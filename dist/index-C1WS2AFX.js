var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
import { HttpAgent, Actor, AnonymousIdentity, Cbor, Expiry, SubmitRequestType, compare as compare$1, requestIdOf, Certificate, LookupStatus, lookupResultToBuffer, IC_ROOT_KEY } from "@dfinity/agent";
import { Ed25519KeyIdentity, ECDSAKeyIdentity, DelegationChain, DelegationIdentity, Delegation } from "@dfinity/identity";
import { Principal } from "@dfinity/principal";
import { asciiStringToByteArray, arrayOfNumberToUint8Array, bigEndianCrc32, uint8ArrayToHexString } from "@dfinity/utils";
import { AuthClient } from "@dfinity/auth-client";
import { lebDecode, PipeArrayBuffer } from "@dfinity/candid";
function getDefaultExportFromCjs$1(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
  var f2 = n.default;
  if (typeof f2 == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a.prototype = f2.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n, k2);
    Object.defineProperty(a, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n[k2];
      }
    });
  });
  return a;
}
var eventemitter3 = { exports: {} };
var hasRequiredEventemitter3;
function requireEventemitter3() {
  if (hasRequiredEventemitter3) return eventemitter3.exports;
  hasRequiredEventemitter3 = 1;
  (function(module) {
    var has = Object.prototype.hasOwnProperty, prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j2;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                args[j2 - 1] = arguments[j2];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    {
      module.exports = EventEmitter2;
    }
  })(eventemitter3);
  return eventemitter3.exports;
}
var eventemitter3Exports = requireEventemitter3();
const EventEmitter$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(eventemitter3Exports);
class WalletError extends Error {
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  constructor(message, error) {
    super(message);
    this.error = error;
  }
}
class WalletNotReadyError extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotReadyError";
  }
}
class WalletLoadError extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletLoadError";
  }
}
class WalletConfigError extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletConfigError";
  }
}
class WalletConnectionError extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletConnectionError";
  }
}
class WalletDisconnectedError extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletDisconnectedError";
  }
}
class WalletDisconnectionError extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletDisconnectionError";
  }
}
class WalletAccountError extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletAccountError";
  }
}
class WalletPublicKeyError extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletPublicKeyError";
  }
}
class WalletNotConnectedError extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotConnectedError";
  }
}
class WalletSendTransactionError extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSendTransactionError";
  }
}
class WalletSignTransactionError extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSignTransactionError";
  }
}
class WalletSignMessageError extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSignMessageError";
  }
}
class WalletWindowClosedError extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletWindowClosedError";
  }
}
var WalletReadyState;
(function(WalletReadyState2) {
  WalletReadyState2["Installed"] = "Installed";
  WalletReadyState2["NotDetected"] = "NotDetected";
  WalletReadyState2["Loadable"] = "Loadable";
  WalletReadyState2["Unsupported"] = "Unsupported";
})(WalletReadyState || (WalletReadyState = {}));
class BaseWalletAdapter extends EventEmitter$1 {
  get connected() {
    return !!this.publicKey;
  }
  async autoConnect() {
    await this.connect();
  }
  async prepareTransaction(transaction, connection, options = {}) {
    const publicKey2 = this.publicKey;
    if (!publicKey2)
      throw new WalletNotConnectedError();
    transaction.feePayer = transaction.feePayer || publicKey2;
    transaction.recentBlockhash = transaction.recentBlockhash || (await connection.getLatestBlockhash({
      commitment: options.preflightCommitment,
      minContextSlot: options.minContextSlot
    })).blockhash;
    return transaction;
  }
}
function scopePollingDetectionStrategy(detect) {
  if (typeof window === "undefined" || typeof document === "undefined")
    return;
  const disposers = [];
  function detectAndDispose() {
    const detected = detect();
    if (detected) {
      for (const dispose of disposers) {
        dispose();
      }
    }
  }
  const interval = (
    // TODO: #334 Replace with idle callback strategy.
    setInterval(detectAndDispose, 1e3)
  );
  disposers.push(() => clearInterval(interval));
  if (
    // Implies that `DOMContentLoaded` has not yet fired.
    document.readyState === "loading"
  ) {
    document.addEventListener("DOMContentLoaded", detectAndDispose, { once: true });
    disposers.push(() => document.removeEventListener("DOMContentLoaded", detectAndDispose));
  }
  if (
    // If the `complete` state has been reached, we're too late.
    document.readyState !== "complete"
  ) {
    window.addEventListener("load", detectAndDispose, { once: true });
    disposers.push(() => window.removeEventListener("load", detectAndDispose));
  }
  detectAndDispose();
}
function isIosAndRedirectable() {
  if (!navigator)
    return false;
  const userAgent = navigator.userAgent.toLowerCase();
  const isIos = userAgent.includes("iphone") || userAgent.includes("ipad");
  const isSafari = userAgent.includes("safari");
  return isIos && isSafari;
}
function isVersionedTransaction(transaction) {
  return "version" in transaction;
}
class BaseSignerWalletAdapter extends BaseWalletAdapter {
  async sendTransaction(transaction, connection, options = {}) {
    let emit = true;
    try {
      if (isVersionedTransaction(transaction)) {
        if (!this.supportedTransactionVersions)
          throw new WalletSendTransactionError(`Sending versioned transactions isn't supported by this wallet`);
        if (!this.supportedTransactionVersions.has(transaction.version))
          throw new WalletSendTransactionError(`Sending transaction version ${transaction.version} isn't supported by this wallet`);
        try {
          transaction = await this.signTransaction(transaction);
          const rawTransaction = transaction.serialize();
          return await connection.sendRawTransaction(rawTransaction, options);
        } catch (error) {
          if (error instanceof WalletSignTransactionError) {
            emit = false;
            throw error;
          }
          throw new WalletSendTransactionError(error?.message, error);
        }
      } else {
        try {
          const { signers, ...sendOptions } = options;
          transaction = await this.prepareTransaction(transaction, connection, sendOptions);
          signers?.length && transaction.partialSign(...signers);
          transaction = await this.signTransaction(transaction);
          const rawTransaction = transaction.serialize();
          return await connection.sendRawTransaction(rawTransaction, sendOptions);
        } catch (error) {
          if (error instanceof WalletSignTransactionError) {
            emit = false;
            throw error;
          }
          throw new WalletSendTransactionError(error?.message, error);
        }
      }
    } catch (error) {
      if (emit) {
        this.emit("error", error);
      }
      throw error;
    }
  }
  async signAllTransactions(transactions) {
    for (const transaction of transactions) {
      if (isVersionedTransaction(transaction)) {
        if (!this.supportedTransactionVersions)
          throw new WalletSignTransactionError(`Signing versioned transactions isn't supported by this wallet`);
        if (!this.supportedTransactionVersions.has(transaction.version))
          throw new WalletSignTransactionError(`Signing transaction version ${transaction.version} isn't supported by this wallet`);
      }
    }
    const signedTransactions = [];
    for (const transaction of transactions) {
      signedTransactions.push(await this.signTransaction(transaction));
    }
    return signedTransactions;
  }
}
class BaseMessageSignerWalletAdapter extends BaseSignerWalletAdapter {
}
const SolanaSignAndSendTransaction = "solana:signAndSendTransaction";
const SolanaSignMessage = "solana:signMessage";
const SolanaSignTransaction = "solana:signTransaction";
const StandardConnect = "standard:connect";
const StandardDisconnect = "standard:disconnect";
const StandardEvents = "standard:events";
var WalletAdapterNetwork;
(function(WalletAdapterNetwork2) {
  WalletAdapterNetwork2["Mainnet"] = "mainnet-beta";
  WalletAdapterNetwork2["Testnet"] = "testnet";
  WalletAdapterNetwork2["Devnet"] = "devnet";
})(WalletAdapterNetwork || (WalletAdapterNetwork = {}));
var Adapter;
((Adapter2) => {
  ((Status2) => {
    Status2["INIT"] = "INIT";
    Status2["READY"] = "READY";
    Status2["CONNECTING"] = "CONNECTING";
    Status2["CONNECTED"] = "CONNECTED";
    Status2["DISCONNECTING"] = "DISCONNECTING";
    Status2["DISCONNECTED"] = "DISCONNECTED";
    Status2["ERROR"] = "ERROR";
  })(Adapter2.Status || (Adapter2.Status = {}));
  ((Chain2) => {
    Chain2["ICP"] = "icp";
    Chain2["SOL"] = "sol";
    Chain2["ETH"] = "eth";
  })(Adapter2.Chain || (Adapter2.Chain = {}));
})(Adapter || (Adapter = {}));
var buffer = {};
var base64Js = {};
var hasRequiredBase64Js;
function requireBase64Js() {
  if (hasRequiredBase64Js) return base64Js;
  hasRequiredBase64Js = 1;
  base64Js.byteLength = byteLength;
  base64Js.toByteArray = toByteArray;
  base64Js.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i2;
    for (i2 = 0; i2 < len2; i2 += 4) {
      tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i2 = start; i2 < end; i2 += 3) {
      tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(
        lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
      );
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(
        lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
      );
    }
    return parts.join("");
  }
  return base64Js;
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredIeee754;
function requireIeee754() {
  if (hasRequiredIeee754) return ieee754;
  hasRequiredIeee754 = 1;
  ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
    var e3, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d2 = isLE ? -1 : 1;
    var s = buffer2[offset + i];
    i += d2;
    e3 = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e3 = e3 * 256 + buffer2[offset + i], i += d2, nBits -= 8) {
    }
    m = e3 & (1 << -nBits) - 1;
    e3 >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer2[offset + i], i += d2, nBits -= 8) {
    }
    if (e3 === 0) {
      e3 = 1 - eBias;
    } else if (e3 === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e3 = e3 - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e3 - mLen);
  };
  ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
    var e3, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d2 = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e3 = eMax;
    } else {
      e3 = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e3)) < 1) {
        e3--;
        c *= 2;
      }
      if (e3 + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e3++;
        c /= 2;
      }
      if (e3 + eBias >= eMax) {
        m = 0;
        e3 = eMax;
      } else if (e3 + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e3 = e3 + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e3 = 0;
      }
    }
    for (; mLen >= 8; buffer2[offset + i] = m & 255, i += d2, m /= 256, mLen -= 8) {
    }
    e3 = e3 << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer2[offset + i] = e3 & 255, i += d2, e3 /= 256, eLen -= 8) {
    }
    buffer2[offset + i - d2] |= s * 128;
  };
  return ieee754;
}
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  (function(exports) {
    const base64 = requireBase64Js();
    const ieee7542 = requireIeee754();
    const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer2;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    const K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e3) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      const b2 = fromObject(value);
      if (b2) return b2;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding2) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding2 === "string" ? createBuffer(size).fill(fill, encoding2) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding2) {
      return alloc(size, fill, encoding2);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string2, encoding2) {
      if (typeof encoding2 !== "string" || encoding2 === "") {
        encoding2 = "utf8";
      }
      if (!Buffer2.isEncoding(encoding2)) {
        throw new TypeError("Unknown encoding: " + encoding2);
      }
      const length = byteLength(string2, encoding2) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string2, encoding2);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array2) {
      const length = array2.length < 0 ? 0 : checked(array2.length) | 0;
      const buf = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf[i] = array2[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array2, byteOffset, length) {
      if (byteOffset < 0 || array2.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array2.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array2);
      } else if (length === void 0) {
        buf = new Uint8Array(array2, byteOffset);
      } else {
        buf = new Uint8Array(array2, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer(b2) {
      return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
    };
    Buffer2.compare = function compare2(a, b2) {
      if (isInstance(a, Uint8Array)) a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b2, Uint8Array)) b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b2)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b2) return 0;
      let x2 = a.length;
      let y = b2.length;
      for (let i = 0, len = Math.min(x2, y); i < len; ++i) {
        if (a[i] !== b2[i]) {
          x2 = a[i];
          y = b2[i];
          break;
        }
      }
      if (x2 < y) return -1;
      if (y < x2) return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding2) {
      switch (String(encoding2).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      const buffer2 = Buffer2.allocUnsafe(length);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer2.length) {
            if (!Buffer2.isBuffer(buf)) buf = Buffer2.from(buf);
            buf.copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer2,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer2, pos);
        }
        pos += buf.length;
      }
      return buffer2;
    };
    function byteLength(string2, encoding2) {
      if (Buffer2.isBuffer(string2)) {
        return string2.length;
      }
      if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
        return string2.byteLength;
      }
      if (typeof string2 !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
        );
      }
      const len = string2.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding2) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes2(string2).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string2).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes2(string2).length;
            }
            encoding2 = ("" + encoding2).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding2, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding2) encoding2 = "utf8";
      while (true) {
        switch (encoding2) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding2);
            encoding2 = (encoding2 + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b2, n, m) {
      const i = b2[n];
      b2[n] = b2[m];
      b2[m] = i;
    }
    Buffer2.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b2) {
      if (!Buffer2.isBuffer(b2)) throw new TypeError("Argument must be a Buffer");
      if (this === b2) return true;
      return Buffer2.compare(this, b2) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      let x2 = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x2, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x2 = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x2 < y) return -1;
      if (y < x2) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding2, dir) {
      if (buffer2.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding2 = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir) return -1;
        else byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding2);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding2, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding2, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding2, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding2 !== void 0) {
        encoding2 = String(encoding2).toLowerCase();
        if (encoding2 === "ucs2" || encoding2 === "ucs-2" || encoding2 === "utf16le" || encoding2 === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j2 = 0; j2 < valLength; j2++) {
            if (read(arr, i + j2) !== read(val, j2)) {
              found = false;
              break;
            }
          }
          if (found) return i;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding2) {
      return this.indexOf(val, byteOffset, encoding2) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding2) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding2, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding2) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding2, false);
    };
    function hexWrite(buf, string2, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string2.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i;
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string2.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string2, offset, length) {
      return blitBuffer(utf8ToBytes2(string2, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string2, offset, length) {
      return blitBuffer(asciiToBytes(string2), buf, offset, length);
    }
    function base64Write(buf, string2, offset, length) {
      return blitBuffer(base64ToBytes(string2), buf, offset, length);
    }
    function ucs2Write(buf, string2, offset, length) {
      return blitBuffer(utf16leToBytes(string2, buf.length - offset), buf, offset, length);
    }
    Buffer2.prototype.write = function write(string2, offset, length, encoding2) {
      if (offset === void 0) {
        encoding2 = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding2 = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding2 === void 0) encoding2 = "utf8";
        } else {
          encoding2 = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining) length = remaining;
      if (string2.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding2) encoding2 = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding2) {
          case "hex":
            return hexWrite(this, string2, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string2, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string2, offset, length);
          case "base64":
            return base64Write(this, string2, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string2, offset, length);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding2);
            encoding2 = ("" + encoding2).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    const MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee7542.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee7542.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee7542.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee7542.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }
      ieee7542.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }
      ieee7542.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding2) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding2 = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding2 = end;
          end = this.length;
        }
        if (encoding2 !== void 0 && typeof encoding2 !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding2 === "string" && !Buffer2.isEncoding(encoding2)) {
          throw new TypeError("Unknown encoding: " + encoding2);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding2 === "utf8" && code < 128 || encoding2 === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding2);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    const errors = {};
    function E2(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E2(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E2(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E2(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length, type2) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type2);
        throw new errors.ERR_OUT_OF_RANGE("offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        "offset",
        `>= ${0} and <= ${length}`,
        value
      );
    }
    const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes2(string2, units) {
      units = units || Infinity;
      let codePoint;
      const length = string2.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string2.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src2, dst, offset, length) {
      let i;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src2.length) break;
        dst[i + offset] = src2[i];
      }
      return i;
    }
    function isInstance(obj, type2) {
      return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    const hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j2 = 0; j2 < 16; ++j2) {
          table[i16 + j2] = alphabet[i] + alphabet[j2];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  })(buffer);
  return buffer;
}
var bufferExports = requireBuffer();
const crypto$1 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function isBytes$1(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function anumber(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error("positive integer expected, got " + n);
}
function abytes$1(b2, ...lengths) {
  if (!isBytes$1(b2))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b2.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b2.length);
}
function ahash(h2) {
  if (typeof h2 !== "function" || typeof h2.create !== "function")
    throw new Error("Hash should be wrapped by utils.createHasher");
  anumber(h2.outputLen);
  anumber(h2.blockLen);
}
function aexists(instance2, checkFinished = true) {
  if (instance2.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance2.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance2) {
  abytes$1(out);
  const min = instance2.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}
function clean(...arrays) {
  for (let i = 0; i < arrays.length; i++) {
    arrays[i].fill(0);
  }
}
function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr(word, shift) {
  return word << 32 - shift | word >>> shift;
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  abytes$1(data);
  return data;
}
function concatBytes$1(...arrays) {
  let sum = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    abytes$1(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad);
    pad += a.length;
  }
  return res;
}
class Hash {
}
function createHasher(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto$1 && typeof crypto$1.getRandomValues === "function") {
    return crypto$1.getRandomValues(new Uint8Array(bytesLength));
  }
  if (crypto$1 && typeof crypto$1.randomBytes === "function") {
    return Uint8Array.from(crypto$1.randomBytes(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}
function setBigUint64(view, byteOffset, value, isLE) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h2 = isLE ? 4 : 0;
  const l = isLE ? 0 : 4;
  view.setUint32(byteOffset + h2, wh, isLE);
  view.setUint32(byteOffset + l, wl, isLE);
}
function Chi(a, b2, c) {
  return a & b2 ^ ~a & c;
}
function Maj(a, b2, c) {
  return a & b2 ^ a & c ^ b2 & c;
}
class HashMD extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE) {
    super();
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    aexists(this);
    data = toBytes(data);
    abytes$1(data);
    const { view, buffer: buffer2, blockLen } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer2.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    this.finished = true;
    const { buffer: buffer2, view, blockLen, isLE } = this;
    let { pos } = this;
    buffer2[pos++] = 128;
    clean(this.buffer.subarray(pos));
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer2[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE);
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer: buffer2, length, finished: finished2, destroyed, pos } = this;
    to.destroyed = destroyed;
    to.finished = finished2;
    to.length = length;
    to.pos = pos;
    if (length % blockLen)
      to.buffer.set(buffer2);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
}
const SHA256_IV = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
const SHA512_IV = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  4089235720,
  3144134277,
  2227873595,
  1013904242,
  4271175723,
  2773480762,
  1595750129,
  1359893119,
  2917565137,
  2600822924,
  725511199,
  528734635,
  4215389547,
  1541459225,
  327033209
]);
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  const len = lst.length;
  let Ah = new Uint32Array(len);
  let Al = new Uint32Array(len);
  for (let i = 0; i < len; i++) {
    const { h: h2, l } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h2, l];
  }
  return [Ah, Al];
}
const shrSH = (h2, _l, s) => h2 >>> s;
const shrSL = (h2, l, s) => h2 << 32 - s | l >>> s;
const rotrSH = (h2, l, s) => h2 >>> s | l << 32 - s;
const rotrSL = (h2, l, s) => h2 << 32 - s | l >>> s;
const rotrBH = (h2, l, s) => h2 << 64 - s | l >>> s - 32;
const rotrBL = (h2, l, s) => h2 >>> s - 32 | l << 64 - s;
function add(Ah, Al, Bh, Bl) {
  const l = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
const SHA256_K = /* @__PURE__ */ Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends HashMD {
  constructor(outputLen = 32) {
    super(64, outputLen, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
    return [A2, B2, C2, D2, E2, F2, G2, H2];
  }
  // prettier-ignore
  set(A2, B2, C2, D2, E2, F2, G2, H2) {
    this.A = A2 | 0;
    this.B = B2 | 0;
    this.C = C2 | 0;
    this.D = D2 | 0;
    this.E = E2 | 0;
    this.F = F2 | 0;
    this.G = G2 | 0;
    this.H = H2 | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA256_W[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A: A2, B: B2, C: C2, D: D2, E: E2, F: F2, G: G2, H: H2 } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E2, 6) ^ rotr(E2, 11) ^ rotr(E2, 25);
      const T1 = H2 + sigma1 + Chi(E2, F2, G2) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A2, 2) ^ rotr(A2, 13) ^ rotr(A2, 22);
      const T2 = sigma0 + Maj(A2, B2, C2) | 0;
      H2 = G2;
      G2 = F2;
      F2 = E2;
      E2 = D2 + T1 | 0;
      D2 = C2;
      C2 = B2;
      B2 = A2;
      A2 = T1 + T2 | 0;
    }
    A2 = A2 + this.A | 0;
    B2 = B2 + this.B | 0;
    C2 = C2 + this.C | 0;
    D2 = D2 + this.D | 0;
    E2 = E2 + this.E | 0;
    F2 = F2 + this.F | 0;
    G2 = G2 + this.G | 0;
    H2 = H2 + this.H | 0;
    this.set(A2, B2, C2, D2, E2, F2, G2, H2);
  }
  roundClean() {
    clean(SHA256_W);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    clean(this.buffer);
  }
}
const K512 = /* @__PURE__ */ (() => split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n) => BigInt(n))))();
const SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
const SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA512 extends HashMD {
  constructor(outputLen = 64) {
    super(128, outputLen, 16, false);
    this.Ah = SHA512_IV[0] | 0;
    this.Al = SHA512_IV[1] | 0;
    this.Bh = SHA512_IV[2] | 0;
    this.Bl = SHA512_IV[3] | 0;
    this.Ch = SHA512_IV[4] | 0;
    this.Cl = SHA512_IV[5] | 0;
    this.Dh = SHA512_IV[6] | 0;
    this.Dl = SHA512_IV[7] | 0;
    this.Eh = SHA512_IV[8] | 0;
    this.El = SHA512_IV[9] | 0;
    this.Fh = SHA512_IV[10] | 0;
    this.Fl = SHA512_IV[11] | 0;
    this.Gh = SHA512_IV[12] | 0;
    this.Gl = SHA512_IV[13] | 0;
    this.Hh = SHA512_IV[14] | 0;
    this.Hl = SHA512_IV[15] | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4) {
      SHA512_W_H[i] = view.getUint32(offset);
      SHA512_W_L[i] = view.getUint32(offset += 4);
    }
    for (let i = 16; i < 80; i++) {
      const W15h = SHA512_W_H[i - 15] | 0;
      const W15l = SHA512_W_L[i - 15] | 0;
      const s0h = rotrSH(W15h, W15l, 1) ^ rotrSH(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);
      const s0l = rotrSL(W15h, W15l, 1) ^ rotrSL(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i - 2] | 0;
      const W2l = SHA512_W_L[i - 2] | 0;
      const s1h = rotrSH(W2h, W2l, 19) ^ rotrBH(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);
      const s1l = rotrSL(W2h, W2l, 19) ^ rotrBL(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);
      const SUMl = add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
      const SUMh = add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
      SHA512_W_H[i] = SUMh | 0;
      SHA512_W_L[i] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i = 0; i < 80; i++) {
      const sigma1h = rotrSH(Eh, El, 14) ^ rotrSH(Eh, El, 18) ^ rotrBH(Eh, El, 41);
      const sigma1l = rotrSL(Eh, El, 14) ^ rotrSL(Eh, El, 18) ^ rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
      const T1h = add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
      const T1l = T1ll | 0;
      const sigma0h = rotrSH(Ah, Al, 28) ^ rotrBH(Ah, Al, 34) ^ rotrBH(Ah, Al, 39);
      const sigma0l = rotrSL(Ah, Al, 28) ^ rotrBL(Ah, Al, 34) ^ rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = add3L(T1l, sigma0l, MAJl);
      Ah = add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    clean(SHA512_W_H, SHA512_W_L);
  }
  destroy() {
    clean(this.buffer);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
const sha256$1 = /* @__PURE__ */ createHasher(() => new SHA256());
const sha512 = /* @__PURE__ */ createHasher(() => new SHA512());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$5 = /* @__PURE__ */ BigInt(0);
const _1n$6 = /* @__PURE__ */ BigInt(1);
function isBytes(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function abytes(item) {
  if (!isBytes(item))
    throw new Error("Uint8Array expected");
}
function abool(title, value) {
  if (typeof value !== "boolean")
    throw new Error(title + " boolean expected, got " + value);
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? "0" + hex : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return hex === "" ? _0n$5 : BigInt("0x" + hex);
}
const hasHexBuiltin = (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
);
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_2, i) => i.toString(16).padStart(2, "0"));
function bytesToHex(bytes) {
  abytes(bytes);
  if (hasHexBuiltin)
    return bytes.toHex();
  let hex = "";
  for (let i = 0; i < bytes.length; i++) {
    hex += hexes[bytes[i]];
  }
  return hex;
}
const asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch) {
  if (ch >= asciis._0 && ch <= asciis._9)
    return ch - asciis._0;
  if (ch >= asciis.A && ch <= asciis.F)
    return ch - (asciis.A - 10);
  if (ch >= asciis.a && ch <= asciis.f)
    return ch - (asciis.a - 10);
  return;
}
function hexToBytes(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  if (hasHexBuiltin)
    return Uint8Array.fromHex(hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array2 = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi));
    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array2[ai] = n1 * 16 + n2;
  }
  return array2;
}
function bytesToNumberBE(bytes) {
  return hexToNumber(bytesToHex(bytes));
}
function bytesToNumberLE(bytes) {
  abytes(bytes);
  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
}
function numberToBytesBE(n, len) {
  return hexToBytes(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n, len) {
  return numberToBytesBE(n, len).reverse();
}
function ensureBytes(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes(hex);
    } catch (e3) {
      throw new Error(title + " must be hex string or Uint8Array, cause: " + e3);
    }
  } else if (isBytes(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(title + " must be hex string or Uint8Array");
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(title + " of length " + expectedLength + " expected, got " + len);
  return res;
}
function concatBytes(...arrays) {
  let sum = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    abytes(a);
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad);
    pad += a.length;
  }
  return res;
}
const isPosBig = (n) => typeof n === "bigint" && _0n$5 <= n;
function inRange$1(n, min, max) {
  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
}
function aInRange(title, n, min, max) {
  if (!inRange$1(n, min, max))
    throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n);
}
function bitLen(n) {
  let len;
  for (len = 0; n > _0n$5; n >>= _1n$6, len += 1)
    ;
  return len;
}
const bitMask = (n) => (_1n$6 << BigInt(n)) - _1n$6;
const u8n = (len) => new Uint8Array(len);
const u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v2 = u8n(hashLen);
  let k2 = u8n(hashLen);
  let i = 0;
  const reset = () => {
    v2.fill(1);
    k2.fill(0);
    i = 0;
  };
  const h2 = (...b2) => hmacFn(k2, v2, ...b2);
  const reseed = (seed = u8n(0)) => {
    k2 = h2(u8fr([0]), seed);
    v2 = h2();
    if (seed.length === 0)
      return;
    k2 = h2(u8fr([1]), seed);
    v2 = h2();
  };
  const gen = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v2 = h2();
      const sl = v2.slice();
      out.push(sl);
      len += v2.length;
    }
    return concatBytes(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
const validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || isBytes(val),
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object) => object.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object, validators, optValidators = {}) {
  const checkField = (fieldName, type2, isOptional) => {
    const checkVal = validatorFns[type2];
    if (typeof checkVal !== "function")
      throw new Error("invalid validator function");
    const val = object[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object)) {
      throw new Error("param " + String(fieldName) + " is invalid. Expected " + type2 + ", got " + val);
    }
  };
  for (const [fieldName, type2] of Object.entries(validators))
    checkField(fieldName, type2, false);
  for (const [fieldName, type2] of Object.entries(optValidators))
    checkField(fieldName, type2, true);
  return object;
}
function memoized(fn) {
  const map = /* @__PURE__ */ new WeakMap();
  return (arg, ...args) => {
    const val = map.get(arg);
    if (val !== void 0)
      return val;
    const computed = fn(arg, ...args);
    map.set(arg, computed);
    return computed;
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$4 = BigInt(0), _1n$5 = BigInt(1), _2n$3 = /* @__PURE__ */ BigInt(2), _3n$1 = /* @__PURE__ */ BigInt(3);
const _4n$1 = /* @__PURE__ */ BigInt(4), _5n$1 = /* @__PURE__ */ BigInt(5), _8n$2 = /* @__PURE__ */ BigInt(8);
function mod(a, b2) {
  const result = a % b2;
  return result >= _0n$4 ? result : b2 + result;
}
function pow2(x2, power, modulo) {
  let res = x2;
  while (power-- > _0n$4) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number2, modulo) {
  if (number2 === _0n$4)
    throw new Error("invert: expected non-zero number");
  if (modulo <= _0n$4)
    throw new Error("invert: expected positive modulus, got " + modulo);
  let a = mod(number2, modulo);
  let b2 = modulo;
  let x2 = _0n$4, u = _1n$5;
  while (a !== _0n$4) {
    const q = b2 / a;
    const r = b2 % a;
    const m = x2 - u * q;
    b2 = a, a = r, x2 = u, u = m;
  }
  const gcd = b2;
  if (gcd !== _1n$5)
    throw new Error("invert: does not exist");
  return mod(x2, modulo);
}
function sqrt3mod4(Fp2, n) {
  const p1div4 = (Fp2.ORDER + _1n$5) / _4n$1;
  const root = Fp2.pow(n, p1div4);
  if (!Fp2.eql(Fp2.sqr(root), n))
    throw new Error("Cannot find square root");
  return root;
}
function sqrt5mod8(Fp2, n) {
  const p5div8 = (Fp2.ORDER - _5n$1) / _8n$2;
  const n2 = Fp2.mul(n, _2n$3);
  const v2 = Fp2.pow(n2, p5div8);
  const nv = Fp2.mul(n, v2);
  const i = Fp2.mul(Fp2.mul(nv, _2n$3), v2);
  const root = Fp2.mul(nv, Fp2.sub(i, Fp2.ONE));
  if (!Fp2.eql(Fp2.sqr(root), n))
    throw new Error("Cannot find square root");
  return root;
}
function tonelliShanks(P2) {
  if (P2 < BigInt(3))
    throw new Error("sqrt is not defined for small field");
  let Q = P2 - _1n$5;
  let S2 = 0;
  while (Q % _2n$3 === _0n$4) {
    Q /= _2n$3;
    S2++;
  }
  let Z = _2n$3;
  const _Fp = Field(P2);
  while (FpLegendre(_Fp, Z) === 1) {
    if (Z++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  }
  if (S2 === 1)
    return sqrt3mod4;
  let cc = _Fp.pow(Z, Q);
  const Q1div2 = (Q + _1n$5) / _2n$3;
  return function tonelliSlow(Fp2, n) {
    if (Fp2.is0(n))
      return n;
    if (FpLegendre(Fp2, n) !== 1)
      throw new Error("Cannot find square root");
    let M2 = S2;
    let c = Fp2.mul(Fp2.ONE, cc);
    let t = Fp2.pow(n, Q);
    let R = Fp2.pow(n, Q1div2);
    while (!Fp2.eql(t, Fp2.ONE)) {
      if (Fp2.is0(t))
        return Fp2.ZERO;
      let i = 1;
      let t_tmp = Fp2.sqr(t);
      while (!Fp2.eql(t_tmp, Fp2.ONE)) {
        i++;
        t_tmp = Fp2.sqr(t_tmp);
        if (i === M2)
          throw new Error("Cannot find square root");
      }
      const exponent = _1n$5 << BigInt(M2 - i - 1);
      const b2 = Fp2.pow(c, exponent);
      M2 = i;
      c = Fp2.sqr(b2);
      t = Fp2.mul(t, c);
      R = Fp2.mul(R, b2);
    }
    return R;
  };
}
function FpSqrt(P2) {
  if (P2 % _4n$1 === _3n$1)
    return sqrt3mod4;
  if (P2 % _8n$2 === _5n$1)
    return sqrt5mod8;
  return tonelliShanks(P2);
}
const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n$5) === _1n$5;
const FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(Fp2, num, power) {
  if (power < _0n$4)
    throw new Error("invalid exponent, negatives unsupported");
  if (power === _0n$4)
    return Fp2.ONE;
  if (power === _1n$5)
    return num;
  let p = Fp2.ONE;
  let d2 = num;
  while (power > _0n$4) {
    if (power & _1n$5)
      p = Fp2.mul(p, d2);
    d2 = Fp2.sqr(d2);
    power >>= _1n$5;
  }
  return p;
}
function FpInvertBatch(Fp2, nums, passZero = false) {
  const inverted = new Array(nums.length).fill(passZero ? Fp2.ZERO : void 0);
  const multipliedAcc = nums.reduce((acc, num, i) => {
    if (Fp2.is0(num))
      return acc;
    inverted[i] = acc;
    return Fp2.mul(acc, num);
  }, Fp2.ONE);
  const invertedAcc = Fp2.inv(multipliedAcc);
  nums.reduceRight((acc, num, i) => {
    if (Fp2.is0(num))
      return acc;
    inverted[i] = Fp2.mul(acc, inverted[i]);
    return Fp2.mul(acc, num);
  }, invertedAcc);
  return inverted;
}
function FpLegendre(Fp2, n) {
  const p1mod2 = (Fp2.ORDER - _1n$5) / _2n$3;
  const powered = Fp2.pow(n, p1mod2);
  const yes = Fp2.eql(powered, Fp2.ONE);
  const zero = Fp2.eql(powered, Fp2.ZERO);
  const no = Fp2.eql(powered, Fp2.neg(Fp2.ONE));
  if (!yes && !zero && !no)
    throw new Error("invalid Legendre symbol result");
  return yes ? 1 : zero ? 0 : -1;
}
function nLength(n, nBitLength) {
  if (nBitLength !== void 0)
    anumber(nBitLength);
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE = false, redef = {}) {
  if (ORDER <= _0n$4)
    throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let sqrtP;
  const f2 = Object.freeze({
    ORDER,
    isLE,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n$4,
    ONE: _1n$5,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof num);
      return _0n$4 <= num && num < ORDER;
    },
    is0: (num) => num === _0n$4,
    isOdd: (num) => (num & _1n$5) === _1n$5,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f2, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n) => {
      if (!sqrtP)
        sqrtP = FpSqrt(ORDER);
      return sqrtP(f2, n);
    }),
    toBytes: (num) => isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes) => {
      if (bytes.length !== BYTES)
        throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes.length);
      return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
    },
    // TODO: we don't need it here, move out to separate fn
    invertBatch: (lst) => FpInvertBatch(f2, lst),
    // We can't move this out because Fp6, Fp12 implement it
    // and it's unclear what to return in there.
    cmov: (a, b2, c) => c ? b2 : a
  });
  return Object.freeze(f2);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
  const num = isLE ? bytesToNumberLE(key) : bytesToNumberBE(key);
  const reduced = mod(num, fieldOrder - _1n$5) + _1n$5;
  return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$3 = BigInt(0);
const _1n$4 = BigInt(1);
function constTimeNegate(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function validateW(W2, bits) {
  if (!Number.isSafeInteger(W2) || W2 <= 0 || W2 > bits)
    throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W2);
}
function calcWOpts(W2, scalarBits) {
  validateW(W2, scalarBits);
  const windows = Math.ceil(scalarBits / W2) + 1;
  const windowSize = 2 ** (W2 - 1);
  const maxNumber = 2 ** W2;
  const mask2 = bitMask(W2);
  const shiftBy = BigInt(W2);
  return { windows, windowSize, mask: mask2, maxNumber, shiftBy };
}
function calcOffsets(n, window2, wOpts) {
  const { windowSize, mask: mask2, maxNumber, shiftBy } = wOpts;
  let wbits = Number(n & mask2);
  let nextN = n >> shiftBy;
  if (wbits > windowSize) {
    wbits -= maxNumber;
    nextN += _1n$4;
  }
  const offsetStart = window2 * windowSize;
  const offset = offsetStart + Math.abs(wbits) - 1;
  const isZero = wbits === 0;
  const isNeg = wbits < 0;
  const isNegF = window2 % 2 !== 0;
  const offsetF = offsetStart;
  return { nextN, offset, isZero, isNeg, isNegF, offsetF };
}
function validateMSMPoints(points, c) {
  if (!Array.isArray(points))
    throw new Error("array expected");
  points.forEach((p, i) => {
    if (!(p instanceof c))
      throw new Error("invalid point at index " + i);
  });
}
function validateMSMScalars(scalars, field) {
  if (!Array.isArray(scalars))
    throw new Error("array of scalars expected");
  scalars.forEach((s, i) => {
    if (!field.isValid(s))
      throw new Error("invalid scalar at index " + i);
  });
}
const pointPrecomputes = /* @__PURE__ */ new WeakMap();
const pointWindowSizes = /* @__PURE__ */ new WeakMap();
function getW(P2) {
  return pointWindowSizes.get(P2) || 1;
}
function wNAF(c, bits) {
  return {
    constTimeNegate,
    hasPrecomputes(elm) {
      return getW(elm) !== 1;
    },
    // non-const time multiplication ladder
    unsafeLadder(elm, n, p = c.ZERO) {
      let d2 = elm;
      while (n > _0n$3) {
        if (n & _1n$4)
          p = p.add(d2);
        d2 = d2.double();
        n >>= _1n$4;
      }
      return p;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param elm Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W2) {
      const { windows, windowSize } = calcWOpts(W2, bits);
      const points = [];
      let p = elm;
      let base2 = p;
      for (let window2 = 0; window2 < windows; window2++) {
        base2 = p;
        points.push(base2);
        for (let i = 1; i < windowSize; i++) {
          base2 = base2.add(p);
          points.push(base2);
        }
        p = base2.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W2, precomputes, n) {
      let p = c.ZERO;
      let f2 = c.BASE;
      const wo = calcWOpts(W2, bits);
      for (let window2 = 0; window2 < wo.windows; window2++) {
        const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window2, wo);
        n = nextN;
        if (isZero) {
          f2 = f2.add(constTimeNegate(isNegF, precomputes[offsetF]));
        } else {
          p = p.add(constTimeNegate(isNeg, precomputes[offset]));
        }
      }
      return { p, f: f2 };
    },
    /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */
    wNAFUnsafe(W2, precomputes, n, acc = c.ZERO) {
      const wo = calcWOpts(W2, bits);
      for (let window2 = 0; window2 < wo.windows; window2++) {
        if (n === _0n$3)
          break;
        const { nextN, offset, isZero, isNeg } = calcOffsets(n, window2, wo);
        n = nextN;
        if (isZero) {
          continue;
        } else {
          const item = precomputes[offset];
          acc = acc.add(isNeg ? item.negate() : item);
        }
      }
      return acc;
    },
    getPrecomputes(W2, P2, transform) {
      let comp = pointPrecomputes.get(P2);
      if (!comp) {
        comp = this.precomputeWindow(P2, W2);
        if (W2 !== 1)
          pointPrecomputes.set(P2, transform(comp));
      }
      return comp;
    },
    wNAFCached(P2, n, transform) {
      const W2 = getW(P2);
      return this.wNAF(W2, this.getPrecomputes(W2, P2, transform), n);
    },
    wNAFCachedUnsafe(P2, n, transform, prev) {
      const W2 = getW(P2);
      if (W2 === 1)
        return this.unsafeLadder(P2, n, prev);
      return this.wNAFUnsafe(W2, this.getPrecomputes(W2, P2, transform), n, prev);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(P2, W2) {
      validateW(W2, bits);
      pointWindowSizes.set(P2, W2);
      pointPrecomputes.delete(P2);
    }
  };
}
function pippenger(c, fieldN, points, scalars) {
  validateMSMPoints(points, c);
  validateMSMScalars(scalars, fieldN);
  const plength = points.length;
  const slength = scalars.length;
  if (plength !== slength)
    throw new Error("arrays of points and scalars must have equal length");
  const zero = c.ZERO;
  const wbits = bitLen(BigInt(plength));
  let windowSize = 1;
  if (wbits > 12)
    windowSize = wbits - 3;
  else if (wbits > 4)
    windowSize = wbits - 2;
  else if (wbits > 0)
    windowSize = 2;
  const MASK = bitMask(windowSize);
  const buckets = new Array(Number(MASK) + 1).fill(zero);
  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
  let sum = zero;
  for (let i = lastBits; i >= 0; i -= windowSize) {
    buckets.fill(zero);
    for (let j2 = 0; j2 < slength; j2++) {
      const scalar = scalars[j2];
      const wbits2 = Number(scalar >> BigInt(i) & MASK);
      buckets[wbits2] = buckets[wbits2].add(points[j2]);
    }
    let resI = zero;
    for (let j2 = buckets.length - 1, sumI = zero; j2 > 0; j2--) {
      sumI = sumI.add(buckets[j2]);
      resI = resI.add(sumI);
    }
    sum = sum.add(resI);
    if (i !== 0)
      for (let j2 = 0; j2 < windowSize; j2++)
        sum = sum.double();
  }
  return sum;
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$2 = BigInt(0), _1n$3 = BigInt(1), _2n$2 = BigInt(2), _8n$1 = BigInt(8);
const VERIFY_DEFAULT = { zip215: true };
function validateOpts$1(curve) {
  const opts = validateBasic(curve);
  validateObject(curve, {
    hash: "function",
    a: "bigint",
    d: "bigint",
    randomBytes: "function"
  }, {
    adjustScalarBytes: "function",
    domain: "function",
    uvRatio: "function",
    mapToCurve: "function"
  });
  return Object.freeze({ ...opts });
}
function twistedEdwards(curveDef) {
  const CURVE = validateOpts$1(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER, prehash, hash: cHash, randomBytes: randomBytes2, nByteLength, h: cofactor } = CURVE;
  const MASK = _2n$2 << BigInt(nByteLength * 8) - _1n$3;
  const modP = Fp2.create;
  const Fn = Field(CURVE.n, CURVE.nBitLength);
  function isEdValidXY(x2, y) {
    const x22 = Fp2.sqr(x2);
    const y2 = Fp2.sqr(y);
    const left = Fp2.add(Fp2.mul(CURVE.a, x22), y2);
    const right = Fp2.add(Fp2.ONE, Fp2.mul(CURVE.d, Fp2.mul(x22, y2)));
    return Fp2.eql(left, right);
  }
  if (!isEdValidXY(CURVE.Gx, CURVE.Gy))
    throw new Error("bad curve params: generator point");
  const uvRatio2 = CURVE.uvRatio || ((u, v2) => {
    try {
      return { isValid: true, value: Fp2.sqrt(u * Fp2.inv(v2)) };
    } catch (e3) {
      return { isValid: false, value: _0n$2 };
    }
  });
  const adjustScalarBytes2 = CURVE.adjustScalarBytes || ((bytes) => bytes);
  const domain = CURVE.domain || ((data, ctx, phflag) => {
    abool("phflag", phflag);
    if (ctx.length || phflag)
      throw new Error("Contexts/pre-hash are not supported");
    return data;
  });
  function aCoordinate(title, n, banZero = false) {
    const min = banZero ? _1n$3 : _0n$2;
    aInRange("coordinate " + title, n, min, MASK);
  }
  function aextpoint(other) {
    if (!(other instanceof Point))
      throw new Error("ExtendedPoint expected");
  }
  const toAffineMemo = memoized((p, iz) => {
    const { ex: x2, ey: y, ez: z2 } = p;
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? _8n$1 : Fp2.inv(z2);
    const ax = modP(x2 * iz);
    const ay = modP(y * iz);
    const zz = modP(z2 * iz);
    if (is0)
      return { x: _0n$2, y: _1n$3 };
    if (zz !== _1n$3)
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized((p) => {
    const { a, d: d2 } = CURVE;
    if (p.is0())
      throw new Error("bad point: ZERO");
    const { ex: X, ey: Y, ez: Z, et: T2 } = p;
    const X2 = modP(X * X);
    const Y2 = modP(Y * Y);
    const Z2 = modP(Z * Z);
    const Z4 = modP(Z2 * Z2);
    const aX2 = modP(X2 * a);
    const left = modP(Z2 * modP(aX2 + Y2));
    const right = modP(Z4 + modP(d2 * modP(X2 * Y2)));
    if (left !== right)
      throw new Error("bad point: equation left != right (1)");
    const XY = modP(X * Y);
    const ZT = modP(Z * T2);
    if (XY !== ZT)
      throw new Error("bad point: equation left != right (2)");
    return true;
  });
  class Point {
    constructor(ex, ey, ez, et) {
      aCoordinate("x", ex);
      aCoordinate("y", ey);
      aCoordinate("z", ez, true);
      aCoordinate("t", et);
      this.ex = ex;
      this.ey = ey;
      this.ez = ez;
      this.et = et;
      Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(p) {
      if (p instanceof Point)
        throw new Error("extended point not allowed");
      const { x: x2, y } = p || {};
      aCoordinate("x", x2);
      aCoordinate("y", y);
      return new Point(x2, y, _1n$3, modP(x2 * y));
    }
    static normalizeZ(points) {
      const toInv = FpInvertBatch(Fp2, points.map((p) => p.ez));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
    }
    // Multiscalar Multiplication
    static msm(points, scalars) {
      return pippenger(Point, Fn, points, scalars);
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      wnaf.setWindowSize(this, windowSize);
    }
    // Not required for fromHex(), which always creates valid points.
    // Could be useful for fromAffine().
    assertValidity() {
      assertValidMemo(this);
    }
    // Compare one point to another.
    equals(other) {
      aextpoint(other);
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const { ex: X2, ey: Y2, ez: Z2 } = other;
      const X1Z2 = modP(X1 * Z2);
      const X2Z1 = modP(X2 * Z1);
      const Y1Z2 = modP(Y1 * Z2);
      const Y2Z1 = modP(Y2 * Z1);
      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    negate() {
      return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));
    }
    // Fast algo for doubling Extended Point.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
    // Cost: 4M + 4S + 1*a + 6add + 1*2.
    double() {
      const { a } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const A2 = modP(X1 * X1);
      const B2 = modP(Y1 * Y1);
      const C2 = modP(_2n$2 * modP(Z1 * Z1));
      const D2 = modP(a * A2);
      const x1y1 = X1 + Y1;
      const E2 = modP(modP(x1y1 * x1y1) - A2 - B2);
      const G3 = D2 + B2;
      const F2 = G3 - C2;
      const H2 = D2 - B2;
      const X3 = modP(E2 * F2);
      const Y3 = modP(G3 * H2);
      const T3 = modP(E2 * H2);
      const Z3 = modP(F2 * G3);
      return new Point(X3, Y3, Z3, T3);
    }
    // Fast algo for adding 2 Extended Points.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
    // Cost: 9M + 1*a + 1*d + 7add.
    add(other) {
      aextpoint(other);
      const { a, d: d2 } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
      const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
      const A2 = modP(X1 * X2);
      const B2 = modP(Y1 * Y2);
      const C2 = modP(T1 * d2 * T2);
      const D2 = modP(Z1 * Z2);
      const E2 = modP((X1 + Y1) * (X2 + Y2) - A2 - B2);
      const F2 = D2 - C2;
      const G3 = D2 + C2;
      const H2 = modP(B2 - a * A2);
      const X3 = modP(E2 * F2);
      const Y3 = modP(G3 * H2);
      const T3 = modP(E2 * H2);
      const Z3 = modP(F2 * G3);
      return new Point(X3, Y3, Z3, T3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    wNAF(n) {
      return wnaf.wNAFCached(this, n, Point.normalizeZ);
    }
    // Constant-time multiplication.
    multiply(scalar) {
      const n = scalar;
      aInRange("scalar", n, _1n$3, CURVE_ORDER);
      const { p, f: f2 } = this.wNAF(n);
      return Point.normalizeZ([p, f2])[0];
    }
    // Non-constant-time multiplication. Uses double-and-add algorithm.
    // It's faster, but should only be used when you don't care about
    // an exposed private key e.g. sig verification.
    // Does NOT allow scalars higher than CURVE.n.
    // Accepts optional accumulator to merge with multiply (important for sparse scalars)
    multiplyUnsafe(scalar, acc = Point.ZERO) {
      const n = scalar;
      aInRange("scalar", n, _0n$2, CURVE_ORDER);
      if (n === _0n$2)
        return I;
      if (this.is0() || n === _1n$3)
        return this;
      return wnaf.wNAFCachedUnsafe(this, n, Point.normalizeZ, acc);
    }
    // Checks if point is of small order.
    // If you add something to small order point, you will have "dirty"
    // point with torsion component.
    // Multiplies point by cofactor and checks if the result is 0.
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    // Multiplies point by curve order and checks if the result is 0.
    // Returns `false` is the point is dirty.
    isTorsionFree() {
      return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    toAffine(iz) {
      return toAffineMemo(this, iz);
    }
    clearCofactor() {
      const { h: cofactor2 } = CURVE;
      if (cofactor2 === _1n$3)
        return this;
      return this.multiplyUnsafe(cofactor2);
    }
    // Converts hash string or Uint8Array to Point.
    // Uses algo from RFC8032 5.1.3.
    static fromHex(hex, zip215 = false) {
      const { d: d2, a } = CURVE;
      const len = Fp2.BYTES;
      hex = ensureBytes("pointHex", hex, len);
      abool("zip215", zip215);
      const normed = hex.slice();
      const lastByte = hex[len - 1];
      normed[len - 1] = lastByte & -129;
      const y = bytesToNumberLE(normed);
      const max = zip215 ? MASK : Fp2.ORDER;
      aInRange("pointHex.y", y, _0n$2, max);
      const y2 = modP(y * y);
      const u = modP(y2 - _1n$3);
      const v2 = modP(d2 * y2 - a);
      let { isValid, value: x2 } = uvRatio2(u, v2);
      if (!isValid)
        throw new Error("Point.fromHex: invalid y coordinate");
      const isXOdd = (x2 & _1n$3) === _1n$3;
      const isLastByteOdd = (lastByte & 128) !== 0;
      if (!zip215 && x2 === _0n$2 && isLastByteOdd)
        throw new Error("Point.fromHex: x=0 and x_0=1");
      if (isLastByteOdd !== isXOdd)
        x2 = modP(-x2);
      return Point.fromAffine({ x: x2, y });
    }
    static fromPrivateKey(privKey) {
      const { scalar } = getPrivateScalar(privKey);
      return G2.multiply(scalar);
    }
    toRawBytes() {
      const { x: x2, y } = this.toAffine();
      const bytes = numberToBytesLE(y, Fp2.BYTES);
      bytes[bytes.length - 1] |= x2 & _1n$3 ? 128 : 0;
      return bytes;
    }
    toHex() {
      return bytesToHex(this.toRawBytes());
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n$3, modP(CURVE.Gx * CURVE.Gy));
  Point.ZERO = new Point(_0n$2, _1n$3, _1n$3, _0n$2);
  const { BASE: G2, ZERO: I } = Point;
  const wnaf = wNAF(Point, nByteLength * 8);
  function modN(a) {
    return mod(a, CURVE_ORDER);
  }
  function modN_LE(hash) {
    return modN(bytesToNumberLE(hash));
  }
  function getPrivateScalar(key) {
    const len = Fp2.BYTES;
    key = ensureBytes("private key", key, len);
    const hashed = ensureBytes("hashed private key", cHash(key), 2 * len);
    const head = adjustScalarBytes2(hashed.slice(0, len));
    const prefix = hashed.slice(len, 2 * len);
    const scalar = modN_LE(head);
    return { head, prefix, scalar };
  }
  function getExtendedPublicKey(key) {
    const { head, prefix, scalar } = getPrivateScalar(key);
    const point = G2.multiply(scalar);
    const pointBytes = point.toRawBytes();
    return { head, prefix, scalar, point, pointBytes };
  }
  function getPublicKey(privKey) {
    return getExtendedPublicKey(privKey).pointBytes;
  }
  function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
    const msg = concatBytes(...msgs);
    return modN_LE(cHash(domain(msg, ensureBytes("context", context), !!prehash)));
  }
  function sign2(msg, privKey, options = {}) {
    msg = ensureBytes("message", msg);
    if (prehash)
      msg = prehash(msg);
    const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
    const r = hashDomainToScalar(options.context, prefix, msg);
    const R = G2.multiply(r).toRawBytes();
    const k2 = hashDomainToScalar(options.context, R, pointBytes, msg);
    const s = modN(r + k2 * scalar);
    aInRange("signature.s", s, _0n$2, CURVE_ORDER);
    const res = concatBytes(R, numberToBytesLE(s, Fp2.BYTES));
    return ensureBytes("result", res, Fp2.BYTES * 2);
  }
  const verifyOpts = VERIFY_DEFAULT;
  function verify2(sig, msg, publicKey2, options = verifyOpts) {
    const { context, zip215 } = options;
    const len = Fp2.BYTES;
    sig = ensureBytes("signature", sig, 2 * len);
    msg = ensureBytes("message", msg);
    publicKey2 = ensureBytes("publicKey", publicKey2, len);
    if (zip215 !== void 0)
      abool("zip215", zip215);
    if (prehash)
      msg = prehash(msg);
    const s = bytesToNumberLE(sig.slice(len, 2 * len));
    let A2, R, SB;
    try {
      A2 = Point.fromHex(publicKey2, zip215);
      R = Point.fromHex(sig.slice(0, len), zip215);
      SB = G2.multiplyUnsafe(s);
    } catch (error) {
      return false;
    }
    if (!zip215 && A2.isSmallOrder())
      return false;
    const k2 = hashDomainToScalar(context, R.toRawBytes(), A2.toRawBytes(), msg);
    const RkA = R.add(A2.multiplyUnsafe(k2));
    return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);
  }
  G2._setWindowSize(8);
  const utils = {
    getExtendedPublicKey,
    /** ed25519 priv keys are uniform 32b. No need to check for modulo bias, like in secp256k1. */
    randomPrivateKey: () => randomBytes2(Fp2.BYTES),
    /**
     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
     * values. This slows down first getPublicKey() by milliseconds (see Speed section),
     * but allows to speed-up subsequent getPublicKey() calls up to 20x.
     * @param windowSize 2, 4, 8, 16
     */
    precompute(windowSize = 8, point = Point.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  return {
    CURVE,
    getPublicKey,
    sign: sign2,
    verify: verify2,
    ExtendedPoint: Point,
    utils
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
const ED25519_SQRT_M1 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
BigInt(0);
const _1n$2 = BigInt(1), _2n$1 = BigInt(2);
BigInt(3);
const _5n = BigInt(5), _8n = BigInt(8);
function ed25519_pow_2_252_3(x2) {
  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
  const P2 = ED25519_P;
  const x22 = x2 * x2 % P2;
  const b2 = x22 * x2 % P2;
  const b4 = pow2(b2, _2n$1, P2) * b2 % P2;
  const b5 = pow2(b4, _1n$2, P2) * x2 % P2;
  const b10 = pow2(b5, _5n, P2) * b5 % P2;
  const b20 = pow2(b10, _10n, P2) * b10 % P2;
  const b40 = pow2(b20, _20n, P2) * b20 % P2;
  const b80 = pow2(b40, _40n, P2) * b40 % P2;
  const b160 = pow2(b80, _80n, P2) * b80 % P2;
  const b240 = pow2(b160, _80n, P2) * b80 % P2;
  const b250 = pow2(b240, _10n, P2) * b10 % P2;
  const pow_p_5_8 = pow2(b250, _2n$1, P2) * x2 % P2;
  return { pow_p_5_8, b2 };
}
function adjustScalarBytes(bytes) {
  bytes[0] &= 248;
  bytes[31] &= 127;
  bytes[31] |= 64;
  return bytes;
}
function uvRatio(u, v2) {
  const P2 = ED25519_P;
  const v32 = mod(v2 * v2 * v2, P2);
  const v7 = mod(v32 * v32 * v2, P2);
  const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
  let x2 = mod(u * v32 * pow, P2);
  const vx2 = mod(v2 * x2 * x2, P2);
  const root1 = x2;
  const root2 = mod(x2 * ED25519_SQRT_M1, P2);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod(-u, P2);
  const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P2);
  if (useRoot1)
    x2 = root1;
  if (useRoot2 || noRoot)
    x2 = root2;
  if (isNegativeLE(x2, P2))
    x2 = mod(-x2, P2);
  return { isValid: useRoot1 || useRoot2, value: x2 };
}
const Fp = /* @__PURE__ */ (() => Field(ED25519_P, void 0, true))();
const ed25519Defaults = /* @__PURE__ */ (() => ({
  // Removing Fp.create() will still work, and is 10% faster on sign
  a: Fp.create(BigInt(-1)),
  // d is -121665/121666 a.k.a. Fp.neg(121665 * Fp.inv(121666))
  d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
  // Finite field 2n**255n - 19n
  Fp,
  // Subgroup order 2n**252n + 27742317777372353535851937790883648493n;
  n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
  h: _8n,
  Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
  Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
  hash: sha512,
  randomBytes,
  adjustScalarBytes,
  // dom2
  // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
  // Constant-time, u/v
  uvRatio
}))();
const ed25519 = /* @__PURE__ */ (() => twistedEdwards(ed25519Defaults))();
var bn$1 = { exports: {} };
var bn = bn$1.exports;
var hasRequiredBn;
function requireBn() {
  if (hasRequiredBn) return bn$1.exports;
  hasRequiredBn = 1;
  (function(module) {
    (function(module2, exports) {
      function assert2(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN2(number2, base2, endian) {
        if (BN2.isBN(number2)) {
          return number2;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number2 !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number2 || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN2;
      } else {
        exports.BN = BN2;
      }
      BN2.BN = BN2;
      BN2.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = requireBuffer().Buffer;
        }
      } catch (e3) {
      }
      BN2.isBN = function isBN(num) {
        if (num instanceof BN2) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
      };
      BN2.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };
      BN2.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };
      BN2.prototype._init = function init(number2, base2, endian) {
        if (typeof number2 === "number") {
          return this._initNumber(number2, base2, endian);
        }
        if (typeof number2 === "object") {
          return this._initArray(number2, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert2(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number2 = number2.toString().replace(/\s+/g, "");
        var start = 0;
        if (number2[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number2.length) {
          if (base2 === 16) {
            this._parseHex(number2, start, endian);
          } else {
            this._parseBase(number2, base2, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base2, endian);
            }
          }
        }
      };
      BN2.prototype._initNumber = function _initNumber(number2, base2, endian) {
        if (number2 < 0) {
          this.negative = 1;
          number2 = -number2;
        }
        if (number2 < 67108864) {
          this.words = [number2 & 67108863];
          this.length = 1;
        } else if (number2 < 4503599627370496) {
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert2(number2 < 9007199254740992);
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le") return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN2.prototype._initArray = function _initArray(number2, base2, endian) {
        assert2(typeof number2.length === "number");
        if (number2.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number2.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j2, w2;
        var off = 0;
        if (endian === "be") {
          for (i = number2.length - 1, j2 = 0; i >= 0; i -= 3) {
            w2 = number2[i] | number2[i - 1] << 8 | number2[i - 2] << 16;
            this.words[j2] |= w2 << off & 67108863;
            this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j2++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j2 = 0; i < number2.length; i += 3) {
            w2 = number2[i] | number2[i + 1] << 8 | number2[i + 2] << 16;
            this.words[j2] |= w2 << off & 67108863;
            this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j2++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string2, index) {
        var c = string2.charCodeAt(index);
        if (c >= 48 && c <= 57) {
          return c - 48;
        } else if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          assert2(false, "Invalid character in " + string2);
        }
      }
      function parseHexByte(string2, lowerBound, index) {
        var r = parseHex4Bits(string2, index);
        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string2, index - 1) << 4;
        }
        return r;
      }
      BN2.prototype._parseHex = function _parseHex(number2, start, endian) {
        this.length = Math.ceil((number2.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j2 = 0;
        var w2;
        if (endian === "be") {
          for (i = number2.length - 1; i >= start; i -= 2) {
            w2 = parseHexByte(number2, start, i) << off;
            this.words[j2] |= w2 & 67108863;
            if (off >= 18) {
              off -= 18;
              j2 += 1;
              this.words[j2] |= w2 >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number2.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number2.length; i += 2) {
            w2 = parseHexByte(number2, start, i) << off;
            this.words[j2] |= w2 & 67108863;
            if (off >= 18) {
              off -= 18;
              j2 += 1;
              this.words[j2] |= w2 >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var b2 = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            b2 = c - 49 + 10;
          } else if (c >= 17) {
            b2 = c - 17 + 10;
          } else {
            b2 = c;
          }
          assert2(c >= 0 && b2 < mul, "Invalid character");
          r += b2;
        }
        return r;
      }
      BN2.prototype._parseBase = function _parseBase(number2, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number2.length - start;
        var mod2 = total % limbLen;
        var end = Math.min(total, total - mod2) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number2, i, i + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod2 !== 0) {
          var pow = 1;
          word = parseBase(number2, i, number2.length, base2);
          for (i = 0; i < mod2; i++) {
            pow *= base2;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN2.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src2) {
        dest.words = src2.words;
        dest.length = src2.length;
        dest.negative = src2.negative;
        dest.red = src2.red;
      }
      BN2.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN2.prototype.clone = function clone2() {
        var r = new BN2(null);
        this.copy(r);
        return r;
      };
      BN2.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN2.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN2.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
        } catch (e3) {
          BN2.prototype.inspect = inspect;
        }
      } else {
        BN2.prototype.inspect = inspect;
      }
      function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN2.prototype.toString = function toString(base2, padding) {
        base2 = base2 || 10;
        padding = padding | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w2 = this.words[i];
            var word = ((w2 << off | carry) & 16777215).toString(16);
            carry = w2 >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modrn(groupBase).toString(base2);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert2(false, "Base should be between 2 and 36");
      };
      BN2.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert2(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN2.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
      };
      if (Buffer2) {
        BN2.prototype.toBuffer = function toBuffer2(endian, length) {
          return this.toArrayLike(Buffer2, endian, length);
        };
      }
      BN2.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert2(byteLength <= reqLength, "byte array longer than desired length");
        assert2(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
      };
      BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN2.prototype._countBits = function _countBits(w2) {
          return 32 - Math.clz32(w2);
        };
      } else {
        BN2.prototype._countBits = function _countBits(w2) {
          var t = w2;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN2.prototype._zeroBits = function _zeroBits(w2) {
        if (w2 === 0) return 26;
        var t = w2;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN2.prototype.bitLength = function bitLength() {
        var w2 = this.words[this.length - 1];
        var hi = this._countBits(w2);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w2 = new Array(num.bitLength());
        for (var bit = 0; bit < w2.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w2[bit] = num.words[off] >>> wbit & 1;
        }
        return w2;
      }
      BN2.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b2 = this._zeroBits(this.words[i]);
          r += b2;
          if (b2 !== 26) break;
        }
        return r;
      };
      BN2.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN2.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN2.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN2.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN2.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN2.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN2.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this._strip();
      };
      BN2.prototype.ior = function ior(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN2.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN2.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN2.prototype.iuand = function iuand(num) {
        var b2;
        if (this.length > num.length) {
          b2 = num;
        } else {
          b2 = this;
        }
        for (var i = 0; i < b2.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b2.length;
        return this._strip();
      };
      BN2.prototype.iand = function iand(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN2.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN2.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN2.prototype.iuxor = function iuxor(num) {
        var a;
        var b2;
        if (this.length > num.length) {
          a = this;
          b2 = num;
        } else {
          a = num;
          b2 = this;
        }
        for (var i = 0; i < b2.length; i++) {
          this.words[i] = a.words[i] ^ b2.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this._strip();
      };
      BN2.prototype.ixor = function ixor(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN2.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN2.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN2.prototype.inotn = function inotn(width) {
        assert2(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN2.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN2.prototype.setn = function setn(bit, val) {
        assert2(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN2.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b2;
        if (this.length > num.length) {
          a = this;
          b2 = num;
        } else {
          a = num;
          b2 = this;
        }
        var carry = 0;
        for (var i = 0; i < b2.length; i++) {
          r = (a.words[i] | 0) + (b2.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN2.prototype.add = function add2(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN2.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b2;
        if (cmp > 0) {
          a = this;
          b2 = num;
        } else {
          a = num;
          b2 = this;
        }
        var carry = 0;
        for (var i = 0; i < b2.length; i++) {
          r = (a.words[i] | 0) - (b2.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN2.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        var len = self.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self.words[0] | 0;
        var b2 = num.words[0] | 0;
        var r = a * b2;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k2 = 1; k2 < len; k2++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k2, num.length - 1);
          for (var j2 = Math.max(0, k2 - self.length + 1); j2 <= maxJ; j2++) {
            var i = k2 - j2 | 0;
            a = self.words[i] | 0;
            b2 = num.words[j2] | 0;
            r = a * b2 + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k2] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k2] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self, num, out) {
        var a = self.words;
        var b2 = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b2[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b2[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b2[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b3 = b2[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b2[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b2[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b2[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b2[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b2[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b2[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        out.length = self.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k2 = 0; k2 < out.length - 1; k2++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k2, num.length - 1);
          for (var j2 = Math.max(0, k2 - self.length + 1); j2 <= maxJ; j2++) {
            var i = k2 - j2;
            var a = self.words[i] | 0;
            var b2 = num.words[j2] | 0;
            var r = a * b2;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k2] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k2] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self, num, out) {
        return bigMulTo(self, num, out);
      }
      BN2.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      BN2.prototype.mul = function mul(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN2.prototype.mulf = function mulf(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN2.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN2.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert2(typeof num === "number");
        assert2(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w2 = (this.words[i] | 0) * num;
          var lo = (w2 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w2 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        this.length = num === 0 ? 1 : this.length;
        return isNegNum ? this.ineg() : this;
      };
      BN2.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN2.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN2.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN2.prototype.pow = function pow(num) {
        var w2 = toBitArray(num);
        if (w2.length === 0) return new BN2(1);
        var res = this;
        for (var i = 0; i < w2.length; i++, res = res.sqr()) {
          if (w2[i] !== 0) break;
        }
        if (++i < w2.length) {
          for (var q = res.sqr(); i < w2.length; i++, q = q.sqr()) {
            if (w2[i] === 0) continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN2.prototype.iushln = function iushln(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this._strip();
      };
      BN2.prototype.ishln = function ishln(bits) {
        assert2(this.negative === 0);
        return this.iushln(bits);
      };
      BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert2(typeof bits === "number" && bits >= 0);
        var h2;
        if (hint) {
          h2 = (hint - hint % 26) / 26;
        } else {
          h2 = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask2 = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h2 -= s;
        h2 = Math.max(0, h2);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) ;
        else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h2); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask2;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert2(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN2.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN2.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN2.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN2.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN2.prototype.testn = function testn(bit) {
        assert2(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) return false;
        var w2 = this.words[s];
        return !!(w2 & q);
      };
      BN2.prototype.imaskn = function imaskn(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert2(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask2 = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask2;
        }
        return this._strip();
      };
      BN2.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN2.prototype.iaddn = function iaddn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0) return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN2.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN2.prototype.isubn = function isubn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN2.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN2.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN2.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN2.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w2;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w2 = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w2 -= right & 67108863;
          carry = (w2 >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w2 & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w2 = (this.words[i + shift] | 0) + carry;
          carry = w2 >> 26;
          this.words[i + shift] = w2 & 67108863;
        }
        if (carry === 0) return this._strip();
        assert2(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w2 = -(this.words[i] | 0) + carry;
          carry = w2 >> 26;
          this.words[i] = w2 & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN2.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b2 = num;
        var bhi = b2.words[b2.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b2 = b2.ushln(shift);
          a.iushln(shift);
          bhi = b2.words[b2.length - 1] | 0;
        }
        var m = a.length - b2.length;
        var q;
        if (mode !== "mod") {
          q = new BN2(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b2, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j2 = m - 1; j2 >= 0; j2--) {
          var qj = (a.words[b2.length + j2] | 0) * 67108864 + (a.words[b2.length + j2 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b2, qj, j2);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b2, 1, j2);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j2] = qj;
          }
        }
        if (q) {
          q._strip();
        }
        a._strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN2.prototype.divmod = function divmod(num, mode, positive) {
        assert2(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN2(0),
            mod: new BN2(0)
          };
        }
        var div, mod2, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.iadd(num);
            }
          }
          return {
            div,
            mod: mod2
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod2
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN2(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN2(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN2(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN2.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN2.prototype.mod = function mod2(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN2.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN2.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero()) return dm.div;
        var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod2.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN2.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert2(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN2.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN2.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert2(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w2 = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w2 / num | 0;
          carry = w2 % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN2.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN2.prototype.egcd = function egcd(p) {
        assert2(p.negative === 0);
        assert2(!p.isZero());
        var x2 = this;
        var y = p.clone();
        if (x2.negative !== 0) {
          x2 = x2.umod(p);
        } else {
          x2 = x2.clone();
        }
        var A2 = new BN2(1);
        var B2 = new BN2(0);
        var C2 = new BN2(0);
        var D2 = new BN2(1);
        var g2 = 0;
        while (x2.isEven() && y.isEven()) {
          x2.iushrn(1);
          y.iushrn(1);
          ++g2;
        }
        var yp = y.clone();
        var xp = x2.clone();
        while (!x2.isZero()) {
          for (var i = 0, im = 1; (x2.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            x2.iushrn(i);
            while (i-- > 0) {
              if (A2.isOdd() || B2.isOdd()) {
                A2.iadd(yp);
                B2.isub(xp);
              }
              A2.iushrn(1);
              B2.iushrn(1);
            }
          }
          for (var j2 = 0, jm = 1; (y.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1) ;
          if (j2 > 0) {
            y.iushrn(j2);
            while (j2-- > 0) {
              if (C2.isOdd() || D2.isOdd()) {
                C2.iadd(yp);
                D2.isub(xp);
              }
              C2.iushrn(1);
              D2.iushrn(1);
            }
          }
          if (x2.cmp(y) >= 0) {
            x2.isub(y);
            A2.isub(C2);
            B2.isub(D2);
          } else {
            y.isub(x2);
            C2.isub(A2);
            D2.isub(B2);
          }
        }
        return {
          a: C2,
          b: D2,
          gcd: y.iushln(g2)
        };
      };
      BN2.prototype._invmp = function _invmp(p) {
        assert2(p.negative === 0);
        assert2(!p.isZero());
        var a = this;
        var b2 = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN2(1);
        var x2 = new BN2(0);
        var delta = b2.clone();
        while (a.cmpn(1) > 0 && b2.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j2 = 0, jm = 1; (b2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1) ;
          if (j2 > 0) {
            b2.iushrn(j2);
            while (j2-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b2) >= 0) {
            a.isub(b2);
            x1.isub(x2);
          } else {
            b2.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN2.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b2 = num.clone();
        a.negative = 0;
        b2.negative = 0;
        for (var shift = 0; a.isEven() && b2.isEven(); shift++) {
          a.iushrn(1);
          b2.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b2.isEven()) {
            b2.iushrn(1);
          }
          var r = a.cmp(b2);
          if (r < 0) {
            var t = a;
            a = b2;
            b2 = t;
          } else if (r === 0 || b2.cmpn(1) === 0) {
            break;
          }
          a.isub(b2);
        } while (true);
        return b2.iushln(shift);
      };
      BN2.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN2.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN2.prototype.isOdd = function isOdd2() {
        return (this.words[0] & 1) === 1;
      };
      BN2.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN2.prototype.bincn = function bincn(bit) {
        assert2(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w2 = this.words[i] | 0;
          w2 += carry;
          carry = w2 >>> 26;
          w2 &= 67108863;
          this.words[i] = w2;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN2.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert2(num <= 67108863, "Number is too big");
          var w2 = this.words[0] | 0;
          res = w2 === num ? 0 : w2 < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN2.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN2.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b2 = num.words[i] | 0;
          if (a === b2) continue;
          if (a < b2) {
            res = -1;
          } else if (a > b2) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN2.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN2.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN2.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN2.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN2.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN2.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN2.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN2.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN2.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN2.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN2.red = function red(num) {
        return new Red(num);
      };
      BN2.prototype.toRed = function toRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        assert2(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN2.prototype.fromRed = function fromRed() {
        assert2(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN2.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN2.prototype.forceRed = function forceRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN2.prototype.redAdd = function redAdd(num) {
        assert2(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN2.prototype.redIAdd = function redIAdd(num) {
        assert2(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN2.prototype.redSub = function redSub(num) {
        assert2(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN2.prototype.redISub = function redISub(num) {
        assert2(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN2.prototype.redShl = function redShl(num) {
        assert2(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN2.prototype.redMul = function redMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN2.prototype.redIMul = function redIMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN2.prototype.redSqr = function redSqr() {
        assert2(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN2.prototype.redISqr = function redISqr() {
        assert2(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN2.prototype.redSqrt = function redSqrt() {
        assert2(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN2.prototype.redInvm = function redInvm() {
        assert2(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN2.prototype.redNeg = function redNeg() {
        assert2(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN2.prototype.redPow = function redPow(num) {
        assert2(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN2(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN2(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN2(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split2(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split2(input, output) {
        var mask2 = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask2;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask2) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w2 = num.words[i] | 0;
          lo += w2 * 977;
          num.words[i] = lo & 67108863;
          lo = w2 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN2._prime = function prime(name) {
        if (primes[name]) return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN2._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert2(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert2(a.negative === 0, "red works only with positives");
        assert2(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b2) {
        assert2((a.negative | b2.negative) === 0, "red works only with positives");
        assert2(
          a.red && a.red === b2.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        move(a, a.umod(this.m)._forceRed(this));
        return a;
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add2(a, b2) {
        this._verify2(a, b2);
        var res = a.add(b2);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b2) {
        this._verify2(a, b2);
        var res = a.iadd(b2);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b2) {
        this._verify2(a, b2);
        var res = a.sub(b2);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b2) {
        this._verify2(a, b2);
        var res = a.isub(b2);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b2) {
        this._verify2(a, b2);
        return this.imod(a.imul(b2));
      };
      Red.prototype.mul = function mul(a, b2) {
        this._verify2(a, b2);
        return this.imod(a.mul(b2));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert2(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN2(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert2(!q.isZero());
        var one = new BN2(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z2 = this.m.bitLength();
        z2 = new BN2(2 * z2 * z2).toRed(this);
        while (this.pow(z2, lpow).cmp(nOne) !== 0) {
          z2.redIAdd(nOne);
        }
        var c = this.pow(z2, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert2(i < m);
          var b2 = this.pow(c, new BN2(1).iushln(m - i - 1));
          r = r.redMul(b2);
          c = b2.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero()) return new BN2(1).toRed(this);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN2(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j2 = start - 1; j2 >= 0; j2--) {
            var bit = word >> j2 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j2 !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN2.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN2(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b2) {
        if (a.isZero() || b2.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b2);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b2) {
        if (a.isZero() || b2.isZero()) return new BN2(0)._forceRed(this);
        var t = a.mul(b2);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(module, bn);
  })(bn$1);
  return bn$1.exports;
}
var bnExports = requireBn();
const BN = /* @__PURE__ */ getDefaultExportFromCjs$1(bnExports);
var safeBuffer = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredSafeBuffer;
function requireSafeBuffer() {
  if (hasRequiredSafeBuffer) return safeBuffer.exports;
  hasRequiredSafeBuffer = 1;
  (function(module, exports) {
    var buffer2 = requireBuffer();
    var Buffer2 = buffer2.Buffer;
    function copyProps(src2, dst) {
      for (var key in src2) {
        dst[key] = src2[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer2;
    } else {
      copyProps(buffer2, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding2) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding2 === "string") {
          buf.fill(fill, encoding2);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  })(safeBuffer, safeBuffer.exports);
  return safeBuffer.exports;
}
var src;
var hasRequiredSrc;
function requireSrc() {
  if (hasRequiredSrc) return src;
  hasRequiredSrc = 1;
  var _Buffer = requireSafeBuffer().Buffer;
  function base2(ALPHABET2) {
    if (ALPHABET2.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j2 = 0; j2 < BASE_MAP.length; j2++) {
      BASE_MAP[j2] = 255;
    }
    for (var i = 0; i < ALPHABET2.length; i++) {
      var x2 = ALPHABET2.charAt(i);
      var xc = x2.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x2 + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE2 = ALPHABET2.length;
    var LEADER = ALPHABET2.charAt(0);
    var FACTOR = Math.log(BASE2) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE2);
    function encode2(source) {
      if (Array.isArray(source) || source instanceof Uint8Array) {
        source = _Buffer.from(source);
      }
      if (!_Buffer.isBuffer(source)) {
        throw new TypeError("Expected Buffer");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i2 = 0;
        for (var it1 = size - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE2 >>> 0;
          carry = carry / BASE2 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length = i2;
        pbegin++;
      }
      var it2 = size - length;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET2.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return _Buffer.alloc(0);
      }
      var psz = 0;
      var zeroes = 0;
      var length = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (psz < source.length) {
        var charCode = source.charCodeAt(psz);
        if (charCode > 255) {
          return;
        }
        var carry = BASE_MAP[charCode];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
          carry += BASE2 * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length = i2;
        psz++;
      }
      var it4 = size - length;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
      vch.fill(0, 0, zeroes);
      var j3 = zeroes;
      while (it4 !== size) {
        vch[j3++] = b256[it4++];
      }
      return vch;
    }
    function decode2(string2) {
      var buffer2 = decodeUnsafe(string2);
      if (buffer2) {
        return buffer2;
      }
      throw new Error("Non-base" + BASE2 + " character");
    }
    return {
      encode: encode2,
      decodeUnsafe,
      decode: decode2
    };
  }
  src = base2;
  return src;
}
var bs58$1;
var hasRequiredBs58;
function requireBs58() {
  if (hasRequiredBs58) return bs58$1;
  hasRequiredBs58 = 1;
  var basex = requireSrc();
  var ALPHABET2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  bs58$1 = basex(ALPHABET2);
  return bs58$1;
}
var bs58Exports = requireBs58();
const bs58 = /* @__PURE__ */ getDefaultExportFromCjs$1(bs58Exports);
const sha256 = sha256$1;
var lib = {};
function inRange(a, min, max) {
  return min <= a && a <= max;
}
function ToDictionary(o) {
  if (o === void 0) return {};
  if (o === Object(o)) return o;
  throw TypeError("Could not convert argument to dictionary");
}
function stringToCodePoints(string2) {
  var s = String(string2);
  var n = s.length;
  var i = 0;
  var u = [];
  while (i < n) {
    var c = s.charCodeAt(i);
    if (c < 55296 || c > 57343) {
      u.push(c);
    } else if (56320 <= c && c <= 57343) {
      u.push(65533);
    } else if (55296 <= c && c <= 56319) {
      if (i === n - 1) {
        u.push(65533);
      } else {
        var d2 = string2.charCodeAt(i + 1);
        if (56320 <= d2 && d2 <= 57343) {
          var a = c & 1023;
          var b2 = d2 & 1023;
          u.push(65536 + (a << 10) + b2);
          i += 1;
        } else {
          u.push(65533);
        }
      }
    }
    i += 1;
  }
  return u;
}
function codePointsToString(code_points) {
  var s = "";
  for (var i = 0; i < code_points.length; ++i) {
    var cp = code_points[i];
    if (cp <= 65535) {
      s += String.fromCharCode(cp);
    } else {
      cp -= 65536;
      s += String.fromCharCode(
        (cp >> 10) + 55296,
        (cp & 1023) + 56320
      );
    }
  }
  return s;
}
var end_of_stream = -1;
function Stream(tokens) {
  this.tokens = [].slice.call(tokens);
}
Stream.prototype = {
  /**
   * @return {boolean} True if end-of-stream has been hit.
   */
  endOfStream: function() {
    return !this.tokens.length;
  },
  /**
   * When a token is read from a stream, the first token in the
   * stream must be returned and subsequently removed, and
   * end-of-stream must be returned otherwise.
   *
   * @return {number} Get the next token from the stream, or
   * end_of_stream.
   */
  read: function() {
    if (!this.tokens.length)
      return end_of_stream;
    return this.tokens.shift();
  },
  /**
   * When one or more tokens are prepended to a stream, those tokens
   * must be inserted, in given order, before the first token in the
   * stream.
   *
   * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.
   */
  prepend: function(token) {
    if (Array.isArray(token)) {
      var tokens = (
        /**@type {!Array.<number>}*/
        token
      );
      while (tokens.length)
        this.tokens.unshift(tokens.pop());
    } else {
      this.tokens.unshift(token);
    }
  },
  /**
   * When one or more tokens are pushed to a stream, those tokens
   * must be inserted, in given order, after the last token in the
   * stream.
   *
   * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.
   */
  push: function(token) {
    if (Array.isArray(token)) {
      var tokens = (
        /**@type {!Array.<number>}*/
        token
      );
      while (tokens.length)
        this.tokens.push(tokens.shift());
    } else {
      this.tokens.push(token);
    }
  }
};
var finished = -1;
function decoderError(fatal, opt_code_point) {
  if (fatal)
    throw TypeError("Decoder error");
  return opt_code_point || 65533;
}
var DEFAULT_ENCODING = "utf-8";
function TextDecoder$1(encoding2, options) {
  if (!(this instanceof TextDecoder$1)) {
    return new TextDecoder$1(encoding2, options);
  }
  encoding2 = encoding2 !== void 0 ? String(encoding2).toLowerCase() : DEFAULT_ENCODING;
  if (encoding2 !== DEFAULT_ENCODING) {
    throw new Error("Encoding not supported. Only utf-8 is supported");
  }
  options = ToDictionary(options);
  this._streaming = false;
  this._BOMseen = false;
  this._decoder = null;
  this._fatal = Boolean(options["fatal"]);
  this._ignoreBOM = Boolean(options["ignoreBOM"]);
  Object.defineProperty(this, "encoding", { value: "utf-8" });
  Object.defineProperty(this, "fatal", { value: this._fatal });
  Object.defineProperty(this, "ignoreBOM", { value: this._ignoreBOM });
}
TextDecoder$1.prototype = {
  /**
   * @param {ArrayBufferView=} input The buffer of bytes to decode.
   * @param {Object=} options
   * @return {string} The decoded string.
   */
  decode: function decode(input, options) {
    var bytes;
    if (typeof input === "object" && input instanceof ArrayBuffer) {
      bytes = new Uint8Array(input);
    } else if (typeof input === "object" && "buffer" in input && input.buffer instanceof ArrayBuffer) {
      bytes = new Uint8Array(
        input.buffer,
        input.byteOffset,
        input.byteLength
      );
    } else {
      bytes = new Uint8Array(0);
    }
    options = ToDictionary(options);
    if (!this._streaming) {
      this._decoder = new UTF8Decoder({ fatal: this._fatal });
      this._BOMseen = false;
    }
    this._streaming = Boolean(options["stream"]);
    var input_stream = new Stream(bytes);
    var code_points = [];
    var result;
    while (!input_stream.endOfStream()) {
      result = this._decoder.handler(input_stream, input_stream.read());
      if (result === finished)
        break;
      if (result === null)
        continue;
      if (Array.isArray(result))
        code_points.push.apply(
          code_points,
          /**@type {!Array.<number>}*/
          result
        );
      else
        code_points.push(result);
    }
    if (!this._streaming) {
      do {
        result = this._decoder.handler(input_stream, input_stream.read());
        if (result === finished)
          break;
        if (result === null)
          continue;
        if (Array.isArray(result))
          code_points.push.apply(
            code_points,
            /**@type {!Array.<number>}*/
            result
          );
        else
          code_points.push(result);
      } while (!input_stream.endOfStream());
      this._decoder = null;
    }
    if (code_points.length) {
      if (["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen) {
        if (code_points[0] === 65279) {
          this._BOMseen = true;
          code_points.shift();
        } else {
          this._BOMseen = true;
        }
      }
    }
    return codePointsToString(code_points);
  }
};
function TextEncoder$1(encoding2, options) {
  if (!(this instanceof TextEncoder$1))
    return new TextEncoder$1(encoding2, options);
  encoding2 = encoding2 !== void 0 ? String(encoding2).toLowerCase() : DEFAULT_ENCODING;
  if (encoding2 !== DEFAULT_ENCODING) {
    throw new Error("Encoding not supported. Only utf-8 is supported");
  }
  options = ToDictionary(options);
  this._streaming = false;
  this._encoder = null;
  this._options = { fatal: Boolean(options["fatal"]) };
  Object.defineProperty(this, "encoding", { value: "utf-8" });
}
TextEncoder$1.prototype = {
  /**
   * @param {string=} opt_string The string to encode.
   * @param {Object=} options
   * @return {Uint8Array} Encoded bytes, as a Uint8Array.
   */
  encode: function encode(opt_string, options) {
    opt_string = opt_string ? String(opt_string) : "";
    options = ToDictionary(options);
    if (!this._streaming)
      this._encoder = new UTF8Encoder(this._options);
    this._streaming = Boolean(options["stream"]);
    var bytes = [];
    var input_stream = new Stream(stringToCodePoints(opt_string));
    var result;
    while (!input_stream.endOfStream()) {
      result = this._encoder.handler(input_stream, input_stream.read());
      if (result === finished)
        break;
      if (Array.isArray(result))
        bytes.push.apply(
          bytes,
          /**@type {!Array.<number>}*/
          result
        );
      else
        bytes.push(result);
    }
    if (!this._streaming) {
      while (true) {
        result = this._encoder.handler(input_stream, input_stream.read());
        if (result === finished)
          break;
        if (Array.isArray(result))
          bytes.push.apply(
            bytes,
            /**@type {!Array.<number>}*/
            result
          );
        else
          bytes.push(result);
      }
      this._encoder = null;
    }
    return new Uint8Array(bytes);
  }
};
function UTF8Decoder(options) {
  var fatal = options.fatal;
  var utf8_code_point = 0, utf8_bytes_seen = 0, utf8_bytes_needed = 0, utf8_lower_boundary = 128, utf8_upper_boundary = 191;
  this.handler = function(stream, bite) {
    if (bite === end_of_stream && utf8_bytes_needed !== 0) {
      utf8_bytes_needed = 0;
      return decoderError(fatal);
    }
    if (bite === end_of_stream)
      return finished;
    if (utf8_bytes_needed === 0) {
      if (inRange(bite, 0, 127)) {
        return bite;
      }
      if (inRange(bite, 194, 223)) {
        utf8_bytes_needed = 1;
        utf8_code_point = bite - 192;
      } else if (inRange(bite, 224, 239)) {
        if (bite === 224)
          utf8_lower_boundary = 160;
        if (bite === 237)
          utf8_upper_boundary = 159;
        utf8_bytes_needed = 2;
        utf8_code_point = bite - 224;
      } else if (inRange(bite, 240, 244)) {
        if (bite === 240)
          utf8_lower_boundary = 144;
        if (bite === 244)
          utf8_upper_boundary = 143;
        utf8_bytes_needed = 3;
        utf8_code_point = bite - 240;
      } else {
        return decoderError(fatal);
      }
      utf8_code_point = utf8_code_point << 6 * utf8_bytes_needed;
      return null;
    }
    if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {
      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
      utf8_lower_boundary = 128;
      utf8_upper_boundary = 191;
      stream.prepend(bite);
      return decoderError(fatal);
    }
    utf8_lower_boundary = 128;
    utf8_upper_boundary = 191;
    utf8_bytes_seen += 1;
    utf8_code_point += bite - 128 << 6 * (utf8_bytes_needed - utf8_bytes_seen);
    if (utf8_bytes_seen !== utf8_bytes_needed)
      return null;
    var code_point = utf8_code_point;
    utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
    return code_point;
  };
}
function UTF8Encoder(options) {
  options.fatal;
  this.handler = function(stream, code_point) {
    if (code_point === end_of_stream)
      return finished;
    if (inRange(code_point, 0, 127))
      return code_point;
    var count, offset;
    if (inRange(code_point, 128, 2047)) {
      count = 1;
      offset = 192;
    } else if (inRange(code_point, 2048, 65535)) {
      count = 2;
      offset = 224;
    } else if (inRange(code_point, 65536, 1114111)) {
      count = 3;
      offset = 240;
    }
    var bytes = [(code_point >> 6 * count) + offset];
    while (count > 0) {
      var temp = code_point >> 6 * (count - 1);
      bytes.push(128 | temp & 63);
      count -= 1;
    }
    return bytes;
  };
}
const encoding = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TextDecoder: TextDecoder$1,
  TextEncoder: TextEncoder$1
}, Symbol.toStringTag, { value: "Module" }));
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(encoding);
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib;
  hasRequiredLib = 1;
  var __createBinding = lib && lib.__createBinding || (Object.create ? function(o, m, k2, k22) {
    if (k22 === void 0) k22 = k2;
    Object.defineProperty(o, k22, { enumerable: true, get: function() {
      return m[k2];
    } });
  } : function(o, m, k2, k22) {
    if (k22 === void 0) k22 = k2;
    o[k22] = m[k2];
  });
  var __setModuleDefault = lib && lib.__setModuleDefault || (Object.create ? function(o, v2) {
    Object.defineProperty(o, "default", { enumerable: true, value: v2 });
  } : function(o, v2) {
    o["default"] = v2;
  });
  var __decorate = lib && lib.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d2 = decorators[i]) r = (c < 3 ? d2(r) : c > 3 ? d2(target, key, r) : d2(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __importStar = lib && lib.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule) return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k2 in mod2) if (k2 !== "default" && Object.hasOwnProperty.call(mod2, k2)) __createBinding(result, mod2, k2);
    }
    __setModuleDefault(result, mod2);
    return result;
  };
  var __importDefault = lib && lib.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(lib, "__esModule", { value: true });
  lib.deserializeUnchecked = lib.deserialize = lib.serialize = lib.BinaryReader = lib.BinaryWriter = lib.BorshError = lib.baseDecode = lib.baseEncode = void 0;
  const bn_js_1 = __importDefault(requireBn());
  const bs58_1 = __importDefault(requireBs58());
  const encoding2 = __importStar(require$$2);
  const ResolvedTextDecoder = typeof TextDecoder !== "function" ? encoding2.TextDecoder : TextDecoder;
  const textDecoder = new ResolvedTextDecoder("utf-8", { fatal: true });
  function baseEncode(value) {
    if (typeof value === "string") {
      value = bufferExports.Buffer.from(value, "utf8");
    }
    return bs58_1.default.encode(bufferExports.Buffer.from(value));
  }
  lib.baseEncode = baseEncode;
  function baseDecode(value) {
    return bufferExports.Buffer.from(bs58_1.default.decode(value));
  }
  lib.baseDecode = baseDecode;
  const INITIAL_LENGTH = 1024;
  class BorshError extends Error {
    constructor(message) {
      super(message);
      this.fieldPath = [];
      this.originalMessage = message;
    }
    addToFieldPath(fieldName) {
      this.fieldPath.splice(0, 0, fieldName);
      this.message = this.originalMessage + ": " + this.fieldPath.join(".");
    }
  }
  lib.BorshError = BorshError;
  class BinaryWriter {
    constructor() {
      this.buf = bufferExports.Buffer.alloc(INITIAL_LENGTH);
      this.length = 0;
    }
    maybeResize() {
      if (this.buf.length < 16 + this.length) {
        this.buf = bufferExports.Buffer.concat([this.buf, bufferExports.Buffer.alloc(INITIAL_LENGTH)]);
      }
    }
    writeU8(value) {
      this.maybeResize();
      this.buf.writeUInt8(value, this.length);
      this.length += 1;
    }
    writeU16(value) {
      this.maybeResize();
      this.buf.writeUInt16LE(value, this.length);
      this.length += 2;
    }
    writeU32(value) {
      this.maybeResize();
      this.buf.writeUInt32LE(value, this.length);
      this.length += 4;
    }
    writeU64(value) {
      this.maybeResize();
      this.writeBuffer(bufferExports.Buffer.from(new bn_js_1.default(value).toArray("le", 8)));
    }
    writeU128(value) {
      this.maybeResize();
      this.writeBuffer(bufferExports.Buffer.from(new bn_js_1.default(value).toArray("le", 16)));
    }
    writeU256(value) {
      this.maybeResize();
      this.writeBuffer(bufferExports.Buffer.from(new bn_js_1.default(value).toArray("le", 32)));
    }
    writeU512(value) {
      this.maybeResize();
      this.writeBuffer(bufferExports.Buffer.from(new bn_js_1.default(value).toArray("le", 64)));
    }
    writeBuffer(buffer2) {
      this.buf = bufferExports.Buffer.concat([
        bufferExports.Buffer.from(this.buf.subarray(0, this.length)),
        buffer2,
        bufferExports.Buffer.alloc(INITIAL_LENGTH)
      ]);
      this.length += buffer2.length;
    }
    writeString(str) {
      this.maybeResize();
      const b2 = bufferExports.Buffer.from(str, "utf8");
      this.writeU32(b2.length);
      this.writeBuffer(b2);
    }
    writeFixedArray(array2) {
      this.writeBuffer(bufferExports.Buffer.from(array2));
    }
    writeArray(array2, fn) {
      this.maybeResize();
      this.writeU32(array2.length);
      for (const elem of array2) {
        this.maybeResize();
        fn(elem);
      }
    }
    toArray() {
      return this.buf.subarray(0, this.length);
    }
  }
  lib.BinaryWriter = BinaryWriter;
  function handlingRangeError(target, propertyKey, propertyDescriptor) {
    const originalMethod = propertyDescriptor.value;
    propertyDescriptor.value = function(...args) {
      try {
        return originalMethod.apply(this, args);
      } catch (e3) {
        if (e3 instanceof RangeError) {
          const code = e3.code;
          if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(code) >= 0) {
            throw new BorshError("Reached the end of buffer when deserializing");
          }
        }
        throw e3;
      }
    };
  }
  class BinaryReader {
    constructor(buf) {
      this.buf = buf;
      this.offset = 0;
    }
    readU8() {
      const value = this.buf.readUInt8(this.offset);
      this.offset += 1;
      return value;
    }
    readU16() {
      const value = this.buf.readUInt16LE(this.offset);
      this.offset += 2;
      return value;
    }
    readU32() {
      const value = this.buf.readUInt32LE(this.offset);
      this.offset += 4;
      return value;
    }
    readU64() {
      const buf = this.readBuffer(8);
      return new bn_js_1.default(buf, "le");
    }
    readU128() {
      const buf = this.readBuffer(16);
      return new bn_js_1.default(buf, "le");
    }
    readU256() {
      const buf = this.readBuffer(32);
      return new bn_js_1.default(buf, "le");
    }
    readU512() {
      const buf = this.readBuffer(64);
      return new bn_js_1.default(buf, "le");
    }
    readBuffer(len) {
      if (this.offset + len > this.buf.length) {
        throw new BorshError(`Expected buffer length ${len} isn't within bounds`);
      }
      const result = this.buf.slice(this.offset, this.offset + len);
      this.offset += len;
      return result;
    }
    readString() {
      const len = this.readU32();
      const buf = this.readBuffer(len);
      try {
        return textDecoder.decode(buf);
      } catch (e3) {
        throw new BorshError(`Error decoding UTF-8 string: ${e3}`);
      }
    }
    readFixedArray(len) {
      return new Uint8Array(this.readBuffer(len));
    }
    readArray(fn) {
      const len = this.readU32();
      const result = Array();
      for (let i = 0; i < len; ++i) {
        result.push(fn());
      }
      return result;
    }
  }
  __decorate([
    handlingRangeError
  ], BinaryReader.prototype, "readU8", null);
  __decorate([
    handlingRangeError
  ], BinaryReader.prototype, "readU16", null);
  __decorate([
    handlingRangeError
  ], BinaryReader.prototype, "readU32", null);
  __decorate([
    handlingRangeError
  ], BinaryReader.prototype, "readU64", null);
  __decorate([
    handlingRangeError
  ], BinaryReader.prototype, "readU128", null);
  __decorate([
    handlingRangeError
  ], BinaryReader.prototype, "readU256", null);
  __decorate([
    handlingRangeError
  ], BinaryReader.prototype, "readU512", null);
  __decorate([
    handlingRangeError
  ], BinaryReader.prototype, "readString", null);
  __decorate([
    handlingRangeError
  ], BinaryReader.prototype, "readFixedArray", null);
  __decorate([
    handlingRangeError
  ], BinaryReader.prototype, "readArray", null);
  lib.BinaryReader = BinaryReader;
  function capitalizeFirstLetter(string2) {
    return string2.charAt(0).toUpperCase() + string2.slice(1);
  }
  function serializeField(schema, fieldName, value, fieldType, writer) {
    try {
      if (typeof fieldType === "string") {
        writer[`write${capitalizeFirstLetter(fieldType)}`](value);
      } else if (fieldType instanceof Array) {
        if (typeof fieldType[0] === "number") {
          if (value.length !== fieldType[0]) {
            throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);
          }
          writer.writeFixedArray(value);
        } else if (fieldType.length === 2 && typeof fieldType[1] === "number") {
          if (value.length !== fieldType[1]) {
            throw new BorshError(`Expecting byte array of length ${fieldType[1]}, but got ${value.length} bytes`);
          }
          for (let i = 0; i < fieldType[1]; i++) {
            serializeField(schema, null, value[i], fieldType[0], writer);
          }
        } else {
          writer.writeArray(value, (item) => {
            serializeField(schema, fieldName, item, fieldType[0], writer);
          });
        }
      } else if (fieldType.kind !== void 0) {
        switch (fieldType.kind) {
          case "option": {
            if (value === null || value === void 0) {
              writer.writeU8(0);
            } else {
              writer.writeU8(1);
              serializeField(schema, fieldName, value, fieldType.type, writer);
            }
            break;
          }
          case "map": {
            writer.writeU32(value.size);
            value.forEach((val, key) => {
              serializeField(schema, fieldName, key, fieldType.key, writer);
              serializeField(schema, fieldName, val, fieldType.value, writer);
            });
            break;
          }
          default:
            throw new BorshError(`FieldType ${fieldType} unrecognized`);
        }
      } else {
        serializeStruct(schema, value, writer);
      }
    } catch (error) {
      if (error instanceof BorshError) {
        error.addToFieldPath(fieldName);
      }
      throw error;
    }
  }
  function serializeStruct(schema, obj, writer) {
    if (typeof obj.borshSerialize === "function") {
      obj.borshSerialize(writer);
      return;
    }
    const structSchema = schema.get(obj.constructor);
    if (!structSchema) {
      throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);
    }
    if (structSchema.kind === "struct") {
      structSchema.fields.map(([fieldName, fieldType]) => {
        serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
      });
    } else if (structSchema.kind === "enum") {
      const name = obj[structSchema.field];
      for (let idx = 0; idx < structSchema.values.length; ++idx) {
        const [fieldName, fieldType] = structSchema.values[idx];
        if (fieldName === name) {
          writer.writeU8(idx);
          serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
          break;
        }
      }
    } else {
      throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);
    }
  }
  function serialize(schema, obj, Writer = BinaryWriter) {
    const writer = new Writer();
    serializeStruct(schema, obj, writer);
    return writer.toArray();
  }
  lib.serialize = serialize;
  function deserializeField(schema, fieldName, fieldType, reader) {
    try {
      if (typeof fieldType === "string") {
        return reader[`read${capitalizeFirstLetter(fieldType)}`]();
      }
      if (fieldType instanceof Array) {
        if (typeof fieldType[0] === "number") {
          return reader.readFixedArray(fieldType[0]);
        } else if (typeof fieldType[1] === "number") {
          const arr = [];
          for (let i = 0; i < fieldType[1]; i++) {
            arr.push(deserializeField(schema, null, fieldType[0], reader));
          }
          return arr;
        } else {
          return reader.readArray(() => deserializeField(schema, fieldName, fieldType[0], reader));
        }
      }
      if (fieldType.kind === "option") {
        const option = reader.readU8();
        if (option) {
          return deserializeField(schema, fieldName, fieldType.type, reader);
        }
        return void 0;
      }
      if (fieldType.kind === "map") {
        let map = /* @__PURE__ */ new Map();
        const length = reader.readU32();
        for (let i = 0; i < length; i++) {
          const key = deserializeField(schema, fieldName, fieldType.key, reader);
          const val = deserializeField(schema, fieldName, fieldType.value, reader);
          map.set(key, val);
        }
        return map;
      }
      return deserializeStruct(schema, fieldType, reader);
    } catch (error) {
      if (error instanceof BorshError) {
        error.addToFieldPath(fieldName);
      }
      throw error;
    }
  }
  function deserializeStruct(schema, classType, reader) {
    if (typeof classType.borshDeserialize === "function") {
      return classType.borshDeserialize(reader);
    }
    const structSchema = schema.get(classType);
    if (!structSchema) {
      throw new BorshError(`Class ${classType.name} is missing in schema`);
    }
    if (structSchema.kind === "struct") {
      const result = {};
      for (const [fieldName, fieldType] of schema.get(classType).fields) {
        result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);
      }
      return new classType(result);
    }
    if (structSchema.kind === "enum") {
      const idx = reader.readU8();
      if (idx >= structSchema.values.length) {
        throw new BorshError(`Enum index: ${idx} is out of range`);
      }
      const [fieldName, fieldType] = structSchema.values[idx];
      const fieldValue = deserializeField(schema, fieldName, fieldType, reader);
      return new classType({ [fieldName]: fieldValue });
    }
    throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);
  }
  function deserialize(schema, classType, buffer2, Reader = BinaryReader) {
    const reader = new Reader(buffer2);
    const result = deserializeStruct(schema, classType, reader);
    if (reader.offset < buffer2.length) {
      throw new BorshError(`Unexpected ${buffer2.length - reader.offset} bytes after deserialized data`);
    }
    return result;
  }
  lib.deserialize = deserialize;
  function deserializeUnchecked(schema, classType, buffer2, Reader = BinaryReader) {
    const reader = new Reader(buffer2);
    return deserializeStruct(schema, classType, reader);
  }
  lib.deserializeUnchecked = deserializeUnchecked;
  return lib;
}
var libExports = requireLib();
var Layout = {};
var hasRequiredLayout;
function requireLayout() {
  if (hasRequiredLayout) return Layout;
  hasRequiredLayout = 1;
  Object.defineProperty(Layout, "__esModule", { value: true });
  Layout.s16 = Layout.s8 = Layout.nu64be = Layout.u48be = Layout.u40be = Layout.u32be = Layout.u24be = Layout.u16be = Layout.nu64 = Layout.u48 = Layout.u40 = Layout.u32 = Layout.u24 = Layout.u16 = Layout.u8 = Layout.offset = Layout.greedy = Layout.Constant = Layout.UTF8 = Layout.CString = Layout.Blob = Layout.Boolean = Layout.BitField = Layout.BitStructure = Layout.VariantLayout = Layout.Union = Layout.UnionLayoutDiscriminator = Layout.UnionDiscriminator = Layout.Structure = Layout.Sequence = Layout.DoubleBE = Layout.Double = Layout.FloatBE = Layout.Float = Layout.NearInt64BE = Layout.NearInt64 = Layout.NearUInt64BE = Layout.NearUInt64 = Layout.IntBE = Layout.Int = Layout.UIntBE = Layout.UInt = Layout.OffsetLayout = Layout.GreedyCount = Layout.ExternalLayout = Layout.bindConstructorLayout = Layout.nameWithProperty = Layout.Layout = Layout.uint8ArrayToBuffer = Layout.checkUint8Array = void 0;
  Layout.constant = Layout.utf8 = Layout.cstr = Layout.blob = Layout.unionLayoutDiscriminator = Layout.union = Layout.seq = Layout.bits = Layout.struct = Layout.f64be = Layout.f64 = Layout.f32be = Layout.f32 = Layout.ns64be = Layout.s48be = Layout.s40be = Layout.s32be = Layout.s24be = Layout.s16be = Layout.ns64 = Layout.s48 = Layout.s40 = Layout.s32 = Layout.s24 = void 0;
  const buffer_1 = requireBuffer();
  function checkUint8Array(b2) {
    if (!(b2 instanceof Uint8Array)) {
      throw new TypeError("b must be a Uint8Array");
    }
  }
  Layout.checkUint8Array = checkUint8Array;
  function uint8ArrayToBuffer(b2) {
    checkUint8Array(b2);
    return buffer_1.Buffer.from(b2.buffer, b2.byteOffset, b2.length);
  }
  Layout.uint8ArrayToBuffer = uint8ArrayToBuffer;
  let Layout$1 = class Layout {
    constructor(span, property) {
      if (!Number.isInteger(span)) {
        throw new TypeError("span must be an integer");
      }
      this.span = span;
      this.property = property;
    }
    /** Function to create an Object into which decoded properties will
     * be written.
     *
     * Used only for layouts that {@link Layout#decode|decode} to Object
     * instances, which means:
     * * {@link Structure}
     * * {@link Union}
     * * {@link VariantLayout}
     * * {@link BitStructure}
     *
     * If left undefined the JavaScript representation of these layouts
     * will be Object instances.
     *
     * See {@link bindConstructorLayout}.
     */
    makeDestinationObject() {
      return {};
    }
    /**
     * Calculate the span of a specific instance of a layout.
     *
     * @param {Uint8Array} b - the buffer that contains an encoded instance.
     *
     * @param {Number} [offset] - the offset at which the encoded instance
     * starts.  If absent a zero offset is inferred.
     *
     * @return {Number} - the number of bytes covered by the layout
     * instance.  If this method is not overridden in a subclass the
     * definition-time constant {@link Layout#span|span} will be
     * returned.
     *
     * @throws {RangeError} - if the length of the value cannot be
     * determined.
     */
    getSpan(b2, offset) {
      if (0 > this.span) {
        throw new RangeError("indeterminate span");
      }
      return this.span;
    }
    /**
     * Replicate the layout using a new property.
     *
     * This function must be used to get a structurally-equivalent layout
     * with a different name since all {@link Layout} instances are
     * immutable.
     *
     * **NOTE** This is a shallow copy.  All fields except {@link
     * Layout#property|property} are strictly equal to the origin layout.
     *
     * @param {String} property - the value for {@link
     * Layout#property|property} in the replica.
     *
     * @returns {Layout} - the copy with {@link Layout#property|property}
     * set to `property`.
     */
    replicate(property) {
      const rv = Object.create(this.constructor.prototype);
      Object.assign(rv, this);
      rv.property = property;
      return rv;
    }
    /**
     * Create an object from layout properties and an array of values.
     *
     * **NOTE** This function returns `undefined` if invoked on a layout
     * that does not return its value as an Object.  Objects are
     * returned for things that are a {@link Structure}, which includes
     * {@link VariantLayout|variant layouts} if they are structures, and
     * excludes {@link Union}s.  If you want this feature for a union
     * you must use {@link Union.getVariant|getVariant} to select the
     * desired layout.
     *
     * @param {Array} values - an array of values that correspond to the
     * default order for properties.  As with {@link Layout#decode|decode}
     * layout elements that have no property name are skipped when
     * iterating over the array values.  Only the top-level properties are
     * assigned; arguments are not assigned to properties of contained
     * layouts.  Any unused values are ignored.
     *
     * @return {(Object|undefined)}
     */
    fromArray(values) {
      return void 0;
    }
  };
  Layout.Layout = Layout$1;
  function nameWithProperty(name, lo) {
    if (lo.property) {
      return name + "[" + lo.property + "]";
    }
    return name;
  }
  Layout.nameWithProperty = nameWithProperty;
  function bindConstructorLayout(Class, layout) {
    if ("function" !== typeof Class) {
      throw new TypeError("Class must be constructor");
    }
    if (Object.prototype.hasOwnProperty.call(Class, "layout_")) {
      throw new Error("Class is already bound to a layout");
    }
    if (!(layout && layout instanceof Layout$1)) {
      throw new TypeError("layout must be a Layout");
    }
    if (Object.prototype.hasOwnProperty.call(layout, "boundConstructor_")) {
      throw new Error("layout is already bound to a constructor");
    }
    Class.layout_ = layout;
    layout.boundConstructor_ = Class;
    layout.makeDestinationObject = () => new Class();
    Object.defineProperty(Class.prototype, "encode", {
      value(b2, offset) {
        return layout.encode(this, b2, offset);
      },
      writable: true
    });
    Object.defineProperty(Class, "decode", {
      value(b2, offset) {
        return layout.decode(b2, offset);
      },
      writable: true
    });
  }
  Layout.bindConstructorLayout = bindConstructorLayout;
  class ExternalLayout extends Layout$1 {
    /**
     * Return `true` iff the external layout decodes to an unsigned
     * integer layout.
     *
     * In that case it can be used as the source of {@link
     * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},
     * or as {@link UnionLayoutDiscriminator#layout|external union
     * discriminators}.
     *
     * @abstract
     */
    isCount() {
      throw new Error("ExternalLayout is abstract");
    }
  }
  Layout.ExternalLayout = ExternalLayout;
  class GreedyCount extends ExternalLayout {
    constructor(elementSpan = 1, property) {
      if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {
        throw new TypeError("elementSpan must be a (positive) integer");
      }
      super(-1, property);
      this.elementSpan = elementSpan;
    }
    /** @override */
    isCount() {
      return true;
    }
    /** @override */
    decode(b2, offset = 0) {
      checkUint8Array(b2);
      const rem = b2.length - offset;
      return Math.floor(rem / this.elementSpan);
    }
    /** @override */
    encode(src2, b2, offset) {
      return 0;
    }
  }
  Layout.GreedyCount = GreedyCount;
  class OffsetLayout extends ExternalLayout {
    constructor(layout, offset = 0, property) {
      if (!(layout instanceof Layout$1)) {
        throw new TypeError("layout must be a Layout");
      }
      if (!Number.isInteger(offset)) {
        throw new TypeError("offset must be integer or undefined");
      }
      super(layout.span, property || layout.property);
      this.layout = layout;
      this.offset = offset;
    }
    /** @override */
    isCount() {
      return this.layout instanceof UInt || this.layout instanceof UIntBE;
    }
    /** @override */
    decode(b2, offset = 0) {
      return this.layout.decode(b2, offset + this.offset);
    }
    /** @override */
    encode(src2, b2, offset = 0) {
      return this.layout.encode(src2, b2, offset + this.offset);
    }
  }
  Layout.OffsetLayout = OffsetLayout;
  class UInt extends Layout$1 {
    constructor(span, property) {
      super(span, property);
      if (6 < this.span) {
        throw new RangeError("span must not exceed 6 bytes");
      }
    }
    /** @override */
    decode(b2, offset = 0) {
      return uint8ArrayToBuffer(b2).readUIntLE(offset, this.span);
    }
    /** @override */
    encode(src2, b2, offset = 0) {
      uint8ArrayToBuffer(b2).writeUIntLE(src2, offset, this.span);
      return this.span;
    }
  }
  Layout.UInt = UInt;
  class UIntBE extends Layout$1 {
    constructor(span, property) {
      super(span, property);
      if (6 < this.span) {
        throw new RangeError("span must not exceed 6 bytes");
      }
    }
    /** @override */
    decode(b2, offset = 0) {
      return uint8ArrayToBuffer(b2).readUIntBE(offset, this.span);
    }
    /** @override */
    encode(src2, b2, offset = 0) {
      uint8ArrayToBuffer(b2).writeUIntBE(src2, offset, this.span);
      return this.span;
    }
  }
  Layout.UIntBE = UIntBE;
  class Int extends Layout$1 {
    constructor(span, property) {
      super(span, property);
      if (6 < this.span) {
        throw new RangeError("span must not exceed 6 bytes");
      }
    }
    /** @override */
    decode(b2, offset = 0) {
      return uint8ArrayToBuffer(b2).readIntLE(offset, this.span);
    }
    /** @override */
    encode(src2, b2, offset = 0) {
      uint8ArrayToBuffer(b2).writeIntLE(src2, offset, this.span);
      return this.span;
    }
  }
  Layout.Int = Int;
  class IntBE extends Layout$1 {
    constructor(span, property) {
      super(span, property);
      if (6 < this.span) {
        throw new RangeError("span must not exceed 6 bytes");
      }
    }
    /** @override */
    decode(b2, offset = 0) {
      return uint8ArrayToBuffer(b2).readIntBE(offset, this.span);
    }
    /** @override */
    encode(src2, b2, offset = 0) {
      uint8ArrayToBuffer(b2).writeIntBE(src2, offset, this.span);
      return this.span;
    }
  }
  Layout.IntBE = IntBE;
  const V2E32 = Math.pow(2, 32);
  function divmodInt64(src2) {
    const hi32 = Math.floor(src2 / V2E32);
    const lo32 = src2 - hi32 * V2E32;
    return { hi32, lo32 };
  }
  function roundedInt64(hi32, lo32) {
    return hi32 * V2E32 + lo32;
  }
  class NearUInt64 extends Layout$1 {
    constructor(property) {
      super(8, property);
    }
    /** @override */
    decode(b2, offset = 0) {
      const buffer2 = uint8ArrayToBuffer(b2);
      const lo32 = buffer2.readUInt32LE(offset);
      const hi32 = buffer2.readUInt32LE(offset + 4);
      return roundedInt64(hi32, lo32);
    }
    /** @override */
    encode(src2, b2, offset = 0) {
      const split2 = divmodInt64(src2);
      const buffer2 = uint8ArrayToBuffer(b2);
      buffer2.writeUInt32LE(split2.lo32, offset);
      buffer2.writeUInt32LE(split2.hi32, offset + 4);
      return 8;
    }
  }
  Layout.NearUInt64 = NearUInt64;
  class NearUInt64BE extends Layout$1 {
    constructor(property) {
      super(8, property);
    }
    /** @override */
    decode(b2, offset = 0) {
      const buffer2 = uint8ArrayToBuffer(b2);
      const hi32 = buffer2.readUInt32BE(offset);
      const lo32 = buffer2.readUInt32BE(offset + 4);
      return roundedInt64(hi32, lo32);
    }
    /** @override */
    encode(src2, b2, offset = 0) {
      const split2 = divmodInt64(src2);
      const buffer2 = uint8ArrayToBuffer(b2);
      buffer2.writeUInt32BE(split2.hi32, offset);
      buffer2.writeUInt32BE(split2.lo32, offset + 4);
      return 8;
    }
  }
  Layout.NearUInt64BE = NearUInt64BE;
  class NearInt64 extends Layout$1 {
    constructor(property) {
      super(8, property);
    }
    /** @override */
    decode(b2, offset = 0) {
      const buffer2 = uint8ArrayToBuffer(b2);
      const lo32 = buffer2.readUInt32LE(offset);
      const hi32 = buffer2.readInt32LE(offset + 4);
      return roundedInt64(hi32, lo32);
    }
    /** @override */
    encode(src2, b2, offset = 0) {
      const split2 = divmodInt64(src2);
      const buffer2 = uint8ArrayToBuffer(b2);
      buffer2.writeUInt32LE(split2.lo32, offset);
      buffer2.writeInt32LE(split2.hi32, offset + 4);
      return 8;
    }
  }
  Layout.NearInt64 = NearInt64;
  class NearInt64BE extends Layout$1 {
    constructor(property) {
      super(8, property);
    }
    /** @override */
    decode(b2, offset = 0) {
      const buffer2 = uint8ArrayToBuffer(b2);
      const hi32 = buffer2.readInt32BE(offset);
      const lo32 = buffer2.readUInt32BE(offset + 4);
      return roundedInt64(hi32, lo32);
    }
    /** @override */
    encode(src2, b2, offset = 0) {
      const split2 = divmodInt64(src2);
      const buffer2 = uint8ArrayToBuffer(b2);
      buffer2.writeInt32BE(split2.hi32, offset);
      buffer2.writeUInt32BE(split2.lo32, offset + 4);
      return 8;
    }
  }
  Layout.NearInt64BE = NearInt64BE;
  class Float extends Layout$1 {
    constructor(property) {
      super(4, property);
    }
    /** @override */
    decode(b2, offset = 0) {
      return uint8ArrayToBuffer(b2).readFloatLE(offset);
    }
    /** @override */
    encode(src2, b2, offset = 0) {
      uint8ArrayToBuffer(b2).writeFloatLE(src2, offset);
      return 4;
    }
  }
  Layout.Float = Float;
  class FloatBE extends Layout$1 {
    constructor(property) {
      super(4, property);
    }
    /** @override */
    decode(b2, offset = 0) {
      return uint8ArrayToBuffer(b2).readFloatBE(offset);
    }
    /** @override */
    encode(src2, b2, offset = 0) {
      uint8ArrayToBuffer(b2).writeFloatBE(src2, offset);
      return 4;
    }
  }
  Layout.FloatBE = FloatBE;
  class Double extends Layout$1 {
    constructor(property) {
      super(8, property);
    }
    /** @override */
    decode(b2, offset = 0) {
      return uint8ArrayToBuffer(b2).readDoubleLE(offset);
    }
    /** @override */
    encode(src2, b2, offset = 0) {
      uint8ArrayToBuffer(b2).writeDoubleLE(src2, offset);
      return 8;
    }
  }
  Layout.Double = Double;
  class DoubleBE extends Layout$1 {
    constructor(property) {
      super(8, property);
    }
    /** @override */
    decode(b2, offset = 0) {
      return uint8ArrayToBuffer(b2).readDoubleBE(offset);
    }
    /** @override */
    encode(src2, b2, offset = 0) {
      uint8ArrayToBuffer(b2).writeDoubleBE(src2, offset);
      return 8;
    }
  }
  Layout.DoubleBE = DoubleBE;
  class Sequence extends Layout$1 {
    constructor(elementLayout, count, property) {
      if (!(elementLayout instanceof Layout$1)) {
        throw new TypeError("elementLayout must be a Layout");
      }
      if (!(count instanceof ExternalLayout && count.isCount() || Number.isInteger(count) && 0 <= count)) {
        throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
      }
      let span = -1;
      if (!(count instanceof ExternalLayout) && 0 < elementLayout.span) {
        span = count * elementLayout.span;
      }
      super(span, property);
      this.elementLayout = elementLayout;
      this.count = count;
    }
    /** @override */
    getSpan(b2, offset = 0) {
      if (0 <= this.span) {
        return this.span;
      }
      let span = 0;
      let count = this.count;
      if (count instanceof ExternalLayout) {
        count = count.decode(b2, offset);
      }
      if (0 < this.elementLayout.span) {
        span = count * this.elementLayout.span;
      } else {
        let idx = 0;
        while (idx < count) {
          span += this.elementLayout.getSpan(b2, offset + span);
          ++idx;
        }
      }
      return span;
    }
    /** @override */
    decode(b2, offset = 0) {
      const rv = [];
      let i = 0;
      let count = this.count;
      if (count instanceof ExternalLayout) {
        count = count.decode(b2, offset);
      }
      while (i < count) {
        rv.push(this.elementLayout.decode(b2, offset));
        offset += this.elementLayout.getSpan(b2, offset);
        i += 1;
      }
      return rv;
    }
    /** Implement {@link Layout#encode|encode} for {@link Sequence}.
     *
     * **NOTE** If `src` is shorter than {@link Sequence#count|count} then
     * the unused space in the buffer is left unchanged.  If `src` is
     * longer than {@link Sequence#count|count} the unneeded elements are
     * ignored.
     *
     * **NOTE** If {@link Layout#count|count} is an instance of {@link
     * ExternalLayout} then the length of `src` will be encoded as the
     * count after `src` is encoded. */
    encode(src2, b2, offset = 0) {
      const elo = this.elementLayout;
      const span = src2.reduce((span2, v2) => {
        return span2 + elo.encode(v2, b2, offset + span2);
      }, 0);
      if (this.count instanceof ExternalLayout) {
        this.count.encode(src2.length, b2, offset);
      }
      return span;
    }
  }
  Layout.Sequence = Sequence;
  class Structure extends Layout$1 {
    constructor(fields, property, decodePrefixes) {
      if (!(Array.isArray(fields) && fields.reduce((acc, v2) => acc && v2 instanceof Layout$1, true))) {
        throw new TypeError("fields must be array of Layout instances");
      }
      if ("boolean" === typeof property && void 0 === decodePrefixes) {
        decodePrefixes = property;
        property = void 0;
      }
      for (const fd of fields) {
        if (0 > fd.span && void 0 === fd.property) {
          throw new Error("fields cannot contain unnamed variable-length layout");
        }
      }
      let span = -1;
      try {
        span = fields.reduce((span2, fd) => span2 + fd.getSpan(), 0);
      } catch (e3) {
      }
      super(span, property);
      this.fields = fields;
      this.decodePrefixes = !!decodePrefixes;
    }
    /** @override */
    getSpan(b2, offset = 0) {
      if (0 <= this.span) {
        return this.span;
      }
      let span = 0;
      try {
        span = this.fields.reduce((span2, fd) => {
          const fsp = fd.getSpan(b2, offset);
          offset += fsp;
          return span2 + fsp;
        }, 0);
      } catch (e3) {
        throw new RangeError("indeterminate span");
      }
      return span;
    }
    /** @override */
    decode(b2, offset = 0) {
      checkUint8Array(b2);
      const dest = this.makeDestinationObject();
      for (const fd of this.fields) {
        if (void 0 !== fd.property) {
          dest[fd.property] = fd.decode(b2, offset);
        }
        offset += fd.getSpan(b2, offset);
        if (this.decodePrefixes && b2.length === offset) {
          break;
        }
      }
      return dest;
    }
    /** Implement {@link Layout#encode|encode} for {@link Structure}.
     *
     * If `src` is missing a property for a member with a defined {@link
     * Layout#property|property} the corresponding region of the buffer is
     * left unmodified. */
    encode(src2, b2, offset = 0) {
      const firstOffset = offset;
      let lastOffset = 0;
      let lastWrote = 0;
      for (const fd of this.fields) {
        let span = fd.span;
        lastWrote = 0 < span ? span : 0;
        if (void 0 !== fd.property) {
          const fv = src2[fd.property];
          if (void 0 !== fv) {
            lastWrote = fd.encode(fv, b2, offset);
            if (0 > span) {
              span = fd.getSpan(b2, offset);
            }
          }
        }
        lastOffset = offset;
        offset += span;
      }
      return lastOffset + lastWrote - firstOffset;
    }
    /** @override */
    fromArray(values) {
      const dest = this.makeDestinationObject();
      for (const fd of this.fields) {
        if (void 0 !== fd.property && 0 < values.length) {
          dest[fd.property] = values.shift();
        }
      }
      return dest;
    }
    /**
     * Get access to the layout of a given property.
     *
     * @param {String} property - the structure member of interest.
     *
     * @return {Layout} - the layout associated with `property`, or
     * undefined if there is no such property.
     */
    layoutFor(property) {
      if ("string" !== typeof property) {
        throw new TypeError("property must be string");
      }
      for (const fd of this.fields) {
        if (fd.property === property) {
          return fd;
        }
      }
      return void 0;
    }
    /**
     * Get the offset of a structure member.
     *
     * @param {String} property - the structure member of interest.
     *
     * @return {Number} - the offset in bytes to the start of `property`
     * within the structure, or undefined if `property` is not a field
     * within the structure.  If the property is a member but follows a
     * variable-length structure member a negative number will be
     * returned.
     */
    offsetOf(property) {
      if ("string" !== typeof property) {
        throw new TypeError("property must be string");
      }
      let offset = 0;
      for (const fd of this.fields) {
        if (fd.property === property) {
          return offset;
        }
        if (0 > fd.span) {
          offset = -1;
        } else if (0 <= offset) {
          offset += fd.span;
        }
      }
      return void 0;
    }
  }
  Layout.Structure = Structure;
  class UnionDiscriminator {
    constructor(property) {
      this.property = property;
    }
    /** Analog to {@link Layout#decode|Layout decode} for union discriminators.
     *
     * The implementation of this method need not reference the buffer if
     * variant information is available through other means. */
    decode(b2, offset) {
      throw new Error("UnionDiscriminator is abstract");
    }
    /** Analog to {@link Layout#decode|Layout encode} for union discriminators.
     *
     * The implementation of this method need not store the value if
     * variant information is maintained through other means. */
    encode(src2, b2, offset) {
      throw new Error("UnionDiscriminator is abstract");
    }
  }
  Layout.UnionDiscriminator = UnionDiscriminator;
  class UnionLayoutDiscriminator extends UnionDiscriminator {
    constructor(layout, property) {
      if (!(layout instanceof ExternalLayout && layout.isCount())) {
        throw new TypeError("layout must be an unsigned integer ExternalLayout");
      }
      super(property || layout.property || "variant");
      this.layout = layout;
    }
    /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */
    decode(b2, offset) {
      return this.layout.decode(b2, offset);
    }
    /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */
    encode(src2, b2, offset) {
      return this.layout.encode(src2, b2, offset);
    }
  }
  Layout.UnionLayoutDiscriminator = UnionLayoutDiscriminator;
  class Union extends Layout$1 {
    constructor(discr, defaultLayout, property) {
      let discriminator;
      if (discr instanceof UInt || discr instanceof UIntBE) {
        discriminator = new UnionLayoutDiscriminator(new OffsetLayout(discr));
      } else if (discr instanceof ExternalLayout && discr.isCount()) {
        discriminator = new UnionLayoutDiscriminator(discr);
      } else if (!(discr instanceof UnionDiscriminator)) {
        throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
      } else {
        discriminator = discr;
      }
      if (void 0 === defaultLayout) {
        defaultLayout = null;
      }
      if (!(null === defaultLayout || defaultLayout instanceof Layout$1)) {
        throw new TypeError("defaultLayout must be null or a Layout");
      }
      if (null !== defaultLayout) {
        if (0 > defaultLayout.span) {
          throw new Error("defaultLayout must have constant span");
        }
        if (void 0 === defaultLayout.property) {
          defaultLayout = defaultLayout.replicate("content");
        }
      }
      let span = -1;
      if (defaultLayout) {
        span = defaultLayout.span;
        if (0 <= span && (discr instanceof UInt || discr instanceof UIntBE)) {
          span += discriminator.layout.span;
        }
      }
      super(span, property);
      this.discriminator = discriminator;
      this.usesPrefixDiscriminator = discr instanceof UInt || discr instanceof UIntBE;
      this.defaultLayout = defaultLayout;
      this.registry = {};
      let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
      this.getSourceVariant = function(src2) {
        return boundGetSourceVariant(src2);
      };
      this.configGetSourceVariant = function(gsv) {
        boundGetSourceVariant = gsv.bind(this);
      };
    }
    /** @override */
    getSpan(b2, offset = 0) {
      if (0 <= this.span) {
        return this.span;
      }
      const vlo = this.getVariant(b2, offset);
      if (!vlo) {
        throw new Error("unable to determine span for unrecognized variant");
      }
      return vlo.getSpan(b2, offset);
    }
    /**
     * Method to infer a registered Union variant compatible with `src`.
     *
     * The first satisfied rule in the following sequence defines the
     * return value:
     * * If `src` has properties matching the Union discriminator and
     *   the default layout, `undefined` is returned regardless of the
     *   value of the discriminator property (this ensures the default
     *   layout will be used);
     * * If `src` has a property matching the Union discriminator, the
     *   value of the discriminator identifies a registered variant, and
     *   either (a) the variant has no layout, or (b) `src` has the
     *   variant's property, then the variant is returned (because the
     *   source satisfies the constraints of the variant it identifies);
     * * If `src` does not have a property matching the Union
     *   discriminator, but does have a property matching a registered
     *   variant, then the variant is returned (because the source
     *   matches a variant without an explicit conflict);
     * * An error is thrown (because we either can't identify a variant,
     *   or we were explicitly told the variant but can't satisfy it).
     *
     * @param {Object} src - an object presumed to be compatible with
     * the content of the Union.
     *
     * @return {(undefined|VariantLayout)} - as described above.
     *
     * @throws {Error} - if `src` cannot be associated with a default or
     * registered variant.
     */
    defaultGetSourceVariant(src2) {
      if (Object.prototype.hasOwnProperty.call(src2, this.discriminator.property)) {
        if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(src2, this.defaultLayout.property)) {
          return void 0;
        }
        const vlo = this.registry[src2[this.discriminator.property]];
        if (vlo && (!vlo.layout || vlo.property && Object.prototype.hasOwnProperty.call(src2, vlo.property))) {
          return vlo;
        }
      } else {
        for (const tag in this.registry) {
          const vlo = this.registry[tag];
          if (vlo.property && Object.prototype.hasOwnProperty.call(src2, vlo.property)) {
            return vlo;
          }
        }
      }
      throw new Error("unable to infer src variant");
    }
    /** Implement {@link Layout#decode|decode} for {@link Union}.
     *
     * If the variant is {@link Union#addVariant|registered} the return
     * value is an instance of that variant, with no explicit
     * discriminator.  Otherwise the {@link Union#defaultLayout|default
     * layout} is used to decode the content. */
    decode(b2, offset = 0) {
      let dest;
      const dlo = this.discriminator;
      const discr = dlo.decode(b2, offset);
      const clo = this.registry[discr];
      if (void 0 === clo) {
        const defaultLayout = this.defaultLayout;
        let contentOffset = 0;
        if (this.usesPrefixDiscriminator) {
          contentOffset = dlo.layout.span;
        }
        dest = this.makeDestinationObject();
        dest[dlo.property] = discr;
        dest[defaultLayout.property] = defaultLayout.decode(b2, offset + contentOffset);
      } else {
        dest = clo.decode(b2, offset);
      }
      return dest;
    }
    /** Implement {@link Layout#encode|encode} for {@link Union}.
     *
     * This API assumes the `src` object is consistent with the union's
     * {@link Union#defaultLayout|default layout}.  To encode variants
     * use the appropriate variant-specific {@link VariantLayout#encode}
     * method. */
    encode(src2, b2, offset = 0) {
      const vlo = this.getSourceVariant(src2);
      if (void 0 === vlo) {
        const dlo = this.discriminator;
        const clo = this.defaultLayout;
        let contentOffset = 0;
        if (this.usesPrefixDiscriminator) {
          contentOffset = dlo.layout.span;
        }
        dlo.encode(src2[dlo.property], b2, offset);
        return contentOffset + clo.encode(src2[clo.property], b2, offset + contentOffset);
      }
      return vlo.encode(src2, b2, offset);
    }
    /** Register a new variant structure within a union.  The newly
     * created variant is returned.
     *
     * @param {Number} variant - initializer for {@link
     * VariantLayout#variant|variant}.
     *
     * @param {Layout} layout - initializer for {@link
     * VariantLayout#layout|layout}.
     *
     * @param {String} property - initializer for {@link
     * Layout#property|property}.
     *
     * @return {VariantLayout} */
    addVariant(variant, layout, property) {
      const rv = new VariantLayout(this, variant, layout, property);
      this.registry[variant] = rv;
      return rv;
    }
    /**
     * Get the layout associated with a registered variant.
     *
     * If `vb` does not produce a registered variant the function returns
     * `undefined`.
     *
     * @param {(Number|Uint8Array)} vb - either the variant number, or a
     * buffer from which the discriminator is to be read.
     *
     * @param {Number} offset - offset into `vb` for the start of the
     * union.  Used only when `vb` is an instance of {Uint8Array}.
     *
     * @return {({VariantLayout}|undefined)}
     */
    getVariant(vb, offset = 0) {
      let variant;
      if (vb instanceof Uint8Array) {
        variant = this.discriminator.decode(vb, offset);
      } else {
        variant = vb;
      }
      return this.registry[variant];
    }
  }
  Layout.Union = Union;
  class VariantLayout extends Layout$1 {
    constructor(union2, variant, layout, property) {
      if (!(union2 instanceof Union)) {
        throw new TypeError("union must be a Union");
      }
      if (!Number.isInteger(variant) || 0 > variant) {
        throw new TypeError("variant must be a (non-negative) integer");
      }
      if ("string" === typeof layout && void 0 === property) {
        property = layout;
        layout = null;
      }
      if (layout) {
        if (!(layout instanceof Layout$1)) {
          throw new TypeError("layout must be a Layout");
        }
        if (null !== union2.defaultLayout && 0 <= layout.span && layout.span > union2.defaultLayout.span) {
          throw new Error("variant span exceeds span of containing union");
        }
        if ("string" !== typeof property) {
          throw new TypeError("variant must have a String property");
        }
      }
      let span = union2.span;
      if (0 > union2.span) {
        span = layout ? layout.span : 0;
        if (0 <= span && union2.usesPrefixDiscriminator) {
          span += union2.discriminator.layout.span;
        }
      }
      super(span, property);
      this.union = union2;
      this.variant = variant;
      this.layout = layout || null;
    }
    /** @override */
    getSpan(b2, offset = 0) {
      if (0 <= this.span) {
        return this.span;
      }
      let contentOffset = 0;
      if (this.union.usesPrefixDiscriminator) {
        contentOffset = this.union.discriminator.layout.span;
      }
      let span = 0;
      if (this.layout) {
        span = this.layout.getSpan(b2, offset + contentOffset);
      }
      return contentOffset + span;
    }
    /** @override */
    decode(b2, offset = 0) {
      const dest = this.makeDestinationObject();
      if (this !== this.union.getVariant(b2, offset)) {
        throw new Error("variant mismatch");
      }
      let contentOffset = 0;
      if (this.union.usesPrefixDiscriminator) {
        contentOffset = this.union.discriminator.layout.span;
      }
      if (this.layout) {
        dest[this.property] = this.layout.decode(b2, offset + contentOffset);
      } else if (this.property) {
        dest[this.property] = true;
      } else if (this.union.usesPrefixDiscriminator) {
        dest[this.union.discriminator.property] = this.variant;
      }
      return dest;
    }
    /** @override */
    encode(src2, b2, offset = 0) {
      let contentOffset = 0;
      if (this.union.usesPrefixDiscriminator) {
        contentOffset = this.union.discriminator.layout.span;
      }
      if (this.layout && !Object.prototype.hasOwnProperty.call(src2, this.property)) {
        throw new TypeError("variant lacks property " + this.property);
      }
      this.union.discriminator.encode(this.variant, b2, offset);
      let span = contentOffset;
      if (this.layout) {
        this.layout.encode(src2[this.property], b2, offset + contentOffset);
        span += this.layout.getSpan(b2, offset + contentOffset);
        if (0 <= this.union.span && span > this.union.span) {
          throw new Error("encoded variant overruns containing union");
        }
      }
      return span;
    }
    /** Delegate {@link Layout#fromArray|fromArray} to {@link
     * VariantLayout#layout|layout}. */
    fromArray(values) {
      if (this.layout) {
        return this.layout.fromArray(values);
      }
      return void 0;
    }
  }
  Layout.VariantLayout = VariantLayout;
  function fixBitwiseResult(v2) {
    if (0 > v2) {
      v2 += 4294967296;
    }
    return v2;
  }
  class BitStructure extends Layout$1 {
    constructor(word, msb, property) {
      if (!(word instanceof UInt || word instanceof UIntBE)) {
        throw new TypeError("word must be a UInt or UIntBE layout");
      }
      if ("string" === typeof msb && void 0 === property) {
        property = msb;
        msb = false;
      }
      if (4 < word.span) {
        throw new RangeError("word cannot exceed 32 bits");
      }
      super(word.span, property);
      this.word = word;
      this.msb = !!msb;
      this.fields = [];
      let value = 0;
      this._packedSetValue = function(v2) {
        value = fixBitwiseResult(v2);
        return this;
      };
      this._packedGetValue = function() {
        return value;
      };
    }
    /** @override */
    decode(b2, offset = 0) {
      const dest = this.makeDestinationObject();
      const value = this.word.decode(b2, offset);
      this._packedSetValue(value);
      for (const fd of this.fields) {
        if (void 0 !== fd.property) {
          dest[fd.property] = fd.decode(b2);
        }
      }
      return dest;
    }
    /** Implement {@link Layout#encode|encode} for {@link BitStructure}.
     *
     * If `src` is missing a property for a member with a defined {@link
     * Layout#property|property} the corresponding region of the packed
     * value is left unmodified.  Unused bits are also left unmodified. */
    encode(src2, b2, offset = 0) {
      const value = this.word.decode(b2, offset);
      this._packedSetValue(value);
      for (const fd of this.fields) {
        if (void 0 !== fd.property) {
          const fv = src2[fd.property];
          if (void 0 !== fv) {
            fd.encode(fv);
          }
        }
      }
      return this.word.encode(this._packedGetValue(), b2, offset);
    }
    /** Register a new bitfield with a containing bit structure.  The
     * resulting bitfield is returned.
     *
     * @param {Number} bits - initializer for {@link BitField#bits|bits}.
     *
     * @param {string} property - initializer for {@link
     * Layout#property|property}.
     *
     * @return {BitField} */
    addField(bits, property) {
      const bf = new BitField(this, bits, property);
      this.fields.push(bf);
      return bf;
    }
    /** As with {@link BitStructure#addField|addField} for single-bit
     * fields with `boolean` value representation.
     *
     * @param {string} property - initializer for {@link
     * Layout#property|property}.
     *
     * @return {Boolean} */
    // `Boolean` conflicts with the native primitive type
    // eslint-disable-next-line @typescript-eslint/ban-types
    addBoolean(property) {
      const bf = new Boolean2(this, property);
      this.fields.push(bf);
      return bf;
    }
    /**
     * Get access to the bit field for a given property.
     *
     * @param {String} property - the bit field of interest.
     *
     * @return {BitField} - the field associated with `property`, or
     * undefined if there is no such property.
     */
    fieldFor(property) {
      if ("string" !== typeof property) {
        throw new TypeError("property must be string");
      }
      for (const fd of this.fields) {
        if (fd.property === property) {
          return fd;
        }
      }
      return void 0;
    }
  }
  Layout.BitStructure = BitStructure;
  class BitField {
    constructor(container, bits, property) {
      if (!(container instanceof BitStructure)) {
        throw new TypeError("container must be a BitStructure");
      }
      if (!Number.isInteger(bits) || 0 >= bits) {
        throw new TypeError("bits must be positive integer");
      }
      const totalBits = 8 * container.span;
      const usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);
      if (bits + usedBits > totalBits) {
        throw new Error("bits too long for span remainder (" + (totalBits - usedBits) + " of " + totalBits + " remain)");
      }
      this.container = container;
      this.bits = bits;
      this.valueMask = (1 << bits) - 1;
      if (32 === bits) {
        this.valueMask = 4294967295;
      }
      this.start = usedBits;
      if (this.container.msb) {
        this.start = totalBits - usedBits - bits;
      }
      this.wordMask = fixBitwiseResult(this.valueMask << this.start);
      this.property = property;
    }
    /** Store a value into the corresponding subsequence of the containing
     * bit field. */
    decode(b2, offset) {
      const word = this.container._packedGetValue();
      const wordValue = fixBitwiseResult(word & this.wordMask);
      const value = wordValue >>> this.start;
      return value;
    }
    /** Store a value into the corresponding subsequence of the containing
     * bit field.
     *
     * **NOTE** This is not a specialization of {@link
     * Layout#encode|Layout.encode} and there is no return value. */
    encode(value) {
      if ("number" !== typeof value || !Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {
        throw new TypeError(nameWithProperty("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
      }
      const word = this.container._packedGetValue();
      const wordValue = fixBitwiseResult(value << this.start);
      this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);
    }
  }
  Layout.BitField = BitField;
  class Boolean2 extends BitField {
    constructor(container, property) {
      super(container, 1, property);
    }
    /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.
     *
     * @returns {boolean} */
    decode(b2, offset) {
      return !!super.decode(b2, offset);
    }
    /** @override */
    encode(value) {
      if ("boolean" === typeof value) {
        value = +value;
      }
      super.encode(value);
    }
  }
  Layout.Boolean = Boolean2;
  class Blob extends Layout$1 {
    constructor(length, property) {
      if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {
        throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
      }
      let span = -1;
      if (!(length instanceof ExternalLayout)) {
        span = length;
      }
      super(span, property);
      this.length = length;
    }
    /** @override */
    getSpan(b2, offset) {
      let span = this.span;
      if (0 > span) {
        span = this.length.decode(b2, offset);
      }
      return span;
    }
    /** @override */
    decode(b2, offset = 0) {
      let span = this.span;
      if (0 > span) {
        span = this.length.decode(b2, offset);
      }
      return uint8ArrayToBuffer(b2).slice(offset, offset + span);
    }
    /** Implement {@link Layout#encode|encode} for {@link Blob}.
     *
     * **NOTE** If {@link Layout#count|count} is an instance of {@link
     * ExternalLayout} then the length of `src` will be encoded as the
     * count after `src` is encoded. */
    encode(src2, b2, offset) {
      let span = this.length;
      if (this.length instanceof ExternalLayout) {
        span = src2.length;
      }
      if (!(src2 instanceof Uint8Array && span === src2.length)) {
        throw new TypeError(nameWithProperty("Blob.encode", this) + " requires (length " + span + ") Uint8Array as src");
      }
      if (offset + span > b2.length) {
        throw new RangeError("encoding overruns Uint8Array");
      }
      const srcBuffer = uint8ArrayToBuffer(src2);
      uint8ArrayToBuffer(b2).write(srcBuffer.toString("hex"), offset, span, "hex");
      if (this.length instanceof ExternalLayout) {
        this.length.encode(span, b2, offset);
      }
      return span;
    }
  }
  Layout.Blob = Blob;
  class CString extends Layout$1 {
    constructor(property) {
      super(-1, property);
    }
    /** @override */
    getSpan(b2, offset = 0) {
      checkUint8Array(b2);
      let idx = offset;
      while (idx < b2.length && 0 !== b2[idx]) {
        idx += 1;
      }
      return 1 + idx - offset;
    }
    /** @override */
    decode(b2, offset = 0) {
      const span = this.getSpan(b2, offset);
      return uint8ArrayToBuffer(b2).slice(offset, offset + span - 1).toString("utf-8");
    }
    /** @override */
    encode(src2, b2, offset = 0) {
      if ("string" !== typeof src2) {
        src2 = String(src2);
      }
      const srcb = buffer_1.Buffer.from(src2, "utf8");
      const span = srcb.length;
      if (offset + span > b2.length) {
        throw new RangeError("encoding overruns Buffer");
      }
      const buffer2 = uint8ArrayToBuffer(b2);
      srcb.copy(buffer2, offset);
      buffer2[offset + span] = 0;
      return span + 1;
    }
  }
  Layout.CString = CString;
  class UTF8 extends Layout$1 {
    constructor(maxSpan, property) {
      if ("string" === typeof maxSpan && void 0 === property) {
        property = maxSpan;
        maxSpan = void 0;
      }
      if (void 0 === maxSpan) {
        maxSpan = -1;
      } else if (!Number.isInteger(maxSpan)) {
        throw new TypeError("maxSpan must be an integer");
      }
      super(-1, property);
      this.maxSpan = maxSpan;
    }
    /** @override */
    getSpan(b2, offset = 0) {
      checkUint8Array(b2);
      return b2.length - offset;
    }
    /** @override */
    decode(b2, offset = 0) {
      const span = this.getSpan(b2, offset);
      if (0 <= this.maxSpan && this.maxSpan < span) {
        throw new RangeError("text length exceeds maxSpan");
      }
      return uint8ArrayToBuffer(b2).slice(offset, offset + span).toString("utf-8");
    }
    /** @override */
    encode(src2, b2, offset = 0) {
      if ("string" !== typeof src2) {
        src2 = String(src2);
      }
      const srcb = buffer_1.Buffer.from(src2, "utf8");
      const span = srcb.length;
      if (0 <= this.maxSpan && this.maxSpan < span) {
        throw new RangeError("text length exceeds maxSpan");
      }
      if (offset + span > b2.length) {
        throw new RangeError("encoding overruns Buffer");
      }
      srcb.copy(uint8ArrayToBuffer(b2), offset);
      return span;
    }
  }
  Layout.UTF8 = UTF8;
  class Constant extends Layout$1 {
    constructor(value, property) {
      super(0, property);
      this.value = value;
    }
    /** @override */
    decode(b2, offset) {
      return this.value;
    }
    /** @override */
    encode(src2, b2, offset) {
      return 0;
    }
  }
  Layout.Constant = Constant;
  Layout.greedy = (elementSpan, property) => new GreedyCount(elementSpan, property);
  Layout.offset = (layout, offset, property) => new OffsetLayout(layout, offset, property);
  Layout.u8 = (property) => new UInt(1, property);
  Layout.u16 = (property) => new UInt(2, property);
  Layout.u24 = (property) => new UInt(3, property);
  Layout.u32 = (property) => new UInt(4, property);
  Layout.u40 = (property) => new UInt(5, property);
  Layout.u48 = (property) => new UInt(6, property);
  Layout.nu64 = (property) => new NearUInt64(property);
  Layout.u16be = (property) => new UIntBE(2, property);
  Layout.u24be = (property) => new UIntBE(3, property);
  Layout.u32be = (property) => new UIntBE(4, property);
  Layout.u40be = (property) => new UIntBE(5, property);
  Layout.u48be = (property) => new UIntBE(6, property);
  Layout.nu64be = (property) => new NearUInt64BE(property);
  Layout.s8 = (property) => new Int(1, property);
  Layout.s16 = (property) => new Int(2, property);
  Layout.s24 = (property) => new Int(3, property);
  Layout.s32 = (property) => new Int(4, property);
  Layout.s40 = (property) => new Int(5, property);
  Layout.s48 = (property) => new Int(6, property);
  Layout.ns64 = (property) => new NearInt64(property);
  Layout.s16be = (property) => new IntBE(2, property);
  Layout.s24be = (property) => new IntBE(3, property);
  Layout.s32be = (property) => new IntBE(4, property);
  Layout.s40be = (property) => new IntBE(5, property);
  Layout.s48be = (property) => new IntBE(6, property);
  Layout.ns64be = (property) => new NearInt64BE(property);
  Layout.f32 = (property) => new Float(property);
  Layout.f32be = (property) => new FloatBE(property);
  Layout.f64 = (property) => new Double(property);
  Layout.f64be = (property) => new DoubleBE(property);
  Layout.struct = (fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes);
  Layout.bits = (word, msb, property) => new BitStructure(word, msb, property);
  Layout.seq = (elementLayout, count, property) => new Sequence(elementLayout, count, property);
  Layout.union = (discr, defaultLayout, property) => new Union(discr, defaultLayout, property);
  Layout.unionLayoutDiscriminator = (layout, property) => new UnionLayoutDiscriminator(layout, property);
  Layout.blob = (length, property) => new Blob(length, property);
  Layout.cstr = (property) => new CString(property);
  Layout.utf8 = (maxSpan, property) => new UTF8(maxSpan, property);
  Layout.constant = (value, property) => new Constant(value, property);
  return Layout;
}
var LayoutExports = requireLayout();
var SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = 8078e3;
var SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = 8078001;
var SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = 8078004;
var SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = 8078005;
var SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = 8078006;
var SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = 8078011;
function encodeValue(value) {
  if (Array.isArray(value)) {
    const commaSeparatedValues = value.map(encodeValue).join(
      "%2C%20"
      /* ", " */
    );
    return "%5B" + commaSeparatedValues + /* "]" */
    "%5D";
  } else if (typeof value === "bigint") {
    return `${value}n`;
  } else {
    return encodeURIComponent(
      String(
        value != null && Object.getPrototypeOf(value) === null ? (
          // Plain objects with no prototype don't have a `toString` method.
          // Convert them before stringifying them.
          { ...value }
        ) : value
      )
    );
  }
}
function encodeObjectContextEntry([key, value]) {
  return `${key}=${encodeValue(value)}`;
}
function encodeContextObject(context) {
  const searchParamsString = Object.entries(context).map(encodeObjectContextEntry).join("&");
  return btoa(searchParamsString);
}
function getErrorMessage(code, context = {}) {
  {
    let decodingAdviceMessage = `Solana error #${code}; Decode this error by running \`npx @solana/errors decode -- ${code}`;
    if (Object.keys(context).length) {
      decodingAdviceMessage += ` '${encodeContextObject(context)}'`;
    }
    return `${decodingAdviceMessage}\``;
  }
}
var SolanaError = class extends Error {
  constructor(...[code, contextAndErrorOptions]) {
    let context;
    let errorOptions;
    if (contextAndErrorOptions) {
      const { cause, ...contextRest } = contextAndErrorOptions;
      if (cause) {
        errorOptions = { cause };
      }
      if (Object.keys(contextRest).length > 0) {
        context = contextRest;
      }
    }
    const message = getErrorMessage(code, context);
    super(message, errorOptions);
    /**
     * Indicates the root cause of this {@link SolanaError}, if any.
     *
     * For example, a transaction error might have an instruction error as its root cause. In this
     * case, you will be able to access the instruction error on the transaction error as `cause`.
     */
    __publicField(this, "cause", this.cause);
    /**
     * Contains context that can assist in understanding or recovering from a {@link SolanaError}.
     */
    __publicField(this, "context");
    this.context = {
      __code: code,
      ...context
    };
    this.name = "SolanaError";
  }
};
function getEncodedSize(value, encoder) {
  return "fixedSize" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);
}
function createEncoder(encoder) {
  return Object.freeze({
    ...encoder,
    encode: (value) => {
      const bytes = new Uint8Array(getEncodedSize(value, encoder));
      encoder.write(value, bytes, 0);
      return bytes;
    }
  });
}
function createDecoder(decoder) {
  return Object.freeze({
    ...decoder,
    decode: (bytes, offset = 0) => decoder.read(bytes, offset)[0]
  });
}
function isFixedSize(codec) {
  return "fixedSize" in codec && typeof codec.fixedSize === "number";
}
function combineCodec(encoder, decoder) {
  if (isFixedSize(encoder) !== isFixedSize(decoder)) {
    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);
  }
  if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {
    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {
      decoderFixedSize: decoder.fixedSize,
      encoderFixedSize: encoder.fixedSize
    });
  }
  if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {
    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {
      decoderMaxSize: decoder.maxSize,
      encoderMaxSize: encoder.maxSize
    });
  }
  return {
    ...decoder,
    ...encoder,
    decode: decoder.decode,
    encode: encoder.encode,
    read: decoder.read,
    write: encoder.write
  };
}
function assertByteArrayIsNotEmptyForCodec(codecDescription, bytes, offset = 0) {
  if (bytes.length - offset <= 0) {
    throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {
      codecDescription
    });
  }
}
function assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes, offset = 0) {
  const bytesLength = bytes.length - offset;
  if (bytesLength < expected) {
    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {
      bytesLength,
      codecDescription,
      expected
    });
  }
}
function assertNumberIsBetweenForCodec(codecDescription, min, max, value) {
  if (value < min || value > max) {
    throw new SolanaError(SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {
      codecDescription,
      max,
      min,
      value
    });
  }
}
function isLittleEndian(config) {
  return config?.endian === 1 ? false : true;
}
function numberEncoderFactory(input) {
  return createEncoder({
    fixedSize: input.size,
    write(value, bytes, offset) {
      if (input.range) {
        assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);
      }
      const arrayBuffer = new ArrayBuffer(input.size);
      input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));
      bytes.set(new Uint8Array(arrayBuffer), offset);
      return offset + input.size;
    }
  });
}
function numberDecoderFactory(input) {
  return createDecoder({
    fixedSize: input.size,
    read(bytes, offset = 0) {
      assertByteArrayIsNotEmptyForCodec(input.name, bytes, offset);
      assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes, offset);
      const view = new DataView(toArrayBuffer(bytes, offset, input.size));
      return [input.get(view, isLittleEndian(input.config)), offset + input.size];
    }
  });
}
function toArrayBuffer(bytes, offset, length) {
  const bytesOffset = bytes.byteOffset + (offset ?? 0);
  const bytesLength = length ?? bytes.byteLength;
  return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);
}
var getU64Encoder = (config = {}) => numberEncoderFactory({
  config,
  name: "u64",
  range: [0n, BigInt("0xffffffffffffffff")],
  set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),
  size: 8
});
var getU64Decoder = (config = {}) => numberDecoderFactory({
  config,
  get: (view, le) => view.getBigUint64(0, le),
  name: "u64",
  size: 8
});
var getU64Codec = (config = {}) => combineCodec(getU64Encoder(config), getU64Decoder(config));
class StructError extends TypeError {
  constructor(failure, failures) {
    let cached;
    const { message, explanation, ...rest } = failure;
    const { path } = failure;
    const msg = path.length === 0 ? message : `At path: ${path.join(".")} -- ${message}`;
    super(explanation ?? msg);
    if (explanation != null)
      this.cause = msg;
    Object.assign(this, rest);
    this.name = this.constructor.name;
    this.failures = () => {
      return cached ?? (cached = [failure, ...failures()]);
    };
  }
}
function isIterable(x2) {
  return isObject(x2) && typeof x2[Symbol.iterator] === "function";
}
function isObject(x2) {
  return typeof x2 === "object" && x2 != null;
}
function isNonArrayObject(x2) {
  return isObject(x2) && !Array.isArray(x2);
}
function print(value) {
  if (typeof value === "symbol") {
    return value.toString();
  }
  return typeof value === "string" ? JSON.stringify(value) : `${value}`;
}
function shiftIterator(input) {
  const { done, value } = input.next();
  return done ? void 0 : value;
}
function toFailure(result, context, struct, value) {
  if (result === true) {
    return;
  } else if (result === false) {
    result = {};
  } else if (typeof result === "string") {
    result = { message: result };
  }
  const { path, branch } = context;
  const { type: type2 } = struct;
  const { refinement, message = `Expected a value of type \`${type2}\`${refinement ? ` with refinement \`${refinement}\`` : ""}, but received: \`${print(value)}\`` } = result;
  return {
    value,
    type: type2,
    refinement,
    key: path[path.length - 1],
    path,
    branch,
    ...result,
    message
  };
}
function* toFailures(result, context, struct, value) {
  if (!isIterable(result)) {
    result = [result];
  }
  for (const r of result) {
    const failure = toFailure(r, context, struct, value);
    if (failure) {
      yield failure;
    }
  }
}
function* run(value, struct, options = {}) {
  const { path = [], branch = [value], coerce: coerce2 = false, mask: mask2 = false } = options;
  const ctx = { path, branch, mask: mask2 };
  if (coerce2) {
    value = struct.coercer(value, ctx);
  }
  let status = "valid";
  for (const failure of struct.validator(value, ctx)) {
    failure.explanation = options.message;
    status = "not_valid";
    yield [failure, void 0];
  }
  for (let [k2, v2, s] of struct.entries(value, ctx)) {
    const ts = run(v2, s, {
      path: k2 === void 0 ? path : [...path, k2],
      branch: k2 === void 0 ? branch : [...branch, v2],
      coerce: coerce2,
      mask: mask2,
      message: options.message
    });
    for (const t of ts) {
      if (t[0]) {
        status = t[0].refinement != null ? "not_refined" : "not_valid";
        yield [t[0], void 0];
      } else if (coerce2) {
        v2 = t[1];
        if (k2 === void 0) {
          value = v2;
        } else if (value instanceof Map) {
          value.set(k2, v2);
        } else if (value instanceof Set) {
          value.add(v2);
        } else if (isObject(value)) {
          if (v2 !== void 0 || k2 in value)
            value[k2] = v2;
        }
      }
    }
  }
  if (status !== "not_valid") {
    for (const failure of struct.refiner(value, ctx)) {
      failure.explanation = options.message;
      status = "not_refined";
      yield [failure, void 0];
    }
  }
  if (status === "valid") {
    yield [void 0, value];
  }
}
let Struct$1 = class Struct {
  constructor(props) {
    const { type: type2, schema, validator, refiner, coercer = (value) => value, entries = function* () {
    } } = props;
    this.type = type2;
    this.schema = schema;
    this.entries = entries;
    this.coercer = coercer;
    if (validator) {
      this.validator = (value, context) => {
        const result = validator(value, context);
        return toFailures(result, context, this, value);
      };
    } else {
      this.validator = () => [];
    }
    if (refiner) {
      this.refiner = (value, context) => {
        const result = refiner(value, context);
        return toFailures(result, context, this, value);
      };
    } else {
      this.refiner = () => [];
    }
  }
  /**
   * Assert that a value passes the struct's validation, throwing if it doesn't.
   */
  assert(value, message) {
    return assert$1(value, this, message);
  }
  /**
   * Create a value with the struct's coercion logic, then validate it.
   */
  create(value, message) {
    return create(value, this, message);
  }
  /**
   * Check if a value passes the struct's validation.
   */
  is(value) {
    return is(value, this);
  }
  /**
   * Mask a value, coercing and validating it, but returning only the subset of
   * properties defined by the struct's schema. Masking applies recursively to
   * props of `object` structs only.
   */
  mask(value, message) {
    return mask(value, this, message);
  }
  /**
   * Validate a value with the struct's validation logic, returning a tuple
   * representing the result.
   *
   * You may optionally pass `true` for the `coerce` argument to coerce
   * the value before attempting to validate it. If you do, the result will
   * contain the coerced result when successful. Also, `mask` will turn on
   * masking of the unknown `object` props recursively if passed.
   */
  validate(value, options = {}) {
    return validate$1(value, this, options);
  }
};
function assert$1(value, struct, message) {
  const result = validate$1(value, struct, { message });
  if (result[0]) {
    throw result[0];
  }
}
function create(value, struct, message) {
  const result = validate$1(value, struct, { coerce: true, message });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function mask(value, struct, message) {
  const result = validate$1(value, struct, { coerce: true, mask: true, message });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function is(value, struct) {
  const result = validate$1(value, struct);
  return !result[0];
}
function validate$1(value, struct, options = {}) {
  const tuples = run(value, struct, options);
  const tuple2 = shiftIterator(tuples);
  if (tuple2[0]) {
    const error = new StructError(tuple2[0], function* () {
      for (const t of tuples) {
        if (t[0]) {
          yield t[0];
        }
      }
    });
    return [error, void 0];
  } else {
    const v2 = tuple2[1];
    return [void 0, v2];
  }
}
function define(name, validator) {
  return new Struct$1({ type: name, schema: null, validator });
}
function any() {
  return define("any", () => true);
}
function array(Element) {
  return new Struct$1({
    type: "array",
    schema: Element,
    *entries(value) {
      if (Element && Array.isArray(value)) {
        for (const [i, v2] of value.entries()) {
          yield [i, v2, Element];
        }
      }
    },
    coercer(value) {
      return Array.isArray(value) ? value.slice() : value;
    },
    validator(value) {
      return Array.isArray(value) || `Expected an array value, but received: ${print(value)}`;
    }
  });
}
function boolean() {
  return define("boolean", (value) => {
    return typeof value === "boolean";
  });
}
function instance(Class) {
  return define("instance", (value) => {
    return value instanceof Class || `Expected a \`${Class.name}\` instance, but received: ${print(value)}`;
  });
}
function literal(constant) {
  const description = print(constant);
  const t = typeof constant;
  return new Struct$1({
    type: "literal",
    schema: t === "string" || t === "number" || t === "boolean" ? constant : null,
    validator(value) {
      return value === constant || `Expected the literal \`${description}\`, but received: ${print(value)}`;
    }
  });
}
function never() {
  return define("never", () => false);
}
function nullable(struct) {
  return new Struct$1({
    ...struct,
    validator: (value, ctx) => value === null || struct.validator(value, ctx),
    refiner: (value, ctx) => value === null || struct.refiner(value, ctx)
  });
}
function number() {
  return define("number", (value) => {
    return typeof value === "number" && !isNaN(value) || `Expected a number, but received: ${print(value)}`;
  });
}
function optional(struct) {
  return new Struct$1({
    ...struct,
    validator: (value, ctx) => value === void 0 || struct.validator(value, ctx),
    refiner: (value, ctx) => value === void 0 || struct.refiner(value, ctx)
  });
}
function record(Key, Value) {
  return new Struct$1({
    type: "record",
    schema: null,
    *entries(value) {
      if (isObject(value)) {
        for (const k2 in value) {
          const v2 = value[k2];
          yield [k2, k2, Key];
          yield [k2, v2, Value];
        }
      }
    },
    validator(value) {
      return isNonArrayObject(value) || `Expected an object, but received: ${print(value)}`;
    },
    coercer(value) {
      return isNonArrayObject(value) ? { ...value } : value;
    }
  });
}
function string() {
  return define("string", (value) => {
    return typeof value === "string" || `Expected a string, but received: ${print(value)}`;
  });
}
function tuple(Structs) {
  const Never = never();
  return new Struct$1({
    type: "tuple",
    schema: null,
    *entries(value) {
      if (Array.isArray(value)) {
        const length = Math.max(Structs.length, value.length);
        for (let i = 0; i < length; i++) {
          yield [i, value[i], Structs[i] || Never];
        }
      }
    },
    validator(value) {
      return Array.isArray(value) || `Expected an array, but received: ${print(value)}`;
    },
    coercer(value) {
      return Array.isArray(value) ? value.slice() : value;
    }
  });
}
function type(schema) {
  const keys2 = Object.keys(schema);
  return new Struct$1({
    type: "type",
    schema,
    *entries(value) {
      if (isObject(value)) {
        for (const k2 of keys2) {
          yield [k2, value[k2], schema[k2]];
        }
      }
    },
    validator(value) {
      return isNonArrayObject(value) || `Expected an object, but received: ${print(value)}`;
    },
    coercer(value) {
      return isNonArrayObject(value) ? { ...value } : value;
    }
  });
}
function union(Structs) {
  const description = Structs.map((s) => s.type).join(" | ");
  return new Struct$1({
    type: "union",
    schema: null,
    coercer(value, ctx) {
      for (const S2 of Structs) {
        const [error, coerced] = S2.validate(value, {
          coerce: true,
          mask: ctx.mask
        });
        if (!error) {
          return coerced;
        }
      }
      return value;
    },
    validator(value, ctx) {
      const failures = [];
      for (const S2 of Structs) {
        const [...tuples] = run(value, S2, ctx);
        const [first] = tuples;
        if (!first[0]) {
          return [];
        } else {
          for (const [failure] of tuples) {
            if (failure) {
              failures.push(failure);
            }
          }
        }
      }
      return [
        `Expected the value to satisfy a union of \`${description}\`, but received: ${print(value)}`,
        ...failures
      ];
    }
  });
}
function unknown() {
  return define("unknown", () => true);
}
function coerce(struct, condition, coercer) {
  return new Struct$1({
    ...struct,
    coercer: (value, ctx) => {
      return is(value, condition) ? struct.coercer(coercer(value, ctx), ctx) : struct.coercer(value, ctx);
    }
  });
}
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate(uuid) {
  return typeof uuid === "string" && REGEX.test(uuid);
}
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).substr(1));
}
function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var _nodeId;
var _clockseq;
var _lastMSecs = 0;
var _lastNSecs = 0;
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b2 = buf || new Array(16);
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || rng)();
    if (node == null) {
      node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  var msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b2[i++] = tl >>> 24 & 255;
  b2[i++] = tl >>> 16 & 255;
  b2[i++] = tl >>> 8 & 255;
  b2[i++] = tl & 255;
  var tmh = msecs / 4294967296 * 1e4 & 268435455;
  b2[i++] = tmh >>> 8 & 255;
  b2[i++] = tmh & 255;
  b2[i++] = tmh >>> 24 & 15 | 16;
  b2[i++] = tmh >>> 16 & 255;
  b2[i++] = clockseq >>> 8 | 128;
  b2[i++] = clockseq & 255;
  for (var n = 0; n < 6; ++n) {
    b2[i + n] = node[n];
  }
  return buf || stringify(b2);
}
function parse(uuid) {
  if (!validate(uuid)) {
    throw TypeError("Invalid UUID");
  }
  var v2;
  var arr = new Uint8Array(16);
  arr[0] = (v2 = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v2 >>> 16 & 255;
  arr[2] = v2 >>> 8 & 255;
  arr[3] = v2 & 255;
  arr[4] = (v2 = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v2 & 255;
  arr[6] = (v2 = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v2 & 255;
  arr[8] = (v2 = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v2 & 255;
  arr[10] = (v2 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v2 / 4294967296 & 255;
  arr[12] = v2 >>> 24 & 255;
  arr[13] = v2 >>> 16 & 255;
  arr[14] = v2 >>> 8 & 255;
  arr[15] = v2 & 255;
  return arr;
}
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  var bytes = [];
  for (var i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL$1 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version2;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return stringify(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL$1;
  return generateUUID;
}
function md5(bytes) {
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (var i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i = 0; i < length32; i += 8) {
    var x2 = input[i >> 5] >>> i % 32 & 255;
    var hex = parseInt(hexTab.charAt(x2 >>> 4 & 15) + hexTab.charAt(x2 & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x2, len) {
  x2[len >> 5] |= 128 << len % 32;
  x2[getOutputLength(len) - 1] = len;
  var a = 1732584193;
  var b2 = -271733879;
  var c = -1732584194;
  var d2 = 271733878;
  for (var i = 0; i < x2.length; i += 16) {
    var olda = a;
    var oldb = b2;
    var oldc = c;
    var oldd = d2;
    a = md5ff(a, b2, c, d2, x2[i], 7, -680876936);
    d2 = md5ff(d2, a, b2, c, x2[i + 1], 12, -389564586);
    c = md5ff(c, d2, a, b2, x2[i + 2], 17, 606105819);
    b2 = md5ff(b2, c, d2, a, x2[i + 3], 22, -1044525330);
    a = md5ff(a, b2, c, d2, x2[i + 4], 7, -176418897);
    d2 = md5ff(d2, a, b2, c, x2[i + 5], 12, 1200080426);
    c = md5ff(c, d2, a, b2, x2[i + 6], 17, -1473231341);
    b2 = md5ff(b2, c, d2, a, x2[i + 7], 22, -45705983);
    a = md5ff(a, b2, c, d2, x2[i + 8], 7, 1770035416);
    d2 = md5ff(d2, a, b2, c, x2[i + 9], 12, -1958414417);
    c = md5ff(c, d2, a, b2, x2[i + 10], 17, -42063);
    b2 = md5ff(b2, c, d2, a, x2[i + 11], 22, -1990404162);
    a = md5ff(a, b2, c, d2, x2[i + 12], 7, 1804603682);
    d2 = md5ff(d2, a, b2, c, x2[i + 13], 12, -40341101);
    c = md5ff(c, d2, a, b2, x2[i + 14], 17, -1502002290);
    b2 = md5ff(b2, c, d2, a, x2[i + 15], 22, 1236535329);
    a = md5gg(a, b2, c, d2, x2[i + 1], 5, -165796510);
    d2 = md5gg(d2, a, b2, c, x2[i + 6], 9, -1069501632);
    c = md5gg(c, d2, a, b2, x2[i + 11], 14, 643717713);
    b2 = md5gg(b2, c, d2, a, x2[i], 20, -373897302);
    a = md5gg(a, b2, c, d2, x2[i + 5], 5, -701558691);
    d2 = md5gg(d2, a, b2, c, x2[i + 10], 9, 38016083);
    c = md5gg(c, d2, a, b2, x2[i + 15], 14, -660478335);
    b2 = md5gg(b2, c, d2, a, x2[i + 4], 20, -405537848);
    a = md5gg(a, b2, c, d2, x2[i + 9], 5, 568446438);
    d2 = md5gg(d2, a, b2, c, x2[i + 14], 9, -1019803690);
    c = md5gg(c, d2, a, b2, x2[i + 3], 14, -187363961);
    b2 = md5gg(b2, c, d2, a, x2[i + 8], 20, 1163531501);
    a = md5gg(a, b2, c, d2, x2[i + 13], 5, -1444681467);
    d2 = md5gg(d2, a, b2, c, x2[i + 2], 9, -51403784);
    c = md5gg(c, d2, a, b2, x2[i + 7], 14, 1735328473);
    b2 = md5gg(b2, c, d2, a, x2[i + 12], 20, -1926607734);
    a = md5hh(a, b2, c, d2, x2[i + 5], 4, -378558);
    d2 = md5hh(d2, a, b2, c, x2[i + 8], 11, -2022574463);
    c = md5hh(c, d2, a, b2, x2[i + 11], 16, 1839030562);
    b2 = md5hh(b2, c, d2, a, x2[i + 14], 23, -35309556);
    a = md5hh(a, b2, c, d2, x2[i + 1], 4, -1530992060);
    d2 = md5hh(d2, a, b2, c, x2[i + 4], 11, 1272893353);
    c = md5hh(c, d2, a, b2, x2[i + 7], 16, -155497632);
    b2 = md5hh(b2, c, d2, a, x2[i + 10], 23, -1094730640);
    a = md5hh(a, b2, c, d2, x2[i + 13], 4, 681279174);
    d2 = md5hh(d2, a, b2, c, x2[i], 11, -358537222);
    c = md5hh(c, d2, a, b2, x2[i + 3], 16, -722521979);
    b2 = md5hh(b2, c, d2, a, x2[i + 6], 23, 76029189);
    a = md5hh(a, b2, c, d2, x2[i + 9], 4, -640364487);
    d2 = md5hh(d2, a, b2, c, x2[i + 12], 11, -421815835);
    c = md5hh(c, d2, a, b2, x2[i + 15], 16, 530742520);
    b2 = md5hh(b2, c, d2, a, x2[i + 2], 23, -995338651);
    a = md5ii(a, b2, c, d2, x2[i], 6, -198630844);
    d2 = md5ii(d2, a, b2, c, x2[i + 7], 10, 1126891415);
    c = md5ii(c, d2, a, b2, x2[i + 14], 15, -1416354905);
    b2 = md5ii(b2, c, d2, a, x2[i + 5], 21, -57434055);
    a = md5ii(a, b2, c, d2, x2[i + 12], 6, 1700485571);
    d2 = md5ii(d2, a, b2, c, x2[i + 3], 10, -1894986606);
    c = md5ii(c, d2, a, b2, x2[i + 10], 15, -1051523);
    b2 = md5ii(b2, c, d2, a, x2[i + 1], 21, -2054922799);
    a = md5ii(a, b2, c, d2, x2[i + 8], 6, 1873313359);
    d2 = md5ii(d2, a, b2, c, x2[i + 15], 10, -30611744);
    c = md5ii(c, d2, a, b2, x2[i + 6], 15, -1560198380);
    b2 = md5ii(b2, c, d2, a, x2[i + 13], 21, 1309151649);
    a = md5ii(a, b2, c, d2, x2[i + 4], 6, -145523070);
    d2 = md5ii(d2, a, b2, c, x2[i + 11], 10, -1120210379);
    c = md5ii(c, d2, a, b2, x2[i + 2], 15, 718787259);
    b2 = md5ii(b2, c, d2, a, x2[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b2 = safeAdd(b2, oldb);
    c = safeAdd(c, oldc);
    d2 = safeAdd(d2, oldd);
  }
  return [a, b2, c, d2];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));
  for (var i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output;
}
function safeAdd(x2, y) {
  var lsw = (x2 & 65535) + (y & 65535);
  var msw = (x2 >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b2, x2, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x2, t)), s), b2);
}
function md5ff(a, b2, c, d2, x2, s, t) {
  return md5cmn(b2 & c | ~b2 & d2, a, b2, x2, s, t);
}
function md5gg(a, b2, c, d2, x2, s, t) {
  return md5cmn(b2 & d2 | c & ~d2, a, b2, x2, s, t);
}
function md5hh(a, b2, c, d2, x2, s, t) {
  return md5cmn(b2 ^ c ^ d2, a, b2, x2, s, t);
}
function md5ii(a, b2, c, d2, x2, s, t) {
  return md5cmn(c ^ (b2 | ~d2), a, b2, x2, s, t);
}
var v3 = v35("v3", 48, md5);
function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify(rnds);
}
function f(s, x2, y, z2) {
  switch (s) {
    case 0:
      return x2 & y ^ ~x2 & z2;
    case 1:
      return x2 ^ y ^ z2;
    case 2:
      return x2 & y ^ x2 & z2 ^ y & z2;
    case 3:
      return x2 ^ y ^ z2;
  }
}
function ROTL(x2, n) {
  return x2 << n | x2 >>> 32 - n;
}
function sha1(bytes) {
  var K2 = [1518500249, 1859775393, 2400959708, 3395469782];
  var H2 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (var i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  var l = bytes.length / 4 + 2;
  var N2 = Math.ceil(l / 16);
  var M2 = new Array(N2);
  for (var _i = 0; _i < N2; ++_i) {
    var arr = new Uint32Array(16);
    for (var j2 = 0; j2 < 16; ++j2) {
      arr[j2] = bytes[_i * 64 + j2 * 4] << 24 | bytes[_i * 64 + j2 * 4 + 1] << 16 | bytes[_i * 64 + j2 * 4 + 2] << 8 | bytes[_i * 64 + j2 * 4 + 3];
    }
    M2[_i] = arr;
  }
  M2[N2 - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M2[N2 - 1][14] = Math.floor(M2[N2 - 1][14]);
  M2[N2 - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (var _i2 = 0; _i2 < N2; ++_i2) {
    var W2 = new Uint32Array(80);
    for (var t = 0; t < 16; ++t) {
      W2[t] = M2[_i2][t];
    }
    for (var _t = 16; _t < 80; ++_t) {
      W2[_t] = ROTL(W2[_t - 3] ^ W2[_t - 8] ^ W2[_t - 14] ^ W2[_t - 16], 1);
    }
    var a = H2[0];
    var b2 = H2[1];
    var c = H2[2];
    var d2 = H2[3];
    var e3 = H2[4];
    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T2 = ROTL(a, 5) + f(s, b2, c, d2) + e3 + K2[s] + W2[_t2] >>> 0;
      e3 = d2;
      d2 = c;
      c = ROTL(b2, 30) >>> 0;
      b2 = a;
      a = T2;
    }
    H2[0] = H2[0] + a >>> 0;
    H2[1] = H2[1] + b2 >>> 0;
    H2[2] = H2[2] + c >>> 0;
    H2[3] = H2[3] + d2 >>> 0;
    H2[4] = H2[4] + e3 >>> 0;
  }
  return [H2[0] >> 24 & 255, H2[0] >> 16 & 255, H2[0] >> 8 & 255, H2[0] & 255, H2[1] >> 24 & 255, H2[1] >> 16 & 255, H2[1] >> 8 & 255, H2[1] & 255, H2[2] >> 24 & 255, H2[2] >> 16 & 255, H2[2] >> 8 & 255, H2[2] & 255, H2[3] >> 24 & 255, H2[3] >> 16 & 255, H2[3] >> 8 & 255, H2[3] & 255, H2[4] >> 24 & 255, H2[4] >> 16 & 255, H2[4] >> 8 & 255, H2[4] & 255];
}
var v5 = v35("v5", 80, sha1);
const nil = "00000000-0000-0000-0000-000000000000";
function version(uuid) {
  if (!validate(uuid)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid.substr(14, 1), 16);
}
const esmBrowser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  NIL: nil,
  parse,
  stringify,
  v1,
  v3,
  v4,
  v5,
  validate,
  version
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(esmBrowser);
var generateRequest_1;
var hasRequiredGenerateRequest;
function requireGenerateRequest() {
  if (hasRequiredGenerateRequest) return generateRequest_1;
  hasRequiredGenerateRequest = 1;
  const uuid = require$$0.v4;
  const generateRequest = function(method, params, id, options) {
    if (typeof method !== "string") {
      throw new TypeError(method + " must be a string");
    }
    options = options || {};
    const version2 = typeof options.version === "number" ? options.version : 2;
    if (version2 !== 1 && version2 !== 2) {
      throw new TypeError(version2 + " must be 1 or 2");
    }
    const request = {
      method
    };
    if (version2 === 2) {
      request.jsonrpc = "2.0";
    }
    if (params) {
      if (typeof params !== "object" && !Array.isArray(params)) {
        throw new TypeError(params + " must be an object, array or omitted");
      }
      request.params = params;
    }
    if (typeof id === "undefined") {
      const generator = typeof options.generator === "function" ? options.generator : function() {
        return uuid();
      };
      request.id = generator(request, options);
    } else if (version2 === 2 && id === null) {
      if (options.notificationIdNull) {
        request.id = null;
      }
    } else {
      request.id = id;
    }
    return request;
  };
  generateRequest_1 = generateRequest;
  return generateRequest_1;
}
var browser;
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser;
  hasRequiredBrowser = 1;
  const uuid = require$$0.v4;
  const generateRequest = requireGenerateRequest();
  const ClientBrowser = function(callServer, options) {
    if (!(this instanceof ClientBrowser)) {
      return new ClientBrowser(callServer, options);
    }
    if (!options) {
      options = {};
    }
    this.options = {
      reviver: typeof options.reviver !== "undefined" ? options.reviver : null,
      replacer: typeof options.replacer !== "undefined" ? options.replacer : null,
      generator: typeof options.generator !== "undefined" ? options.generator : function() {
        return uuid();
      },
      version: typeof options.version !== "undefined" ? options.version : 2,
      notificationIdNull: typeof options.notificationIdNull === "boolean" ? options.notificationIdNull : false
    };
    this.callServer = callServer;
  };
  browser = ClientBrowser;
  ClientBrowser.prototype.request = function(method, params, id, callback) {
    const self = this;
    let request = null;
    const isBatch = Array.isArray(method) && typeof params === "function";
    if (this.options.version === 1 && isBatch) {
      throw new TypeError("JSON-RPC 1.0 does not support batching");
    }
    const isRaw = !isBatch && method && typeof method === "object" && typeof params === "function";
    if (isBatch || isRaw) {
      callback = params;
      request = method;
    } else {
      if (typeof id === "function") {
        callback = id;
        id = void 0;
      }
      const hasCallback = typeof callback === "function";
      try {
        request = generateRequest(method, params, id, {
          generator: this.options.generator,
          version: this.options.version,
          notificationIdNull: this.options.notificationIdNull
        });
      } catch (err) {
        if (hasCallback) {
          return callback(err);
        }
        throw err;
      }
      if (!hasCallback) {
        return request;
      }
    }
    let message;
    try {
      message = JSON.stringify(request, this.options.replacer);
    } catch (err) {
      return callback(err);
    }
    this.callServer(message, function(err, response) {
      self._parseResponse(err, response, callback);
    });
    return request;
  };
  ClientBrowser.prototype._parseResponse = function(err, responseText, callback) {
    if (err) {
      callback(err);
      return;
    }
    if (!responseText) {
      return callback();
    }
    let response;
    try {
      response = JSON.parse(responseText, this.options.reviver);
    } catch (err2) {
      return callback(err2);
    }
    if (callback.length === 3) {
      if (Array.isArray(response)) {
        const isError = function(res) {
          return typeof res.error !== "undefined";
        };
        const isNotError = function(res) {
          return !isError(res);
        };
        return callback(null, response.filter(isError), response.filter(isNotError));
      } else {
        return callback(null, response.error, response.result);
      }
    }
    callback(null, response);
  };
  return browser;
}
var browserExports = requireBrowser();
const RpcClient = /* @__PURE__ */ getDefaultExportFromCjs$1(browserExports);
var WebSocketBrowserImpl = class extends EventEmitter$1 {
  /** Instantiate a WebSocket class
  * @constructor
  * @param {String} address - url to a websocket server
  * @param {(Object)} options - websocket options
  * @param {(String|Array)} protocols - a list of protocols
  * @return {WebSocketBrowserImpl} - returns a WebSocket instance
  */
  constructor(address, options, protocols) {
    super();
    __publicField(this, "socket");
    this.socket = new window.WebSocket(address, protocols);
    this.socket.onopen = () => this.emit("open");
    this.socket.onmessage = (event) => this.emit("message", event.data);
    this.socket.onerror = (error) => this.emit("error", error);
    this.socket.onclose = (event) => {
      this.emit("close", event.code, event.reason);
    };
  }
  /**
  * Sends data through a websocket connection
  * @method
  * @param {(String|Object)} data - data to be sent via websocket
  * @param {Object} optionsOrCallback - ws options
  * @param {Function} callback - a callback called once the data is sent
  * @return {Undefined}
  */
  send(data, optionsOrCallback, callback) {
    const cb = callback || optionsOrCallback;
    try {
      this.socket.send(data);
      cb();
    } catch (error) {
      cb(error);
    }
  }
  /**
  * Closes an underlying socket
  * @method
  * @param {Number} code - status code explaining why the connection is being closed
  * @param {String} reason - a description why the connection is closing
  * @return {Undefined}
  * @throws {Error}
  */
  close(code, reason) {
    this.socket.close(code, reason);
  }
  addEventListener(type2, listener, options) {
    this.socket.addEventListener(type2, listener, options);
  }
};
function WebSocket(address, options) {
  return new WebSocketBrowserImpl(address, options);
}
var DefaultDataPack = class {
  encode(value) {
    return JSON.stringify(value);
  }
  decode(value) {
    return JSON.parse(value);
  }
};
var CommonClient = class extends EventEmitter$1 {
  /**
  * Instantiate a Client class.
  * @constructor
  * @param {webSocketFactory} webSocketFactory - factory method for WebSocket
  * @param {String} address - url to a websocket server
  * @param {Object} options - ws options object with reconnect parameters
  * @param {Function} generate_request_id - custom generation request Id
  * @param {DataPack} dataPack - data pack contains encoder and decoder
  * @return {CommonClient}
  */
  constructor(webSocketFactory, address = "ws://localhost:8080", {
    autoconnect = true,
    reconnect = true,
    reconnect_interval = 1e3,
    max_reconnects = 5,
    ...rest_options
  } = {}, generate_request_id, dataPack) {
    super();
    __publicField(this, "address");
    __publicField(this, "rpc_id");
    __publicField(this, "queue");
    __publicField(this, "options");
    __publicField(this, "autoconnect");
    __publicField(this, "ready");
    __publicField(this, "reconnect");
    __publicField(this, "reconnect_timer_id");
    __publicField(this, "reconnect_interval");
    __publicField(this, "max_reconnects");
    __publicField(this, "rest_options");
    __publicField(this, "current_reconnects");
    __publicField(this, "generate_request_id");
    __publicField(this, "socket");
    __publicField(this, "webSocketFactory");
    __publicField(this, "dataPack");
    this.webSocketFactory = webSocketFactory;
    this.queue = {};
    this.rpc_id = 0;
    this.address = address;
    this.autoconnect = autoconnect;
    this.ready = false;
    this.reconnect = reconnect;
    this.reconnect_timer_id = void 0;
    this.reconnect_interval = reconnect_interval;
    this.max_reconnects = max_reconnects;
    this.rest_options = rest_options;
    this.current_reconnects = 0;
    this.generate_request_id = generate_request_id || (() => typeof this.rpc_id === "number" ? ++this.rpc_id : Number(this.rpc_id) + 1);
    if (!dataPack) this.dataPack = new DefaultDataPack();
    else this.dataPack = dataPack;
    if (this.autoconnect)
      this._connect(this.address, {
        autoconnect: this.autoconnect,
        reconnect: this.reconnect,
        reconnect_interval: this.reconnect_interval,
        max_reconnects: this.max_reconnects,
        ...this.rest_options
      });
  }
  /**
  * Connects to a defined server if not connected already.
  * @method
  * @return {Undefined}
  */
  connect() {
    if (this.socket) return;
    this._connect(this.address, {
      autoconnect: this.autoconnect,
      reconnect: this.reconnect,
      reconnect_interval: this.reconnect_interval,
      max_reconnects: this.max_reconnects,
      ...this.rest_options
    });
  }
  /**
  * Calls a registered RPC method on server.
  * @method
  * @param {String} method - RPC method name
  * @param {Object|Array} params - optional method parameters
  * @param {Number} timeout - RPC reply timeout value
  * @param {Object} ws_opts - options passed to ws
  * @return {Promise}
  */
  call(method, params, timeout, ws_opts) {
    if (!ws_opts && "object" === typeof timeout) {
      ws_opts = timeout;
      timeout = null;
    }
    return new Promise((resolve, reject) => {
      if (!this.ready) return reject(new Error("socket not ready"));
      const rpc_id = this.generate_request_id(method, params);
      const message = {
        jsonrpc: "2.0",
        method,
        params: params || void 0,
        id: rpc_id
      };
      this.socket.send(this.dataPack.encode(message), ws_opts, (error) => {
        if (error) return reject(error);
        this.queue[rpc_id] = { promise: [resolve, reject] };
        if (timeout) {
          this.queue[rpc_id].timeout = setTimeout(() => {
            delete this.queue[rpc_id];
            reject(new Error("reply timeout"));
          }, timeout);
        }
      });
    });
  }
  /**
  * Logins with the other side of the connection.
  * @method
  * @param {Object} params - Login credentials object
  * @return {Promise}
  */
  async login(params) {
    const resp = await this.call("rpc.login", params);
    if (!resp) throw new Error("authentication failed");
    return resp;
  }
  /**
  * Fetches a list of client's methods registered on server.
  * @method
  * @return {Array}
  */
  async listMethods() {
    return await this.call("__listMethods");
  }
  /**
  * Sends a JSON-RPC 2.0 notification to server.
  * @method
  * @param {String} method - RPC method name
  * @param {Object} params - optional method parameters
  * @return {Promise}
  */
  notify(method, params) {
    return new Promise((resolve, reject) => {
      if (!this.ready) return reject(new Error("socket not ready"));
      const message = {
        jsonrpc: "2.0",
        method,
        params
      };
      this.socket.send(this.dataPack.encode(message), (error) => {
        if (error) return reject(error);
        resolve();
      });
    });
  }
  /**
  * Subscribes for a defined event.
  * @method
  * @param {String|Array} event - event name
  * @return {Undefined}
  * @throws {Error}
  */
  async subscribe(event) {
    if (typeof event === "string") event = [event];
    const result = await this.call("rpc.on", event);
    if (typeof event === "string" && result[event] !== "ok")
      throw new Error(
        "Failed subscribing to an event '" + event + "' with: " + result[event]
      );
    return result;
  }
  /**
  * Unsubscribes from a defined event.
  * @method
  * @param {String|Array} event - event name
  * @return {Undefined}
  * @throws {Error}
  */
  async unsubscribe(event) {
    if (typeof event === "string") event = [event];
    const result = await this.call("rpc.off", event);
    if (typeof event === "string" && result[event] !== "ok")
      throw new Error("Failed unsubscribing from an event with: " + result);
    return result;
  }
  /**
  * Closes a WebSocket connection gracefully.
  * @method
  * @param {Number} code - socket close code
  * @param {String} data - optional data to be sent before closing
  * @return {Undefined}
  */
  close(code, data) {
    this.socket.close(code || 1e3, data);
  }
  /**
  * Enable / disable automatic reconnection.
  * @method
  * @param {Boolean} reconnect - enable / disable reconnection
  * @return {Undefined}
  */
  setAutoReconnect(reconnect) {
    this.reconnect = reconnect;
  }
  /**
  * Set the interval between reconnection attempts.
  * @method
  * @param {Number} interval - reconnection interval in milliseconds
  * @return {Undefined}
  */
  setReconnectInterval(interval) {
    this.reconnect_interval = interval;
  }
  /**
  * Set the maximum number of reconnection attempts.
  * @method
  * @param {Number} max_reconnects - maximum reconnection attempts
  * @return {Undefined}
  */
  setMaxReconnects(max_reconnects) {
    this.max_reconnects = max_reconnects;
  }
  /**
  * Connection/Message handler.
  * @method
  * @private
  * @param {String} address - WebSocket API address
  * @param {Object} options - ws options object
  * @return {Undefined}
  */
  _connect(address, options) {
    clearTimeout(this.reconnect_timer_id);
    this.socket = this.webSocketFactory(address, options);
    this.socket.addEventListener("open", () => {
      this.ready = true;
      this.emit("open");
      this.current_reconnects = 0;
    });
    this.socket.addEventListener("message", ({ data: message }) => {
      if (message instanceof ArrayBuffer)
        message = bufferExports.Buffer.from(message).toString();
      try {
        message = this.dataPack.decode(message);
      } catch (error) {
        return;
      }
      if (message.notification && this.listeners(message.notification).length) {
        if (!Object.keys(message.params).length)
          return this.emit(message.notification);
        const args = [message.notification];
        if (message.params.constructor === Object) args.push(message.params);
        else
          for (let i = 0; i < message.params.length; i++)
            args.push(message.params[i]);
        return Promise.resolve().then(() => {
          this.emit.apply(this, args);
        });
      }
      if (!this.queue[message.id]) {
        if (message.method) {
          return Promise.resolve().then(() => {
            this.emit(message.method, message?.params);
          });
        }
        return;
      }
      if ("error" in message === "result" in message)
        this.queue[message.id].promise[1](
          new Error(
            'Server response malformed. Response must include either "result" or "error", but not both.'
          )
        );
      if (this.queue[message.id].timeout)
        clearTimeout(this.queue[message.id].timeout);
      if (message.error) this.queue[message.id].promise[1](message.error);
      else this.queue[message.id].promise[0](message.result);
      delete this.queue[message.id];
    });
    this.socket.addEventListener("error", (error) => this.emit("error", error));
    this.socket.addEventListener("close", ({ code, reason }) => {
      if (this.ready)
        setTimeout(() => this.emit("close", code, reason), 0);
      this.ready = false;
      this.socket = void 0;
      if (code === 1e3) return;
      this.current_reconnects++;
      if (this.reconnect && (this.max_reconnects > this.current_reconnects || this.max_reconnects === 0))
        this.reconnect_timer_id = setTimeout(
          () => this._connect(address, options),
          this.reconnect_interval
        );
    });
  }
};
class HMAC extends Hash {
  constructor(hash, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    ahash(hash);
    const key = toBytes(_key);
    this.iHash = hash.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash.create();
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    clean(pad);
  }
  update(buf) {
    aexists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    aexists(this);
    abytes$1(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished: finished2, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished2;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
}
const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
hmac.create = (hash, key) => new HMAC(hash, key);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validateSigVerOpts(opts) {
  if (opts.lowS !== void 0)
    abool("lowS", opts.lowS);
  if (opts.prehash !== void 0)
    abool("prehash", opts.prehash);
}
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowInfinityPoint: "boolean",
    allowedPrivateKeyLengths: "array",
    clearCofactor: "function",
    fromBytes: "function",
    isTorsionFree: "function",
    toBytes: "function",
    wrapPrivateKey: "boolean"
  });
  const { endo, Fp: Fp2, a } = opts;
  if (endo) {
    if (!Fp2.eql(a, Fp2.ZERO)) {
      throw new Error("invalid endo: CURVE.a must be 0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
    }
  }
  return Object.freeze({ ...opts });
}
class DERErr extends Error {
  constructor(m = "") {
    super(m);
  }
}
const DER = {
  // asn.1 DER encoding utils
  Err: DERErr,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (tag, data) => {
      const { Err: E2 } = DER;
      if (tag < 0 || tag > 256)
        throw new E2("tlv.encode: wrong tag");
      if (data.length & 1)
        throw new E2("tlv.encode: unpadded data");
      const dataLen = data.length / 2;
      const len = numberToHexUnpadded(dataLen);
      if (len.length / 2 & 128)
        throw new E2("tlv.encode: long form length too big");
      const lenLen = dataLen > 127 ? numberToHexUnpadded(len.length / 2 | 128) : "";
      const t = numberToHexUnpadded(tag);
      return t + lenLen + len + data;
    },
    // v - value, l - left bytes (unparsed)
    decode(tag, data) {
      const { Err: E2 } = DER;
      let pos = 0;
      if (tag < 0 || tag > 256)
        throw new E2("tlv.encode: wrong tag");
      if (data.length < 2 || data[pos++] !== tag)
        throw new E2("tlv.decode: wrong tlv");
      const first = data[pos++];
      const isLong = !!(first & 128);
      let length = 0;
      if (!isLong)
        length = first;
      else {
        const lenLen = first & 127;
        if (!lenLen)
          throw new E2("tlv.decode(long): indefinite length not supported");
        if (lenLen > 4)
          throw new E2("tlv.decode(long): byte length is too big");
        const lengthBytes = data.subarray(pos, pos + lenLen);
        if (lengthBytes.length !== lenLen)
          throw new E2("tlv.decode: length bytes not complete");
        if (lengthBytes[0] === 0)
          throw new E2("tlv.decode(long): zero leftmost byte");
        for (const b2 of lengthBytes)
          length = length << 8 | b2;
        pos += lenLen;
        if (length < 128)
          throw new E2("tlv.decode(long): not minimal encoding");
      }
      const v2 = data.subarray(pos, pos + length);
      if (v2.length !== length)
        throw new E2("tlv.decode: wrong value length");
      return { v: v2, l: data.subarray(pos + length) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(num) {
      const { Err: E2 } = DER;
      if (num < _0n$1)
        throw new E2("integer: negative integers are not allowed");
      let hex = numberToHexUnpadded(num);
      if (Number.parseInt(hex[0], 16) & 8)
        hex = "00" + hex;
      if (hex.length & 1)
        throw new E2("unexpected DER parsing assertion: unpadded hex");
      return hex;
    },
    decode(data) {
      const { Err: E2 } = DER;
      if (data[0] & 128)
        throw new E2("invalid signature integer: negative");
      if (data[0] === 0 && !(data[1] & 128))
        throw new E2("invalid signature integer: unnecessary leading zero");
      return bytesToNumberBE(data);
    }
  },
  toSig(hex) {
    const { Err: E2, _int: int, _tlv: tlv } = DER;
    const data = ensureBytes("signature", hex);
    const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
    if (seqLeftBytes.length)
      throw new E2("invalid signature: left bytes after parsing");
    const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
    const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
    if (sLeftBytes.length)
      throw new E2("invalid signature: left bytes after parsing");
    return { r: int.decode(rBytes), s: int.decode(sBytes) };
  },
  hexFromSig(sig) {
    const { _tlv: tlv, _int: int } = DER;
    const rs = tlv.encode(2, int.encode(sig.r));
    const ss = tlv.encode(2, int.encode(sig.s));
    const seq = rs + ss;
    return tlv.encode(48, seq);
  }
};
function numToSizedHex(num, size) {
  return bytesToHex(numberToBytesBE(num, size));
}
const _0n$1 = BigInt(0), _1n$1 = BigInt(1);
BigInt(2);
const _3n = BigInt(3), _4n = BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp2 } = CURVE;
  const Fn = Field(CURVE.n, CURVE.nBitLength);
  const toBytes2 = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a = point.toAffine();
    return concatBytes(Uint8Array.from([4]), Fp2.toBytes(a.x), Fp2.toBytes(a.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes) => {
    const tail = bytes.subarray(1);
    const x2 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
    const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
    return { x: x2, y };
  });
  function weierstrassEquation(x2) {
    const { a, b: b2 } = CURVE;
    const x22 = Fp2.sqr(x2);
    const x3 = Fp2.mul(x22, x2);
    return Fp2.add(Fp2.add(x3, Fp2.mul(x2, a)), b2);
  }
  function isValidXY(x2, y) {
    const left = Fp2.sqr(y);
    const right = weierstrassEquation(x2);
    return Fp2.eql(left, right);
  }
  if (!isValidXY(CURVE.Gx, CURVE.Gy))
    throw new Error("bad curve params: generator point");
  const _4a3 = Fp2.mul(Fp2.pow(CURVE.a, _3n), _4n);
  const _27b2 = Fp2.mul(Fp2.sqr(CURVE.b), BigInt(27));
  if (Fp2.is0(Fp2.add(_4a3, _27b2)))
    throw new Error("bad curve params: a or b");
  function isWithinCurveOrder(num) {
    return inRange$1(num, _1n$1, CURVE.n);
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N2 } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (isBytes(key))
        key = bytesToHex(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("invalid private key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error) {
      throw new Error("invalid private key, expected hex or " + nByteLength + " bytes, got " + typeof key);
    }
    if (wrapPrivateKey)
      num = mod(num, N2);
    aInRange("private key", num, _1n$1, N2);
    return num;
  }
  function aprjpoint(other) {
    if (!(other instanceof Point))
      throw new Error("ProjectivePoint expected");
  }
  const toAffineMemo = memoized((p, iz) => {
    const { px: x2, py: y, pz: z2 } = p;
    if (Fp2.eql(z2, Fp2.ONE))
      return { x: x2, y };
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? Fp2.ONE : Fp2.inv(z2);
    const ax = Fp2.mul(x2, iz);
    const ay = Fp2.mul(y, iz);
    const zz = Fp2.mul(z2, iz);
    if (is0)
      return { x: Fp2.ZERO, y: Fp2.ZERO };
    if (!Fp2.eql(zz, Fp2.ONE))
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized((p) => {
    if (p.is0()) {
      if (CURVE.allowInfinityPoint && !Fp2.is0(p.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: x2, y } = p.toAffine();
    if (!Fp2.isValid(x2) || !Fp2.isValid(y))
      throw new Error("bad point: x or y not FE");
    if (!isValidXY(x2, y))
      throw new Error("bad point: equation left != right");
    if (!p.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  class Point {
    constructor(px, py, pz) {
      if (px == null || !Fp2.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp2.isValid(py) || Fp2.is0(py))
        throw new Error("y required");
      if (pz == null || !Fp2.isValid(pz))
        throw new Error("z required");
      this.px = px;
      this.py = py;
      this.pz = pz;
      Object.freeze(this);
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p) {
      const { x: x2, y } = p || {};
      if (!p || !Fp2.isValid(x2) || !Fp2.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point)
        throw new Error("projective point not allowed");
      const is0 = (i) => Fp2.eql(i, Fp2.ZERO);
      if (is0(x2) && is0(y))
        return Point.ZERO;
      return new Point(x2, y, Fp2.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = FpInvertBatch(Fp2, points.map((p) => p.pz));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex) {
      const P2 = Point.fromAffine(fromBytes(ensureBytes("pointHex", hex)));
      P2.assertValidity();
      return P2;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // Multiscalar Multiplication
    static msm(points, scalars) {
      return pippenger(Point, Fn, points, scalars);
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      wnaf.setWindowSize(this, windowSize);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (Fp2.isOdd)
        return !Fp2.isOdd(y);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      aprjpoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U1 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
      const U2 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
      return U1 && U2;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point(this.px, Fp2.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a, b: b2 } = CURVE;
      const b3 = Fp2.mul(b2, _3n);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      let t0 = Fp2.mul(X1, X1);
      let t1 = Fp2.mul(Y1, Y1);
      let t2 = Fp2.mul(Z1, Z1);
      let t3 = Fp2.mul(X1, Y1);
      t3 = Fp2.add(t3, t3);
      Z3 = Fp2.mul(X1, Z1);
      Z3 = Fp2.add(Z3, Z3);
      X3 = Fp2.mul(a, Z3);
      Y3 = Fp2.mul(b3, t2);
      Y3 = Fp2.add(X3, Y3);
      X3 = Fp2.sub(t1, Y3);
      Y3 = Fp2.add(t1, Y3);
      Y3 = Fp2.mul(X3, Y3);
      X3 = Fp2.mul(t3, X3);
      Z3 = Fp2.mul(b3, Z3);
      t2 = Fp2.mul(a, t2);
      t3 = Fp2.sub(t0, t2);
      t3 = Fp2.mul(a, t3);
      t3 = Fp2.add(t3, Z3);
      Z3 = Fp2.add(t0, t0);
      t0 = Fp2.add(Z3, t0);
      t0 = Fp2.add(t0, t2);
      t0 = Fp2.mul(t0, t3);
      Y3 = Fp2.add(Y3, t0);
      t2 = Fp2.mul(Y1, Z1);
      t2 = Fp2.add(t2, t2);
      t0 = Fp2.mul(t2, t3);
      X3 = Fp2.sub(X3, t0);
      Z3 = Fp2.mul(t2, t1);
      Z3 = Fp2.add(Z3, Z3);
      Z3 = Fp2.add(Z3, Z3);
      return new Point(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      aprjpoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      const a = CURVE.a;
      const b3 = Fp2.mul(CURVE.b, _3n);
      let t0 = Fp2.mul(X1, X2);
      let t1 = Fp2.mul(Y1, Y2);
      let t2 = Fp2.mul(Z1, Z2);
      let t3 = Fp2.add(X1, Y1);
      let t4 = Fp2.add(X2, Y2);
      t3 = Fp2.mul(t3, t4);
      t4 = Fp2.add(t0, t1);
      t3 = Fp2.sub(t3, t4);
      t4 = Fp2.add(X1, Z1);
      let t5 = Fp2.add(X2, Z2);
      t4 = Fp2.mul(t4, t5);
      t5 = Fp2.add(t0, t2);
      t4 = Fp2.sub(t4, t5);
      t5 = Fp2.add(Y1, Z1);
      X3 = Fp2.add(Y2, Z2);
      t5 = Fp2.mul(t5, X3);
      X3 = Fp2.add(t1, t2);
      t5 = Fp2.sub(t5, X3);
      Z3 = Fp2.mul(a, t4);
      X3 = Fp2.mul(b3, t2);
      Z3 = Fp2.add(X3, Z3);
      X3 = Fp2.sub(t1, Z3);
      Z3 = Fp2.add(t1, Z3);
      Y3 = Fp2.mul(X3, Z3);
      t1 = Fp2.add(t0, t0);
      t1 = Fp2.add(t1, t0);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.mul(b3, t4);
      t1 = Fp2.add(t1, t2);
      t2 = Fp2.sub(t0, t2);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.add(t4, t2);
      t0 = Fp2.mul(t1, t4);
      Y3 = Fp2.add(Y3, t0);
      t0 = Fp2.mul(t5, t4);
      X3 = Fp2.mul(t3, X3);
      X3 = Fp2.sub(X3, t0);
      t0 = Fp2.mul(t3, t1);
      Z3 = Fp2.mul(t5, Z3);
      Z3 = Fp2.add(Z3, t0);
      return new Point(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    wNAF(n) {
      return wnaf.wNAFCached(this, n, Point.normalizeZ);
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(sc) {
      const { endo: endo2, n: N2 } = CURVE;
      aInRange("scalar", sc, _0n$1, N2);
      const I = Point.ZERO;
      if (sc === _0n$1)
        return I;
      if (this.is0() || sc === _1n$1)
        return this;
      if (!endo2 || wnaf.hasPrecomputes(this))
        return wnaf.wNAFCachedUnsafe(this, sc, Point.normalizeZ);
      let { k1neg, k1, k2neg, k2 } = endo2.splitScalar(sc);
      let k1p = I;
      let k2p = I;
      let d2 = this;
      while (k1 > _0n$1 || k2 > _0n$1) {
        if (k1 & _1n$1)
          k1p = k1p.add(d2);
        if (k2 & _1n$1)
          k2p = k2p.add(d2);
        d2 = d2.double();
        k1 >>= _1n$1;
        k2 >>= _1n$1;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point(Fp2.mul(k2p.px, endo2.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      const { endo: endo2, n: N2 } = CURVE;
      aInRange("scalar", scalar, _1n$1, N2);
      let point, fake;
      if (endo2) {
        const { k1neg, k1, k2neg, k2 } = endo2.splitScalar(scalar);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point(Fp2.mul(k2p.px, endo2.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f: f2 } = this.wNAF(scalar);
        point = p;
        fake = f2;
      }
      return Point.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q, a, b2) {
      const G2 = Point.BASE;
      const mul = (P2, a2) => a2 === _0n$1 || a2 === _1n$1 || !P2.equals(G2) ? P2.multiplyUnsafe(a2) : P2.multiply(a2);
      const sum = mul(this, a).add(mul(Q, b2));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(iz) {
      return toAffineMemo(this, iz);
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n$1)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n$1)
        return this;
      if (clearCofactor)
        return clearCofactor(Point, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      abool("isCompressed", isCompressed);
      this.assertValidity();
      return toBytes2(Point, this, isCompressed);
    }
    toHex(isCompressed = true) {
      abool("isCompressed", isCompressed);
      return bytesToHex(this.toRawBytes(isCompressed));
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp2.ONE);
  Point.ZERO = new Point(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
  const { endo, nBitLength } = CURVE;
  const wnaf = wNAF(Point, endo ? Math.ceil(nBitLength / 2) : nBitLength);
  return {
    CURVE,
    ProjectivePoint: Point,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER, nByteLength, nBitLength } = CURVE;
  const compressedLen = Fp2.BYTES + 1;
  const uncompressedLen = 2 * Fp2.BYTES + 1;
  function modN(a) {
    return mod(a, CURVE_ORDER);
  }
  function invN(a) {
    return invert(a, CURVE_ORDER);
  }
  const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a = point.toAffine();
      const x2 = Fp2.toBytes(a.x);
      const cat = concatBytes;
      abool("isCompressed", isCompressed);
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x2);
      } else {
        return cat(Uint8Array.from([4]), x2, Fp2.toBytes(a.y));
      }
    },
    fromBytes(bytes) {
      const len = bytes.length;
      const head = bytes[0];
      const tail = bytes.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x2 = bytesToNumberBE(tail);
        if (!inRange$1(x2, _1n$1, Fp2.ORDER))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x2);
        let y;
        try {
          y = Fp2.sqrt(y2);
        } catch (sqrtError) {
          const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("Point is not on curve" + suffix);
        }
        const isYOdd = (y & _1n$1) === _1n$1;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y = Fp2.neg(y);
        return { x: x2, y };
      } else if (len === uncompressedLen && head === 4) {
        const x2 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
        const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
        return { x: x2, y };
      } else {
        const cl = compressedLen;
        const ul = uncompressedLen;
        throw new Error("invalid Point, expected length of " + cl + ", or uncompressed " + ul + ", got " + len);
      }
    }
  });
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n$1;
    return number2 > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN(-s) : s;
  }
  const slcNum = (b2, from, to) => bytesToNumberBE(b2.slice(from, to));
  class Signature {
    constructor(r, s, recovery) {
      aInRange("r", r, _1n$1, CURVE_ORDER);
      aInRange("s", s, _1n$1, CURVE_ORDER);
      this.r = r;
      this.s = s;
      if (recovery != null)
        this.recovery = recovery;
      Object.freeze(this);
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex) {
      const l = nByteLength;
      hex = ensureBytes("compactSignature", hex, l * 2);
      return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex) {
      const { r, s } = DER.toSig(ensureBytes("DER", hex));
      return new Signature(r, s);
    }
    /**
     * @todo remove
     * @deprecated
     */
    assertValidity() {
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r, s, recovery: rec } = this;
      const h2 = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
      if (radj >= Fp2.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R = Point.fromHex(prefix + numToSizedHex(radj, Fp2.BYTES));
      const ir = invN(radj);
      const u1 = modN(-h2 * ir);
      const u2 = modN(s * ir);
      const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig(this);
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      const l = nByteLength;
      return numToSizedHex(this.r, l) + numToSizedHex(this.s, l);
    }
  }
  const utils = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    if (typeof item === "bigint")
      return false;
    if (item instanceof Point)
      return true;
    const arr = ensureBytes("key", item);
    const len = arr.length;
    const fpl = Fp2.BYTES;
    const compLen = fpl + 1;
    const uncompLen = 2 * fpl + 1;
    if (CURVE.allowedPrivateKeyLengths || nByteLength === compLen) {
      return void 0;
    } else {
      return len === compLen || len === uncompLen;
    }
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA) === true)
      throw new Error("first arg must be private key");
    if (isProbPub(publicB) === false)
      throw new Error("second arg must be public key");
    const b2 = Point.fromHex(publicB);
    return b2.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes) {
    if (bytes.length > 8192)
      throw new Error("input is too large");
    const num = bytesToNumberBE(bytes);
    const delta = bytes.length * 8 - nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes) {
    return modN(bits2int(bytes));
  };
  const ORDER_MASK = bitMask(nBitLength);
  function int2octets(num) {
    aInRange("num < 2^" + nBitLength, num, _0n$1, ORDER_MASK);
    return numberToBytesBE(num, nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k2) => k2 in opts))
      throw new Error("sign() legacy options not supported");
    const { hash, randomBytes: randomBytes2 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    validateSigVerOpts(opts);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d2 = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d2), int2octets(h1int)];
    if (ent != null && ent !== false) {
      const e3 = ent === true ? randomBytes2(Fp2.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e3));
    }
    const seed = concatBytes(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k2 = bits2int(kBytes);
      if (!isWithinCurveOrder(k2))
        return;
      const ik = invN(k2);
      const q = Point.BASE.multiply(k2).toAffine();
      const r = modN(q.x);
      if (r === _0n$1)
        return;
      const s = modN(ik * modN(m + r * d2));
      if (s === _0n$1)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n$1);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign2(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C2 = CURVE;
    const drbg = createHmacDrbg(C2.hash.outputLen, C2.nByteLength, C2.hmac);
    return drbg(seed, k2sig);
  }
  Point.BASE._setWindowSize(8);
  function verify2(signature2, msgHash, publicKey2, opts = defaultVerOpts) {
    const sg = signature2;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey2 = ensureBytes("publicKey", publicKey2);
    const { lowS, prehash, format } = opts;
    validateSigVerOpts(opts);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    if (format !== void 0 && format !== "compact" && format !== "der")
      throw new Error("format must be compact or der");
    const isHex = typeof sg === "string" || isBytes(sg);
    const isObj = !isHex && !format && typeof sg === "object" && sg !== null && typeof sg.r === "bigint" && typeof sg.s === "bigint";
    if (!isHex && !isObj)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let _sig = void 0;
    let P2;
    try {
      if (isObj)
        _sig = new Signature(sg.r, sg.s);
      if (isHex) {
        try {
          if (format !== "compact")
            _sig = Signature.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
        }
        if (!_sig && format !== "der")
          _sig = Signature.fromCompact(sg);
      }
      P2 = Point.fromHex(publicKey2);
    } catch (error) {
      return false;
    }
    if (!_sig)
      return false;
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r, s } = _sig;
    const h2 = bits2int_modN(msgHash);
    const is2 = invN(s);
    const u1 = modN(h2 * is2);
    const u2 = modN(r * is2);
    const R = Point.BASE.multiplyAndAddUnsafe(P2, u1, u2)?.toAffine();
    if (!R)
      return false;
    const v2 = modN(R.x);
    return v2 === r;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign: sign2,
    verify: verify2,
    ProjectivePoint: Point,
    Signature,
    utils
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function getHash(hash) {
  return {
    hash,
    hmac: (key, ...msgs) => hmac(hash, key, concatBytes$1(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create2 = (hash) => weierstrass({ ...curveDef, ...getHash(hash) });
  return { ...create2(defHash), create: create2 };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
const secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const divNearest = (a, b2) => (a + b2 / _2n) / b2;
function sqrtMod(y) {
  const P2 = secp256k1P;
  const _3n2 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P2;
  const b3 = b2 * b2 * y % P2;
  const b6 = pow2(b3, _3n2, P2) * b3 % P2;
  const b9 = pow2(b6, _3n2, P2) * b3 % P2;
  const b11 = pow2(b9, _2n, P2) * b2 % P2;
  const b22 = pow2(b11, _11n, P2) * b11 % P2;
  const b44 = pow2(b22, _22n, P2) * b22 % P2;
  const b88 = pow2(b44, _44n, P2) * b44 % P2;
  const b176 = pow2(b88, _88n, P2) * b88 % P2;
  const b220 = pow2(b176, _44n, P2) * b44 % P2;
  const b223 = pow2(b220, _3n2, P2) * b3 % P2;
  const t1 = pow2(b223, _23n, P2) * b22 % P2;
  const t2 = pow2(t1, _6n, P2) * b2 % P2;
  const root = pow2(t2, _2n, P2);
  if (!Fpk1.eql(Fpk1.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
const Fpk1 = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
const secp256k1 = createCurve({
  a: _0n,
  b: BigInt(7),
  Fp: Fpk1,
  n: secp256k1N,
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: true,
  // Allow only low-S signatures by default in sign() and verify()
  endo: {
    // Endomorphism, see above
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k2) => {
      const n = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b2 * k2, n);
      const c2 = divNearest(-b1 * k2, n);
      let k1 = mod(k2 - c1 * a1 - c2 * a2, n);
      let k22 = mod(-c1 * b1 - c2 * b2, n);
      const k1neg = k1 > POW_2_128;
      const k2neg = k22 > POW_2_128;
      if (k1neg)
        k1 = n - k1;
      if (k2neg)
        k22 = n - k22;
      if (k1 > POW_2_128 || k22 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k2);
      }
      return { k1neg, k1, k2neg, k2: k22 };
    }
  }
}, sha256$1);
function isOnCurve(publicKey2) {
  try {
    ed25519.ExtendedPoint.fromHex(publicKey2);
    return true;
  } catch {
    return false;
  }
}
const sign = (message, secretKey) => ed25519.sign(message, secretKey.slice(0, 32));
const verify = ed25519.verify;
const toBuffer = (arr) => {
  if (bufferExports.Buffer.isBuffer(arr)) {
    return arr;
  } else if (arr instanceof Uint8Array) {
    return bufferExports.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);
  } else {
    return bufferExports.Buffer.from(arr);
  }
};
class Struct2 {
  constructor(properties) {
    Object.assign(this, properties);
  }
  encode() {
    return bufferExports.Buffer.from(libExports.serialize(SOLANA_SCHEMA, this));
  }
  static decode(data) {
    return libExports.deserialize(SOLANA_SCHEMA, this, data);
  }
  static decodeUnchecked(data) {
    return libExports.deserializeUnchecked(SOLANA_SCHEMA, this, data);
  }
}
const SOLANA_SCHEMA = /* @__PURE__ */ new Map();
var _PublicKey;
const MAX_SEED_LENGTH = 32;
const PUBLIC_KEY_LENGTH = 32;
function isPublicKeyData(value) {
  return value._bn !== void 0;
}
let uniquePublicKeyCounter = 1;
class PublicKey extends Struct2 {
  /**
   * Create a new PublicKey object
   * @param value ed25519 public key as buffer or base-58 encoded string
   */
  constructor(value) {
    super({});
    this._bn = void 0;
    if (isPublicKeyData(value)) {
      this._bn = value._bn;
    } else {
      if (typeof value === "string") {
        const decoded = bs58.decode(value);
        if (decoded.length != PUBLIC_KEY_LENGTH) {
          throw new Error(`Invalid public key input`);
        }
        this._bn = new BN(decoded);
      } else {
        this._bn = new BN(value);
      }
      if (this._bn.byteLength() > PUBLIC_KEY_LENGTH) {
        throw new Error(`Invalid public key input`);
      }
    }
  }
  /**
   * Returns a unique PublicKey for tests and benchmarks using a counter
   */
  static unique() {
    const key = new PublicKey(uniquePublicKeyCounter);
    uniquePublicKeyCounter += 1;
    return new PublicKey(key.toBuffer());
  }
  /**
   * Default public key value. The base58-encoded string representation is all ones (as seen below)
   * The underlying BN number is 32 bytes that are all zeros
   */
  /**
   * Checks if two publicKeys are equal
   */
  equals(publicKey2) {
    return this._bn.eq(publicKey2._bn);
  }
  /**
   * Return the base-58 representation of the public key
   */
  toBase58() {
    return bs58.encode(this.toBytes());
  }
  toJSON() {
    return this.toBase58();
  }
  /**
   * Return the byte array representation of the public key in big endian
   */
  toBytes() {
    const buf = this.toBuffer();
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  /**
   * Return the Buffer representation of the public key in big endian
   */
  toBuffer() {
    const b2 = this._bn.toArrayLike(bufferExports.Buffer);
    if (b2.length === PUBLIC_KEY_LENGTH) {
      return b2;
    }
    const zeroPad = bufferExports.Buffer.alloc(32);
    b2.copy(zeroPad, 32 - b2.length);
    return zeroPad;
  }
  get [Symbol.toStringTag]() {
    return `PublicKey(${this.toString()})`;
  }
  /**
   * Return the base-58 representation of the public key
   */
  toString() {
    return this.toBase58();
  }
  /**
   * Derive a public key from another key, a seed, and a program ID.
   * The program ID will also serve as the owner of the public key, giving
   * it permission to write data to the account.
   */
  /* eslint-disable require-await */
  static async createWithSeed(fromPublicKey, seed, programId) {
    const buffer2 = bufferExports.Buffer.concat([fromPublicKey.toBuffer(), bufferExports.Buffer.from(seed), programId.toBuffer()]);
    const publicKeyBytes = sha256(buffer2);
    return new PublicKey(publicKeyBytes);
  }
  /**
   * Derive a program address from seeds and a program ID.
   */
  /* eslint-disable require-await */
  static createProgramAddressSync(seeds, programId) {
    let buffer2 = bufferExports.Buffer.alloc(0);
    seeds.forEach(function(seed) {
      if (seed.length > MAX_SEED_LENGTH) {
        throw new TypeError(`Max seed length exceeded`);
      }
      buffer2 = bufferExports.Buffer.concat([buffer2, toBuffer(seed)]);
    });
    buffer2 = bufferExports.Buffer.concat([buffer2, programId.toBuffer(), bufferExports.Buffer.from("ProgramDerivedAddress")]);
    const publicKeyBytes = sha256(buffer2);
    if (isOnCurve(publicKeyBytes)) {
      throw new Error(`Invalid seeds, address must fall off the curve`);
    }
    return new PublicKey(publicKeyBytes);
  }
  /**
   * Async version of createProgramAddressSync
   * For backwards compatibility
   *
   * @deprecated Use {@link createProgramAddressSync} instead
   */
  /* eslint-disable require-await */
  static async createProgramAddress(seeds, programId) {
    return this.createProgramAddressSync(seeds, programId);
  }
  /**
   * Find a valid program address
   *
   * Valid program addresses must fall off the ed25519 curve.  This function
   * iterates a nonce until it finds one that when combined with the seeds
   * results in a valid program address.
   */
  static findProgramAddressSync(seeds, programId) {
    let nonce = 255;
    let address;
    while (nonce != 0) {
      try {
        const seedsWithNonce = seeds.concat(bufferExports.Buffer.from([nonce]));
        address = this.createProgramAddressSync(seedsWithNonce, programId);
      } catch (err) {
        if (err instanceof TypeError) {
          throw err;
        }
        nonce--;
        continue;
      }
      return [address, nonce];
    }
    throw new Error(`Unable to find a viable program address nonce`);
  }
  /**
   * Async version of findProgramAddressSync
   * For backwards compatibility
   *
   * @deprecated Use {@link findProgramAddressSync} instead
   */
  static async findProgramAddress(seeds, programId) {
    return this.findProgramAddressSync(seeds, programId);
  }
  /**
   * Check that a pubkey is on the ed25519 curve.
   */
  static isOnCurve(pubkeyData) {
    const pubkey = new PublicKey(pubkeyData);
    return isOnCurve(pubkey.toBytes());
  }
}
_PublicKey = PublicKey;
PublicKey.default = new _PublicKey("11111111111111111111111111111111");
SOLANA_SCHEMA.set(PublicKey, {
  kind: "struct",
  fields: [["_bn", "u256"]]
});
new PublicKey("BPFLoader1111111111111111111111111111111111");
const PACKET_DATA_SIZE = 1280 - 40 - 8;
const VERSION_PREFIX_MASK = 127;
const SIGNATURE_LENGTH_IN_BYTES = 64;
class TransactionExpiredBlockheightExceededError extends Error {
  constructor(signature2) {
    super(`Signature ${signature2} has expired: block height exceeded.`);
    this.signature = void 0;
    this.signature = signature2;
  }
}
Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype, "name", {
  value: "TransactionExpiredBlockheightExceededError"
});
class TransactionExpiredTimeoutError extends Error {
  constructor(signature2, timeoutSeconds) {
    super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${signature2} using the Solana Explorer or CLI tools.`);
    this.signature = void 0;
    this.signature = signature2;
  }
}
Object.defineProperty(TransactionExpiredTimeoutError.prototype, "name", {
  value: "TransactionExpiredTimeoutError"
});
class TransactionExpiredNonceInvalidError extends Error {
  constructor(signature2) {
    super(`Signature ${signature2} has expired: the nonce is no longer valid.`);
    this.signature = void 0;
    this.signature = signature2;
  }
}
Object.defineProperty(TransactionExpiredNonceInvalidError.prototype, "name", {
  value: "TransactionExpiredNonceInvalidError"
});
class MessageAccountKeys {
  constructor(staticAccountKeys, accountKeysFromLookups) {
    this.staticAccountKeys = void 0;
    this.accountKeysFromLookups = void 0;
    this.staticAccountKeys = staticAccountKeys;
    this.accountKeysFromLookups = accountKeysFromLookups;
  }
  keySegments() {
    const keySegments = [this.staticAccountKeys];
    if (this.accountKeysFromLookups) {
      keySegments.push(this.accountKeysFromLookups.writable);
      keySegments.push(this.accountKeysFromLookups.readonly);
    }
    return keySegments;
  }
  get(index) {
    for (const keySegment of this.keySegments()) {
      if (index < keySegment.length) {
        return keySegment[index];
      } else {
        index -= keySegment.length;
      }
    }
    return;
  }
  get length() {
    return this.keySegments().flat().length;
  }
  compileInstructions(instructions) {
    const U8_MAX = 255;
    if (this.length > U8_MAX + 1) {
      throw new Error("Account index overflow encountered during compilation");
    }
    const keyIndexMap = /* @__PURE__ */ new Map();
    this.keySegments().flat().forEach((key, index) => {
      keyIndexMap.set(key.toBase58(), index);
    });
    const findKeyIndex = (key) => {
      const keyIndex = keyIndexMap.get(key.toBase58());
      if (keyIndex === void 0) throw new Error("Encountered an unknown instruction account key during compilation");
      return keyIndex;
    };
    return instructions.map((instruction) => {
      return {
        programIdIndex: findKeyIndex(instruction.programId),
        accountKeyIndexes: instruction.keys.map((meta) => findKeyIndex(meta.pubkey)),
        data: instruction.data
      };
    });
  }
}
const publicKey = (property = "publicKey") => {
  return LayoutExports.blob(32, property);
};
const signature = (property = "signature") => {
  return LayoutExports.blob(64, property);
};
const rustString = (property = "string") => {
  const rsl = LayoutExports.struct([LayoutExports.u32("length"), LayoutExports.u32("lengthPadding"), LayoutExports.blob(LayoutExports.offset(LayoutExports.u32(), -8), "chars")], property);
  const _decode = rsl.decode.bind(rsl);
  const _encode = rsl.encode.bind(rsl);
  const rslShim = rsl;
  rslShim.decode = (b2, offset) => {
    const data = _decode(b2, offset);
    return data["chars"].toString();
  };
  rslShim.encode = (str, b2, offset) => {
    const data = {
      chars: bufferExports.Buffer.from(str, "utf8")
    };
    return _encode(data, b2, offset);
  };
  rslShim.alloc = (str) => {
    return LayoutExports.u32().span + LayoutExports.u32().span + bufferExports.Buffer.from(str, "utf8").length;
  };
  return rslShim;
};
const authorized = (property = "authorized") => {
  return LayoutExports.struct([publicKey("staker"), publicKey("withdrawer")], property);
};
const lockup = (property = "lockup") => {
  return LayoutExports.struct([LayoutExports.ns64("unixTimestamp"), LayoutExports.ns64("epoch"), publicKey("custodian")], property);
};
const voteInit = (property = "voteInit") => {
  return LayoutExports.struct([publicKey("nodePubkey"), publicKey("authorizedVoter"), publicKey("authorizedWithdrawer"), LayoutExports.u8("commission")], property);
};
const voteAuthorizeWithSeedArgs = (property = "voteAuthorizeWithSeedArgs") => {
  return LayoutExports.struct([LayoutExports.u32("voteAuthorizationType"), publicKey("currentAuthorityDerivedKeyOwnerPubkey"), rustString("currentAuthorityDerivedKeySeed"), publicKey("newAuthorized")], property);
};
function decodeLength(bytes) {
  let len = 0;
  let size = 0;
  for (; ; ) {
    let elem = bytes.shift();
    len |= (elem & 127) << size * 7;
    size += 1;
    if ((elem & 128) === 0) {
      break;
    }
  }
  return len;
}
function encodeLength(bytes, len) {
  let rem_len = len;
  for (; ; ) {
    let elem = rem_len & 127;
    rem_len >>= 7;
    if (rem_len == 0) {
      bytes.push(elem);
      break;
    } else {
      elem |= 128;
      bytes.push(elem);
    }
  }
}
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}
class CompiledKeys {
  constructor(payer, keyMetaMap) {
    this.payer = void 0;
    this.keyMetaMap = void 0;
    this.payer = payer;
    this.keyMetaMap = keyMetaMap;
  }
  static compile(instructions, payer) {
    const keyMetaMap = /* @__PURE__ */ new Map();
    const getOrInsertDefault = (pubkey) => {
      const address = pubkey.toBase58();
      let keyMeta = keyMetaMap.get(address);
      if (keyMeta === void 0) {
        keyMeta = {
          isSigner: false,
          isWritable: false,
          isInvoked: false
        };
        keyMetaMap.set(address, keyMeta);
      }
      return keyMeta;
    };
    const payerKeyMeta = getOrInsertDefault(payer);
    payerKeyMeta.isSigner = true;
    payerKeyMeta.isWritable = true;
    for (const ix of instructions) {
      getOrInsertDefault(ix.programId).isInvoked = true;
      for (const accountMeta of ix.keys) {
        const keyMeta = getOrInsertDefault(accountMeta.pubkey);
        keyMeta.isSigner || (keyMeta.isSigner = accountMeta.isSigner);
        keyMeta.isWritable || (keyMeta.isWritable = accountMeta.isWritable);
      }
    }
    return new CompiledKeys(payer, keyMetaMap);
  }
  getMessageComponents() {
    const mapEntries = [...this.keyMetaMap.entries()];
    assert(mapEntries.length <= 256, "Max static account keys length exceeded");
    const writableSigners = mapEntries.filter(([, meta]) => meta.isSigner && meta.isWritable);
    const readonlySigners = mapEntries.filter(([, meta]) => meta.isSigner && !meta.isWritable);
    const writableNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && meta.isWritable);
    const readonlyNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && !meta.isWritable);
    const header = {
      numRequiredSignatures: writableSigners.length + readonlySigners.length,
      numReadonlySignedAccounts: readonlySigners.length,
      numReadonlyUnsignedAccounts: readonlyNonSigners.length
    };
    {
      assert(writableSigners.length > 0, "Expected at least one writable signer key");
      const [payerAddress] = writableSigners[0];
      assert(payerAddress === this.payer.toBase58(), "Expected first writable signer key to be the fee payer");
    }
    const staticAccountKeys = [...writableSigners.map(([address]) => new PublicKey(address)), ...readonlySigners.map(([address]) => new PublicKey(address)), ...writableNonSigners.map(([address]) => new PublicKey(address)), ...readonlyNonSigners.map(([address]) => new PublicKey(address))];
    return [header, staticAccountKeys];
  }
  extractTableLookup(lookupTable) {
    const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);
    const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);
    if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {
      return;
    }
    return [{
      accountKey: lookupTable.key,
      writableIndexes,
      readonlyIndexes
    }, {
      writable: drainedWritableKeys,
      readonly: drainedReadonlyKeys
    }];
  }
  /** @internal */
  drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {
    const lookupTableIndexes = new Array();
    const drainedKeys = new Array();
    for (const [address, keyMeta] of this.keyMetaMap.entries()) {
      if (keyMetaFilter(keyMeta)) {
        const key = new PublicKey(address);
        const lookupTableIndex = lookupTableEntries.findIndex((entry) => entry.equals(key));
        if (lookupTableIndex >= 0) {
          assert(lookupTableIndex < 256, "Max lookup table index exceeded");
          lookupTableIndexes.push(lookupTableIndex);
          drainedKeys.push(key);
          this.keyMetaMap.delete(address);
        }
      }
    }
    return [lookupTableIndexes, drainedKeys];
  }
}
const END_OF_BUFFER_ERROR_MESSAGE = "Reached end of buffer unexpectedly";
function guardedShift(byteArray) {
  if (byteArray.length === 0) {
    throw new Error(END_OF_BUFFER_ERROR_MESSAGE);
  }
  return byteArray.shift();
}
function guardedSplice(byteArray, ...args) {
  const [start] = args;
  if (args.length === 2 ? start + (args[1] ?? 0) > byteArray.length : start >= byteArray.length) {
    throw new Error(END_OF_BUFFER_ERROR_MESSAGE);
  }
  return byteArray.splice(...args);
}
class Message {
  constructor(args) {
    this.header = void 0;
    this.accountKeys = void 0;
    this.recentBlockhash = void 0;
    this.instructions = void 0;
    this.indexToProgramIds = /* @__PURE__ */ new Map();
    this.header = args.header;
    this.accountKeys = args.accountKeys.map((account) => new PublicKey(account));
    this.recentBlockhash = args.recentBlockhash;
    this.instructions = args.instructions;
    this.instructions.forEach((ix) => this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));
  }
  get version() {
    return "legacy";
  }
  get staticAccountKeys() {
    return this.accountKeys;
  }
  get compiledInstructions() {
    return this.instructions.map((ix) => ({
      programIdIndex: ix.programIdIndex,
      accountKeyIndexes: ix.accounts,
      data: bs58.decode(ix.data)
    }));
  }
  get addressTableLookups() {
    return [];
  }
  getAccountKeys() {
    return new MessageAccountKeys(this.staticAccountKeys);
  }
  static compile(args) {
    const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
    const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
    const accountKeys = new MessageAccountKeys(staticAccountKeys);
    const instructions = accountKeys.compileInstructions(args.instructions).map((ix) => ({
      programIdIndex: ix.programIdIndex,
      accounts: ix.accountKeyIndexes,
      data: bs58.encode(ix.data)
    }));
    return new Message({
      header,
      accountKeys: staticAccountKeys,
      recentBlockhash: args.recentBlockhash,
      instructions
    });
  }
  isAccountSigner(index) {
    return index < this.header.numRequiredSignatures;
  }
  isAccountWritable(index) {
    const numSignedAccounts = this.header.numRequiredSignatures;
    if (index >= this.header.numRequiredSignatures) {
      const unsignedAccountIndex = index - numSignedAccounts;
      const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;
      const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
      return unsignedAccountIndex < numWritableUnsignedAccounts;
    } else {
      const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
      return index < numWritableSignedAccounts;
    }
  }
  isProgramId(index) {
    return this.indexToProgramIds.has(index);
  }
  programIds() {
    return [...this.indexToProgramIds.values()];
  }
  nonProgramIds() {
    return this.accountKeys.filter((_2, index) => !this.isProgramId(index));
  }
  serialize() {
    const numKeys = this.accountKeys.length;
    let keyCount = [];
    encodeLength(keyCount, numKeys);
    const instructions = this.instructions.map((instruction) => {
      const {
        accounts,
        programIdIndex
      } = instruction;
      const data = Array.from(bs58.decode(instruction.data));
      let keyIndicesCount = [];
      encodeLength(keyIndicesCount, accounts.length);
      let dataCount = [];
      encodeLength(dataCount, data.length);
      return {
        programIdIndex,
        keyIndicesCount: bufferExports.Buffer.from(keyIndicesCount),
        keyIndices: accounts,
        dataLength: bufferExports.Buffer.from(dataCount),
        data
      };
    });
    let instructionCount = [];
    encodeLength(instructionCount, instructions.length);
    let instructionBuffer = bufferExports.Buffer.alloc(PACKET_DATA_SIZE);
    bufferExports.Buffer.from(instructionCount).copy(instructionBuffer);
    let instructionBufferLength = instructionCount.length;
    instructions.forEach((instruction) => {
      const instructionLayout = LayoutExports.struct([LayoutExports.u8("programIdIndex"), LayoutExports.blob(instruction.keyIndicesCount.length, "keyIndicesCount"), LayoutExports.seq(LayoutExports.u8("keyIndex"), instruction.keyIndices.length, "keyIndices"), LayoutExports.blob(instruction.dataLength.length, "dataLength"), LayoutExports.seq(LayoutExports.u8("userdatum"), instruction.data.length, "data")]);
      const length2 = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);
      instructionBufferLength += length2;
    });
    instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);
    const signDataLayout = LayoutExports.struct([LayoutExports.blob(1, "numRequiredSignatures"), LayoutExports.blob(1, "numReadonlySignedAccounts"), LayoutExports.blob(1, "numReadonlyUnsignedAccounts"), LayoutExports.blob(keyCount.length, "keyCount"), LayoutExports.seq(publicKey("key"), numKeys, "keys"), publicKey("recentBlockhash")]);
    const transaction = {
      numRequiredSignatures: bufferExports.Buffer.from([this.header.numRequiredSignatures]),
      numReadonlySignedAccounts: bufferExports.Buffer.from([this.header.numReadonlySignedAccounts]),
      numReadonlyUnsignedAccounts: bufferExports.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
      keyCount: bufferExports.Buffer.from(keyCount),
      keys: this.accountKeys.map((key) => toBuffer(key.toBytes())),
      recentBlockhash: bs58.decode(this.recentBlockhash)
    };
    let signData = bufferExports.Buffer.alloc(2048);
    const length = signDataLayout.encode(transaction, signData);
    instructionBuffer.copy(signData, length);
    return signData.slice(0, length + instructionBuffer.length);
  }
  /**
   * Decode a compiled message into a Message object.
   */
  static from(buffer2) {
    let byteArray = [...buffer2];
    const numRequiredSignatures = guardedShift(byteArray);
    if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK)) {
      throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
    }
    const numReadonlySignedAccounts = guardedShift(byteArray);
    const numReadonlyUnsignedAccounts = guardedShift(byteArray);
    const accountCount = decodeLength(byteArray);
    let accountKeys = [];
    for (let i = 0; i < accountCount; i++) {
      const account = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);
      accountKeys.push(new PublicKey(bufferExports.Buffer.from(account)));
    }
    const recentBlockhash = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);
    const instructionCount = decodeLength(byteArray);
    let instructions = [];
    for (let i = 0; i < instructionCount; i++) {
      const programIdIndex = guardedShift(byteArray);
      const accountCount2 = decodeLength(byteArray);
      const accounts = guardedSplice(byteArray, 0, accountCount2);
      const dataLength = decodeLength(byteArray);
      const dataSlice = guardedSplice(byteArray, 0, dataLength);
      const data = bs58.encode(bufferExports.Buffer.from(dataSlice));
      instructions.push({
        programIdIndex,
        accounts,
        data
      });
    }
    const messageArgs = {
      header: {
        numRequiredSignatures,
        numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts
      },
      recentBlockhash: bs58.encode(bufferExports.Buffer.from(recentBlockhash)),
      accountKeys,
      instructions
    };
    return new Message(messageArgs);
  }
}
class MessageV0 {
  constructor(args) {
    this.header = void 0;
    this.staticAccountKeys = void 0;
    this.recentBlockhash = void 0;
    this.compiledInstructions = void 0;
    this.addressTableLookups = void 0;
    this.header = args.header;
    this.staticAccountKeys = args.staticAccountKeys;
    this.recentBlockhash = args.recentBlockhash;
    this.compiledInstructions = args.compiledInstructions;
    this.addressTableLookups = args.addressTableLookups;
  }
  get version() {
    return 0;
  }
  get numAccountKeysFromLookups() {
    let count = 0;
    for (const lookup of this.addressTableLookups) {
      count += lookup.readonlyIndexes.length + lookup.writableIndexes.length;
    }
    return count;
  }
  getAccountKeys(args) {
    let accountKeysFromLookups;
    if (args && "accountKeysFromLookups" in args && args.accountKeysFromLookups) {
      if (this.numAccountKeysFromLookups != args.accountKeysFromLookups.writable.length + args.accountKeysFromLookups.readonly.length) {
        throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");
      }
      accountKeysFromLookups = args.accountKeysFromLookups;
    } else if (args && "addressLookupTableAccounts" in args && args.addressLookupTableAccounts) {
      accountKeysFromLookups = this.resolveAddressTableLookups(args.addressLookupTableAccounts);
    } else if (this.addressTableLookups.length > 0) {
      throw new Error("Failed to get account keys because address table lookups were not resolved");
    }
    return new MessageAccountKeys(this.staticAccountKeys, accountKeysFromLookups);
  }
  isAccountSigner(index) {
    return index < this.header.numRequiredSignatures;
  }
  isAccountWritable(index) {
    const numSignedAccounts = this.header.numRequiredSignatures;
    const numStaticAccountKeys = this.staticAccountKeys.length;
    if (index >= numStaticAccountKeys) {
      const lookupAccountKeysIndex = index - numStaticAccountKeys;
      const numWritableLookupAccountKeys = this.addressTableLookups.reduce((count, lookup) => count + lookup.writableIndexes.length, 0);
      return lookupAccountKeysIndex < numWritableLookupAccountKeys;
    } else if (index >= this.header.numRequiredSignatures) {
      const unsignedAccountIndex = index - numSignedAccounts;
      const numUnsignedAccounts = numStaticAccountKeys - numSignedAccounts;
      const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
      return unsignedAccountIndex < numWritableUnsignedAccounts;
    } else {
      const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
      return index < numWritableSignedAccounts;
    }
  }
  resolveAddressTableLookups(addressLookupTableAccounts) {
    const accountKeysFromLookups = {
      writable: [],
      readonly: []
    };
    for (const tableLookup of this.addressTableLookups) {
      const tableAccount = addressLookupTableAccounts.find((account) => account.key.equals(tableLookup.accountKey));
      if (!tableAccount) {
        throw new Error(`Failed to find address lookup table account for table key ${tableLookup.accountKey.toBase58()}`);
      }
      for (const index of tableLookup.writableIndexes) {
        if (index < tableAccount.state.addresses.length) {
          accountKeysFromLookups.writable.push(tableAccount.state.addresses[index]);
        } else {
          throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);
        }
      }
      for (const index of tableLookup.readonlyIndexes) {
        if (index < tableAccount.state.addresses.length) {
          accountKeysFromLookups.readonly.push(tableAccount.state.addresses[index]);
        } else {
          throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);
        }
      }
    }
    return accountKeysFromLookups;
  }
  static compile(args) {
    const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
    const addressTableLookups = new Array();
    const accountKeysFromLookups = {
      writable: new Array(),
      readonly: new Array()
    };
    const lookupTableAccounts = args.addressLookupTableAccounts || [];
    for (const lookupTable of lookupTableAccounts) {
      const extractResult = compiledKeys.extractTableLookup(lookupTable);
      if (extractResult !== void 0) {
        const [addressTableLookup, {
          writable,
          readonly
        }] = extractResult;
        addressTableLookups.push(addressTableLookup);
        accountKeysFromLookups.writable.push(...writable);
        accountKeysFromLookups.readonly.push(...readonly);
      }
    }
    const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
    const accountKeys = new MessageAccountKeys(staticAccountKeys, accountKeysFromLookups);
    const compiledInstructions = accountKeys.compileInstructions(args.instructions);
    return new MessageV0({
      header,
      staticAccountKeys,
      recentBlockhash: args.recentBlockhash,
      compiledInstructions,
      addressTableLookups
    });
  }
  serialize() {
    const encodedStaticAccountKeysLength = Array();
    encodeLength(encodedStaticAccountKeysLength, this.staticAccountKeys.length);
    const serializedInstructions = this.serializeInstructions();
    const encodedInstructionsLength = Array();
    encodeLength(encodedInstructionsLength, this.compiledInstructions.length);
    const serializedAddressTableLookups = this.serializeAddressTableLookups();
    const encodedAddressTableLookupsLength = Array();
    encodeLength(encodedAddressTableLookupsLength, this.addressTableLookups.length);
    const messageLayout = LayoutExports.struct([LayoutExports.u8("prefix"), LayoutExports.struct([LayoutExports.u8("numRequiredSignatures"), LayoutExports.u8("numReadonlySignedAccounts"), LayoutExports.u8("numReadonlyUnsignedAccounts")], "header"), LayoutExports.blob(encodedStaticAccountKeysLength.length, "staticAccountKeysLength"), LayoutExports.seq(publicKey(), this.staticAccountKeys.length, "staticAccountKeys"), publicKey("recentBlockhash"), LayoutExports.blob(encodedInstructionsLength.length, "instructionsLength"), LayoutExports.blob(serializedInstructions.length, "serializedInstructions"), LayoutExports.blob(encodedAddressTableLookupsLength.length, "addressTableLookupsLength"), LayoutExports.blob(serializedAddressTableLookups.length, "serializedAddressTableLookups")]);
    const serializedMessage = new Uint8Array(PACKET_DATA_SIZE);
    const MESSAGE_VERSION_0_PREFIX = 1 << 7;
    const serializedMessageLength = messageLayout.encode({
      prefix: MESSAGE_VERSION_0_PREFIX,
      header: this.header,
      staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),
      staticAccountKeys: this.staticAccountKeys.map((key) => key.toBytes()),
      recentBlockhash: bs58.decode(this.recentBlockhash),
      instructionsLength: new Uint8Array(encodedInstructionsLength),
      serializedInstructions,
      addressTableLookupsLength: new Uint8Array(encodedAddressTableLookupsLength),
      serializedAddressTableLookups
    }, serializedMessage);
    return serializedMessage.slice(0, serializedMessageLength);
  }
  serializeInstructions() {
    let serializedLength = 0;
    const serializedInstructions = new Uint8Array(PACKET_DATA_SIZE);
    for (const instruction of this.compiledInstructions) {
      const encodedAccountKeyIndexesLength = Array();
      encodeLength(encodedAccountKeyIndexesLength, instruction.accountKeyIndexes.length);
      const encodedDataLength = Array();
      encodeLength(encodedDataLength, instruction.data.length);
      const instructionLayout = LayoutExports.struct([LayoutExports.u8("programIdIndex"), LayoutExports.blob(encodedAccountKeyIndexesLength.length, "encodedAccountKeyIndexesLength"), LayoutExports.seq(LayoutExports.u8(), instruction.accountKeyIndexes.length, "accountKeyIndexes"), LayoutExports.blob(encodedDataLength.length, "encodedDataLength"), LayoutExports.blob(instruction.data.length, "data")]);
      serializedLength += instructionLayout.encode({
        programIdIndex: instruction.programIdIndex,
        encodedAccountKeyIndexesLength: new Uint8Array(encodedAccountKeyIndexesLength),
        accountKeyIndexes: instruction.accountKeyIndexes,
        encodedDataLength: new Uint8Array(encodedDataLength),
        data: instruction.data
      }, serializedInstructions, serializedLength);
    }
    return serializedInstructions.slice(0, serializedLength);
  }
  serializeAddressTableLookups() {
    let serializedLength = 0;
    const serializedAddressTableLookups = new Uint8Array(PACKET_DATA_SIZE);
    for (const lookup of this.addressTableLookups) {
      const encodedWritableIndexesLength = Array();
      encodeLength(encodedWritableIndexesLength, lookup.writableIndexes.length);
      const encodedReadonlyIndexesLength = Array();
      encodeLength(encodedReadonlyIndexesLength, lookup.readonlyIndexes.length);
      const addressTableLookupLayout = LayoutExports.struct([publicKey("accountKey"), LayoutExports.blob(encodedWritableIndexesLength.length, "encodedWritableIndexesLength"), LayoutExports.seq(LayoutExports.u8(), lookup.writableIndexes.length, "writableIndexes"), LayoutExports.blob(encodedReadonlyIndexesLength.length, "encodedReadonlyIndexesLength"), LayoutExports.seq(LayoutExports.u8(), lookup.readonlyIndexes.length, "readonlyIndexes")]);
      serializedLength += addressTableLookupLayout.encode({
        accountKey: lookup.accountKey.toBytes(),
        encodedWritableIndexesLength: new Uint8Array(encodedWritableIndexesLength),
        writableIndexes: lookup.writableIndexes,
        encodedReadonlyIndexesLength: new Uint8Array(encodedReadonlyIndexesLength),
        readonlyIndexes: lookup.readonlyIndexes
      }, serializedAddressTableLookups, serializedLength);
    }
    return serializedAddressTableLookups.slice(0, serializedLength);
  }
  static deserialize(serializedMessage) {
    let byteArray = [...serializedMessage];
    const prefix = guardedShift(byteArray);
    const maskedPrefix = prefix & VERSION_PREFIX_MASK;
    assert(prefix !== maskedPrefix, `Expected versioned message but received legacy message`);
    const version2 = maskedPrefix;
    assert(version2 === 0, `Expected versioned message with version 0 but found version ${version2}`);
    const header = {
      numRequiredSignatures: guardedShift(byteArray),
      numReadonlySignedAccounts: guardedShift(byteArray),
      numReadonlyUnsignedAccounts: guardedShift(byteArray)
    };
    const staticAccountKeys = [];
    const staticAccountKeysLength = decodeLength(byteArray);
    for (let i = 0; i < staticAccountKeysLength; i++) {
      staticAccountKeys.push(new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH)));
    }
    const recentBlockhash = bs58.encode(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));
    const instructionCount = decodeLength(byteArray);
    const compiledInstructions = [];
    for (let i = 0; i < instructionCount; i++) {
      const programIdIndex = guardedShift(byteArray);
      const accountKeyIndexesLength = decodeLength(byteArray);
      const accountKeyIndexes = guardedSplice(byteArray, 0, accountKeyIndexesLength);
      const dataLength = decodeLength(byteArray);
      const data = new Uint8Array(guardedSplice(byteArray, 0, dataLength));
      compiledInstructions.push({
        programIdIndex,
        accountKeyIndexes,
        data
      });
    }
    const addressTableLookupsCount = decodeLength(byteArray);
    const addressTableLookups = [];
    for (let i = 0; i < addressTableLookupsCount; i++) {
      const accountKey = new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));
      const writableIndexesLength = decodeLength(byteArray);
      const writableIndexes = guardedSplice(byteArray, 0, writableIndexesLength);
      const readonlyIndexesLength = decodeLength(byteArray);
      const readonlyIndexes = guardedSplice(byteArray, 0, readonlyIndexesLength);
      addressTableLookups.push({
        accountKey,
        writableIndexes,
        readonlyIndexes
      });
    }
    return new MessageV0({
      header,
      staticAccountKeys,
      recentBlockhash,
      compiledInstructions,
      addressTableLookups
    });
  }
}
const VersionedMessage = {
  deserializeMessageVersion(serializedMessage) {
    const prefix = serializedMessage[0];
    const maskedPrefix = prefix & VERSION_PREFIX_MASK;
    if (maskedPrefix === prefix) {
      return "legacy";
    }
    return maskedPrefix;
  },
  deserialize: (serializedMessage) => {
    const version2 = VersionedMessage.deserializeMessageVersion(serializedMessage);
    if (version2 === "legacy") {
      return Message.from(serializedMessage);
    }
    if (version2 === 0) {
      return MessageV0.deserialize(serializedMessage);
    } else {
      throw new Error(`Transaction message version ${version2} deserialization is not supported`);
    }
  }
};
let TransactionStatus = /* @__PURE__ */ function(TransactionStatus2) {
  TransactionStatus2[TransactionStatus2["BLOCKHEIGHT_EXCEEDED"] = 0] = "BLOCKHEIGHT_EXCEEDED";
  TransactionStatus2[TransactionStatus2["PROCESSED"] = 1] = "PROCESSED";
  TransactionStatus2[TransactionStatus2["TIMED_OUT"] = 2] = "TIMED_OUT";
  TransactionStatus2[TransactionStatus2["NONCE_INVALID"] = 3] = "NONCE_INVALID";
  return TransactionStatus2;
}({});
const DEFAULT_SIGNATURE = bufferExports.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);
class TransactionInstruction {
  constructor(opts) {
    this.keys = void 0;
    this.programId = void 0;
    this.data = bufferExports.Buffer.alloc(0);
    this.programId = opts.programId;
    this.keys = opts.keys;
    if (opts.data) {
      this.data = opts.data;
    }
  }
  /**
   * @internal
   */
  toJSON() {
    return {
      keys: this.keys.map(({
        pubkey,
        isSigner,
        isWritable
      }) => ({
        pubkey: pubkey.toJSON(),
        isSigner,
        isWritable
      })),
      programId: this.programId.toJSON(),
      data: [...this.data]
    };
  }
}
class Transaction {
  /**
   * The first (payer) Transaction signature
   *
   * @returns {Buffer | null} Buffer of payer's signature
   */
  get signature() {
    if (this.signatures.length > 0) {
      return this.signatures[0].signature;
    }
    return null;
  }
  /**
   * The transaction fee payer
   */
  // Construct a transaction with a blockhash and lastValidBlockHeight
  // Construct a transaction using a durable nonce
  /**
   * @deprecated `TransactionCtorFields` has been deprecated and will be removed in a future version.
   * Please supply a `TransactionBlockhashCtor` instead.
   */
  /**
   * Construct an empty Transaction
   */
  constructor(opts) {
    this.signatures = [];
    this.feePayer = void 0;
    this.instructions = [];
    this.recentBlockhash = void 0;
    this.lastValidBlockHeight = void 0;
    this.nonceInfo = void 0;
    this.minNonceContextSlot = void 0;
    this._message = void 0;
    this._json = void 0;
    if (!opts) {
      return;
    }
    if (opts.feePayer) {
      this.feePayer = opts.feePayer;
    }
    if (opts.signatures) {
      this.signatures = opts.signatures;
    }
    if (Object.prototype.hasOwnProperty.call(opts, "nonceInfo")) {
      const {
        minContextSlot,
        nonceInfo
      } = opts;
      this.minNonceContextSlot = minContextSlot;
      this.nonceInfo = nonceInfo;
    } else if (Object.prototype.hasOwnProperty.call(opts, "lastValidBlockHeight")) {
      const {
        blockhash,
        lastValidBlockHeight
      } = opts;
      this.recentBlockhash = blockhash;
      this.lastValidBlockHeight = lastValidBlockHeight;
    } else {
      const {
        recentBlockhash,
        nonceInfo
      } = opts;
      if (nonceInfo) {
        this.nonceInfo = nonceInfo;
      }
      this.recentBlockhash = recentBlockhash;
    }
  }
  /**
   * @internal
   */
  toJSON() {
    return {
      recentBlockhash: this.recentBlockhash || null,
      feePayer: this.feePayer ? this.feePayer.toJSON() : null,
      nonceInfo: this.nonceInfo ? {
        nonce: this.nonceInfo.nonce,
        nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
      } : null,
      instructions: this.instructions.map((instruction) => instruction.toJSON()),
      signers: this.signatures.map(({
        publicKey: publicKey2
      }) => {
        return publicKey2.toJSON();
      })
    };
  }
  /**
   * Add one or more instructions to this Transaction
   *
   * @param {Array< Transaction | TransactionInstruction | TransactionInstructionCtorFields >} items - Instructions to add to the Transaction
   */
  add(...items) {
    if (items.length === 0) {
      throw new Error("No instructions");
    }
    items.forEach((item) => {
      if ("instructions" in item) {
        this.instructions = this.instructions.concat(item.instructions);
      } else if ("data" in item && "programId" in item && "keys" in item) {
        this.instructions.push(item);
      } else {
        this.instructions.push(new TransactionInstruction(item));
      }
    });
    return this;
  }
  /**
   * Compile transaction data
   */
  compileMessage() {
    if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {
      return this._message;
    }
    let recentBlockhash;
    let instructions;
    if (this.nonceInfo) {
      recentBlockhash = this.nonceInfo.nonce;
      if (this.instructions[0] != this.nonceInfo.nonceInstruction) {
        instructions = [this.nonceInfo.nonceInstruction, ...this.instructions];
      } else {
        instructions = this.instructions;
      }
    } else {
      recentBlockhash = this.recentBlockhash;
      instructions = this.instructions;
    }
    if (!recentBlockhash) {
      throw new Error("Transaction recentBlockhash required");
    }
    if (instructions.length < 1) {
      console.warn("No instructions provided");
    }
    let feePayer;
    if (this.feePayer) {
      feePayer = this.feePayer;
    } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {
      feePayer = this.signatures[0].publicKey;
    } else {
      throw new Error("Transaction fee payer required");
    }
    for (let i = 0; i < instructions.length; i++) {
      if (instructions[i].programId === void 0) {
        throw new Error(`Transaction instruction index ${i} has undefined program id`);
      }
    }
    const programIds = [];
    const accountMetas = [];
    instructions.forEach((instruction) => {
      instruction.keys.forEach((accountMeta) => {
        accountMetas.push({
          ...accountMeta
        });
      });
      const programId = instruction.programId.toString();
      if (!programIds.includes(programId)) {
        programIds.push(programId);
      }
    });
    programIds.forEach((programId) => {
      accountMetas.push({
        pubkey: new PublicKey(programId),
        isSigner: false,
        isWritable: false
      });
    });
    const uniqueMetas = [];
    accountMetas.forEach((accountMeta) => {
      const pubkeyString = accountMeta.pubkey.toString();
      const uniqueIndex = uniqueMetas.findIndex((x2) => {
        return x2.pubkey.toString() === pubkeyString;
      });
      if (uniqueIndex > -1) {
        uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;
        uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;
      } else {
        uniqueMetas.push(accountMeta);
      }
    });
    uniqueMetas.sort(function(x2, y) {
      if (x2.isSigner !== y.isSigner) {
        return x2.isSigner ? -1 : 1;
      }
      if (x2.isWritable !== y.isWritable) {
        return x2.isWritable ? -1 : 1;
      }
      const options = {
        localeMatcher: "best fit",
        usage: "sort",
        sensitivity: "variant",
        ignorePunctuation: false,
        numeric: false,
        caseFirst: "lower"
      };
      return x2.pubkey.toBase58().localeCompare(y.pubkey.toBase58(), "en", options);
    });
    const feePayerIndex = uniqueMetas.findIndex((x2) => {
      return x2.pubkey.equals(feePayer);
    });
    if (feePayerIndex > -1) {
      const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);
      payerMeta.isSigner = true;
      payerMeta.isWritable = true;
      uniqueMetas.unshift(payerMeta);
    } else {
      uniqueMetas.unshift({
        pubkey: feePayer,
        isSigner: true,
        isWritable: true
      });
    }
    for (const signature2 of this.signatures) {
      const uniqueIndex = uniqueMetas.findIndex((x2) => {
        return x2.pubkey.equals(signature2.publicKey);
      });
      if (uniqueIndex > -1) {
        if (!uniqueMetas[uniqueIndex].isSigner) {
          uniqueMetas[uniqueIndex].isSigner = true;
          console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release.");
        }
      } else {
        throw new Error(`unknown signer: ${signature2.publicKey.toString()}`);
      }
    }
    let numRequiredSignatures = 0;
    let numReadonlySignedAccounts = 0;
    let numReadonlyUnsignedAccounts = 0;
    const signedKeys = [];
    const unsignedKeys = [];
    uniqueMetas.forEach(({
      pubkey,
      isSigner,
      isWritable
    }) => {
      if (isSigner) {
        signedKeys.push(pubkey.toString());
        numRequiredSignatures += 1;
        if (!isWritable) {
          numReadonlySignedAccounts += 1;
        }
      } else {
        unsignedKeys.push(pubkey.toString());
        if (!isWritable) {
          numReadonlyUnsignedAccounts += 1;
        }
      }
    });
    const accountKeys = signedKeys.concat(unsignedKeys);
    const compiledInstructions = instructions.map((instruction) => {
      const {
        data,
        programId
      } = instruction;
      return {
        programIdIndex: accountKeys.indexOf(programId.toString()),
        accounts: instruction.keys.map((meta) => accountKeys.indexOf(meta.pubkey.toString())),
        data: bs58.encode(data)
      };
    });
    compiledInstructions.forEach((instruction) => {
      assert(instruction.programIdIndex >= 0);
      instruction.accounts.forEach((keyIndex) => assert(keyIndex >= 0));
    });
    return new Message({
      header: {
        numRequiredSignatures,
        numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts
      },
      accountKeys,
      recentBlockhash,
      instructions: compiledInstructions
    });
  }
  /**
   * @internal
   */
  _compile() {
    const message = this.compileMessage();
    const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);
    if (this.signatures.length === signedKeys.length) {
      const valid = this.signatures.every((pair, index) => {
        return signedKeys[index].equals(pair.publicKey);
      });
      if (valid) return message;
    }
    this.signatures = signedKeys.map((publicKey2) => ({
      signature: null,
      publicKey: publicKey2
    }));
    return message;
  }
  /**
   * Get a buffer of the Transaction data that need to be covered by signatures
   */
  serializeMessage() {
    return this._compile().serialize();
  }
  /**
   * Get the estimated fee associated with a transaction
   *
   * @param {Connection} connection Connection to RPC Endpoint.
   *
   * @returns {Promise<number | null>} The estimated fee for the transaction
   */
  async getEstimatedFee(connection) {
    return (await connection.getFeeForMessage(this.compileMessage())).value;
  }
  /**
   * Specify the public keys which will be used to sign the Transaction.
   * The first signer will be used as the transaction fee payer account.
   *
   * Signatures can be added with either `partialSign` or `addSignature`
   *
   * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be
   * specified and it can be set in the Transaction constructor or with the
   * `feePayer` property.
   */
  setSigners(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = /* @__PURE__ */ new Set();
    this.signatures = signers.filter((publicKey2) => {
      const key = publicKey2.toString();
      if (seen.has(key)) {
        return false;
      } else {
        seen.add(key);
        return true;
      }
    }).map((publicKey2) => ({
      signature: null,
      publicKey: publicKey2
    }));
  }
  /**
   * Sign the Transaction with the specified signers. Multiple signatures may
   * be applied to a Transaction. The first signature is considered "primary"
   * and is used identify and confirm transactions.
   *
   * If the Transaction `feePayer` is not set, the first signer will be used
   * as the transaction fee payer account.
   *
   * Transaction fields should not be modified after the first call to `sign`,
   * as doing so may invalidate the signature and cause the Transaction to be
   * rejected.
   *
   * The Transaction must be assigned a valid `recentBlockhash` before invoking this method
   *
   * @param {Array<Signer>} signers Array of signers that will sign the transaction
   */
  sign(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = /* @__PURE__ */ new Set();
    const uniqueSigners = [];
    for (const signer of signers) {
      const key = signer.publicKey.toString();
      if (seen.has(key)) {
        continue;
      } else {
        seen.add(key);
        uniqueSigners.push(signer);
      }
    }
    this.signatures = uniqueSigners.map((signer) => ({
      signature: null,
      publicKey: signer.publicKey
    }));
    const message = this._compile();
    this._partialSign(message, ...uniqueSigners);
  }
  /**
   * Partially sign a transaction with the specified accounts. All accounts must
   * correspond to either the fee payer or a signer account in the transaction
   * instructions.
   *
   * All the caveats from the `sign` method apply to `partialSign`
   *
   * @param {Array<Signer>} signers Array of signers that will sign the transaction
   */
  partialSign(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = /* @__PURE__ */ new Set();
    const uniqueSigners = [];
    for (const signer of signers) {
      const key = signer.publicKey.toString();
      if (seen.has(key)) {
        continue;
      } else {
        seen.add(key);
        uniqueSigners.push(signer);
      }
    }
    const message = this._compile();
    this._partialSign(message, ...uniqueSigners);
  }
  /**
   * @internal
   */
  _partialSign(message, ...signers) {
    const signData = message.serialize();
    signers.forEach((signer) => {
      const signature2 = sign(signData, signer.secretKey);
      this._addSignature(signer.publicKey, toBuffer(signature2));
    });
  }
  /**
   * Add an externally created signature to a transaction. The public key
   * must correspond to either the fee payer or a signer account in the transaction
   * instructions.
   *
   * @param {PublicKey} pubkey Public key that will be added to the transaction.
   * @param {Buffer} signature An externally created signature to add to the transaction.
   */
  addSignature(pubkey, signature2) {
    this._compile();
    this._addSignature(pubkey, signature2);
  }
  /**
   * @internal
   */
  _addSignature(pubkey, signature2) {
    assert(signature2.length === 64);
    const index = this.signatures.findIndex((sigpair) => pubkey.equals(sigpair.publicKey));
    if (index < 0) {
      throw new Error(`unknown signer: ${pubkey.toString()}`);
    }
    this.signatures[index].signature = bufferExports.Buffer.from(signature2);
  }
  /**
   * Verify signatures of a Transaction
   * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.
   * If no boolean is provided, we expect a fully signed Transaction by default.
   *
   * @param {boolean} [requireAllSignatures=true] Require a fully signed Transaction
   */
  verifySignatures(requireAllSignatures = true) {
    const signatureErrors = this._getMessageSignednessErrors(this.serializeMessage(), requireAllSignatures);
    return !signatureErrors;
  }
  /**
   * @internal
   */
  _getMessageSignednessErrors(message, requireAllSignatures) {
    const errors = {};
    for (const {
      signature: signature2,
      publicKey: publicKey2
    } of this.signatures) {
      if (signature2 === null) {
        if (requireAllSignatures) {
          (errors.missing || (errors.missing = [])).push(publicKey2);
        }
      } else {
        if (!verify(signature2, message, publicKey2.toBytes())) {
          (errors.invalid || (errors.invalid = [])).push(publicKey2);
        }
      }
    }
    return errors.invalid || errors.missing ? errors : void 0;
  }
  /**
   * Serialize the Transaction in the wire format.
   *
   * @param {Buffer} [config] Config of transaction.
   *
   * @returns {Buffer} Signature of transaction in wire format.
   */
  serialize(config) {
    const {
      requireAllSignatures,
      verifySignatures
    } = Object.assign({
      requireAllSignatures: true,
      verifySignatures: true
    }, config);
    const signData = this.serializeMessage();
    if (verifySignatures) {
      const sigErrors = this._getMessageSignednessErrors(signData, requireAllSignatures);
      if (sigErrors) {
        let errorMessage = "Signature verification failed.";
        if (sigErrors.invalid) {
          errorMessage += `
Invalid signature for public key${sigErrors.invalid.length === 1 ? "" : "(s)"} [\`${sigErrors.invalid.map((p) => p.toBase58()).join("`, `")}\`].`;
        }
        if (sigErrors.missing) {
          errorMessage += `
Missing signature for public key${sigErrors.missing.length === 1 ? "" : "(s)"} [\`${sigErrors.missing.map((p) => p.toBase58()).join("`, `")}\`].`;
        }
        throw new Error(errorMessage);
      }
    }
    return this._serialize(signData);
  }
  /**
   * @internal
   */
  _serialize(signData) {
    const {
      signatures
    } = this;
    const signatureCount = [];
    encodeLength(signatureCount, signatures.length);
    const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;
    const wireTransaction = bufferExports.Buffer.alloc(transactionLength);
    assert(signatures.length < 256);
    bufferExports.Buffer.from(signatureCount).copy(wireTransaction, 0);
    signatures.forEach(({
      signature: signature2
    }, index) => {
      if (signature2 !== null) {
        assert(signature2.length === 64, `signature has invalid length`);
        bufferExports.Buffer.from(signature2).copy(wireTransaction, signatureCount.length + index * 64);
      }
    });
    signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);
    assert(wireTransaction.length <= PACKET_DATA_SIZE, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`);
    return wireTransaction;
  }
  /**
   * Deprecated method
   * @internal
   */
  get keys() {
    assert(this.instructions.length === 1);
    return this.instructions[0].keys.map((keyObj) => keyObj.pubkey);
  }
  /**
   * Deprecated method
   * @internal
   */
  get programId() {
    assert(this.instructions.length === 1);
    return this.instructions[0].programId;
  }
  /**
   * Deprecated method
   * @internal
   */
  get data() {
    assert(this.instructions.length === 1);
    return this.instructions[0].data;
  }
  /**
   * Parse a wire transaction into a Transaction object.
   *
   * @param {Buffer | Uint8Array | Array<number>} buffer Signature of wire Transaction
   *
   * @returns {Transaction} Transaction associated with the signature
   */
  static from(buffer2) {
    let byteArray = [...buffer2];
    const signatureCount = decodeLength(byteArray);
    let signatures = [];
    for (let i = 0; i < signatureCount; i++) {
      const signature2 = guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES);
      signatures.push(bs58.encode(bufferExports.Buffer.from(signature2)));
    }
    return Transaction.populate(Message.from(byteArray), signatures);
  }
  /**
   * Populate Transaction object from message and signatures
   *
   * @param {Message} message Message of transaction
   * @param {Array<string>} signatures List of signatures to assign to the transaction
   *
   * @returns {Transaction} The populated Transaction
   */
  static populate(message, signatures = []) {
    const transaction = new Transaction();
    transaction.recentBlockhash = message.recentBlockhash;
    if (message.header.numRequiredSignatures > 0) {
      transaction.feePayer = message.accountKeys[0];
    }
    signatures.forEach((signature2, index) => {
      const sigPubkeyPair = {
        signature: signature2 == bs58.encode(DEFAULT_SIGNATURE) ? null : bs58.decode(signature2),
        publicKey: message.accountKeys[index]
      };
      transaction.signatures.push(sigPubkeyPair);
    });
    message.instructions.forEach((instruction) => {
      const keys2 = instruction.accounts.map((account) => {
        const pubkey = message.accountKeys[account];
        return {
          pubkey,
          isSigner: transaction.signatures.some((keyObj) => keyObj.publicKey.toString() === pubkey.toString()) || message.isAccountSigner(account),
          isWritable: message.isAccountWritable(account)
        };
      });
      transaction.instructions.push(new TransactionInstruction({
        keys: keys2,
        programId: message.accountKeys[instruction.programIdIndex],
        data: bs58.decode(instruction.data)
      }));
    });
    transaction._message = message;
    transaction._json = transaction.toJSON();
    return transaction;
  }
}
class VersionedTransaction {
  get version() {
    return this.message.version;
  }
  constructor(message, signatures) {
    this.signatures = void 0;
    this.message = void 0;
    if (signatures !== void 0) {
      assert(signatures.length === message.header.numRequiredSignatures, "Expected signatures length to be equal to the number of required signatures");
      this.signatures = signatures;
    } else {
      const defaultSignatures = [];
      for (let i = 0; i < message.header.numRequiredSignatures; i++) {
        defaultSignatures.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));
      }
      this.signatures = defaultSignatures;
    }
    this.message = message;
  }
  serialize() {
    const serializedMessage = this.message.serialize();
    const encodedSignaturesLength = Array();
    encodeLength(encodedSignaturesLength, this.signatures.length);
    const transactionLayout = LayoutExports.struct([LayoutExports.blob(encodedSignaturesLength.length, "encodedSignaturesLength"), LayoutExports.seq(signature(), this.signatures.length, "signatures"), LayoutExports.blob(serializedMessage.length, "serializedMessage")]);
    const serializedTransaction = new Uint8Array(2048);
    const serializedTransactionLength = transactionLayout.encode({
      encodedSignaturesLength: new Uint8Array(encodedSignaturesLength),
      signatures: this.signatures,
      serializedMessage
    }, serializedTransaction);
    return serializedTransaction.slice(0, serializedTransactionLength);
  }
  static deserialize(serializedTransaction) {
    let byteArray = [...serializedTransaction];
    const signatures = [];
    const signaturesLength = decodeLength(byteArray);
    for (let i = 0; i < signaturesLength; i++) {
      signatures.push(new Uint8Array(guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES)));
    }
    const message = VersionedMessage.deserialize(new Uint8Array(byteArray));
    return new VersionedTransaction(message, signatures);
  }
  sign(signers) {
    const messageData = this.message.serialize();
    const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
    for (const signer of signers) {
      const signerIndex = signerPubkeys.findIndex((pubkey) => pubkey.equals(signer.publicKey));
      assert(signerIndex >= 0, `Cannot sign with non signer key ${signer.publicKey.toBase58()}`);
      this.signatures[signerIndex] = sign(messageData, signer.secretKey);
    }
  }
  addSignature(publicKey2, signature2) {
    assert(signature2.byteLength === 64, "Signature must be 64 bytes long");
    const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
    const signerIndex = signerPubkeys.findIndex((pubkey) => pubkey.equals(publicKey2));
    assert(signerIndex >= 0, `Can not add signature; \`${publicKey2.toBase58()}\` is not required to sign this transaction`);
    this.signatures[signerIndex] = signature2;
  }
}
const NUM_TICKS_PER_SECOND = 160;
const DEFAULT_TICKS_PER_SLOT = 64;
const NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;
const MS_PER_SLOT = 1e3 / NUM_SLOTS_PER_SECOND;
new PublicKey("SysvarC1ock11111111111111111111111111111111");
new PublicKey("SysvarEpochSchedu1e111111111111111111111111");
new PublicKey("Sysvar1nstructions1111111111111111111111111");
new PublicKey("SysvarRecentB1ockHashes11111111111111111111");
new PublicKey("SysvarRent111111111111111111111111111111111");
new PublicKey("SysvarRewards111111111111111111111111111111");
new PublicKey("SysvarS1otHashes111111111111111111111111111");
new PublicKey("SysvarS1otHistory11111111111111111111111111");
new PublicKey("SysvarStakeHistory1111111111111111111111111");
class SendTransactionError extends Error {
  constructor({
    action,
    signature: signature2,
    transactionMessage,
    logs
  }) {
    const maybeLogsOutput = logs ? `Logs: 
${JSON.stringify(logs.slice(-10), null, 2)}. ` : "";
    const guideText = "\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";
    let message;
    switch (action) {
      case "send":
        message = `Transaction ${signature2} resulted in an error. 
${transactionMessage}. ` + maybeLogsOutput + guideText;
        break;
      case "simulate":
        message = `Simulation failed. 
Message: ${transactionMessage}. 
` + maybeLogsOutput + guideText;
        break;
      default: {
        message = `Unknown action '${/* @__PURE__ */ ((a) => a)(action)}'`;
      }
    }
    super(message);
    this.signature = void 0;
    this.transactionMessage = void 0;
    this.transactionLogs = void 0;
    this.signature = signature2;
    this.transactionMessage = transactionMessage;
    this.transactionLogs = logs ? logs : void 0;
  }
  get transactionError() {
    return {
      message: this.transactionMessage,
      logs: Array.isArray(this.transactionLogs) ? this.transactionLogs : void 0
    };
  }
  /* @deprecated Use `await getLogs()` instead */
  get logs() {
    const cachedLogs = this.transactionLogs;
    if (cachedLogs != null && typeof cachedLogs === "object" && "then" in cachedLogs) {
      return void 0;
    }
    return cachedLogs;
  }
  async getLogs(connection) {
    if (!Array.isArray(this.transactionLogs)) {
      this.transactionLogs = new Promise((resolve, reject) => {
        connection.getTransaction(this.signature).then((tx) => {
          if (tx && tx.meta && tx.meta.logMessages) {
            const logs = tx.meta.logMessages;
            this.transactionLogs = logs;
            resolve(logs);
          } else {
            reject(new Error("Log messages not found"));
          }
        }).catch(reject);
      });
    }
    return await this.transactionLogs;
  }
}
class SolanaJSONRPCError extends Error {
  constructor({
    code,
    message,
    data
  }, customMessage) {
    super(customMessage != null ? `${customMessage}: ${message}` : message);
    this.code = void 0;
    this.data = void 0;
    this.code = code;
    this.data = data;
    this.name = "SolanaJSONRPCError";
  }
}
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
const FeeCalculatorLayout = LayoutExports.nu64("lamportsPerSignature");
const NonceAccountLayout = LayoutExports.struct([LayoutExports.u32("version"), LayoutExports.u32("state"), publicKey("authorizedPubkey"), publicKey("nonce"), LayoutExports.struct([FeeCalculatorLayout], "feeCalculator")]);
NonceAccountLayout.span;
class NonceAccount {
  /**
   * @internal
   */
  constructor(args) {
    this.authorizedPubkey = void 0;
    this.nonce = void 0;
    this.feeCalculator = void 0;
    this.authorizedPubkey = args.authorizedPubkey;
    this.nonce = args.nonce;
    this.feeCalculator = args.feeCalculator;
  }
  /**
   * Deserialize NonceAccount from the account data.
   *
   * @param buffer account data
   * @return NonceAccount
   */
  static fromAccountData(buffer2) {
    const nonceAccount = NonceAccountLayout.decode(toBuffer(buffer2), 0);
    return new NonceAccount({
      authorizedPubkey: new PublicKey(nonceAccount.authorizedPubkey),
      nonce: new PublicKey(nonceAccount.nonce).toString(),
      feeCalculator: nonceAccount.feeCalculator
    });
  }
}
function u64(property) {
  const layout = LayoutExports.blob(8, property);
  const decode2 = layout.decode.bind(layout);
  const encode2 = layout.encode.bind(layout);
  const bigIntLayout = layout;
  const codec = getU64Codec();
  bigIntLayout.decode = (buffer2, offset) => {
    const src2 = decode2(buffer2, offset);
    return codec.decode(src2);
  };
  bigIntLayout.encode = (bigInt, buffer2, offset) => {
    const src2 = codec.encode(bigInt);
    return encode2(src2, buffer2, offset);
  };
  return bigIntLayout;
}
Object.freeze({
  Create: {
    index: 0,
    layout: LayoutExports.struct([LayoutExports.u32("instruction"), LayoutExports.ns64("lamports"), LayoutExports.ns64("space"), publicKey("programId")])
  },
  Assign: {
    index: 1,
    layout: LayoutExports.struct([LayoutExports.u32("instruction"), publicKey("programId")])
  },
  Transfer: {
    index: 2,
    layout: LayoutExports.struct([LayoutExports.u32("instruction"), u64("lamports")])
  },
  CreateWithSeed: {
    index: 3,
    layout: LayoutExports.struct([LayoutExports.u32("instruction"), publicKey("base"), rustString("seed"), LayoutExports.ns64("lamports"), LayoutExports.ns64("space"), publicKey("programId")])
  },
  AdvanceNonceAccount: {
    index: 4,
    layout: LayoutExports.struct([LayoutExports.u32("instruction")])
  },
  WithdrawNonceAccount: {
    index: 5,
    layout: LayoutExports.struct([LayoutExports.u32("instruction"), LayoutExports.ns64("lamports")])
  },
  InitializeNonceAccount: {
    index: 6,
    layout: LayoutExports.struct([LayoutExports.u32("instruction"), publicKey("authorized")])
  },
  AuthorizeNonceAccount: {
    index: 7,
    layout: LayoutExports.struct([LayoutExports.u32("instruction"), publicKey("authorized")])
  },
  Allocate: {
    index: 8,
    layout: LayoutExports.struct([LayoutExports.u32("instruction"), LayoutExports.ns64("space")])
  },
  AllocateWithSeed: {
    index: 9,
    layout: LayoutExports.struct([LayoutExports.u32("instruction"), publicKey("base"), rustString("seed"), LayoutExports.ns64("space"), publicKey("programId")])
  },
  AssignWithSeed: {
    index: 10,
    layout: LayoutExports.struct([LayoutExports.u32("instruction"), publicKey("base"), rustString("seed"), publicKey("programId")])
  },
  TransferWithSeed: {
    index: 11,
    layout: LayoutExports.struct([LayoutExports.u32("instruction"), u64("lamports"), rustString("seed"), publicKey("programId")])
  },
  UpgradeNonceAccount: {
    index: 12,
    layout: LayoutExports.struct([LayoutExports.u32("instruction")])
  }
});
new PublicKey("11111111111111111111111111111111");
new PublicKey("BPFLoader2111111111111111111111111111111111");
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var fastStableStringify$1;
var hasRequiredFastStableStringify;
function requireFastStableStringify() {
  if (hasRequiredFastStableStringify) return fastStableStringify$1;
  hasRequiredFastStableStringify = 1;
  var objToString = Object.prototype.toString;
  var objKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var name in obj) {
      keys2.push(name);
    }
    return keys2;
  };
  function stringify2(val, isArrayProp) {
    var i, max, str, keys2, key, propVal, toStr;
    if (val === true) {
      return "true";
    }
    if (val === false) {
      return "false";
    }
    switch (typeof val) {
      case "object":
        if (val === null) {
          return null;
        } else if (val.toJSON && typeof val.toJSON === "function") {
          return stringify2(val.toJSON(), isArrayProp);
        } else {
          toStr = objToString.call(val);
          if (toStr === "[object Array]") {
            str = "[";
            max = val.length - 1;
            for (i = 0; i < max; i++) {
              str += stringify2(val[i], true) + ",";
            }
            if (max > -1) {
              str += stringify2(val[i], true);
            }
            return str + "]";
          } else if (toStr === "[object Object]") {
            keys2 = objKeys(val).sort();
            max = keys2.length;
            str = "";
            i = 0;
            while (i < max) {
              key = keys2[i];
              propVal = stringify2(val[key], false);
              if (propVal !== void 0) {
                if (str) {
                  str += ",";
                }
                str += JSON.stringify(key) + ":" + propVal;
              }
              i++;
            }
            return "{" + str + "}";
          } else {
            return JSON.stringify(val);
          }
        }
      case "function":
      case "undefined":
        return isArrayProp ? null : void 0;
      case "string":
        return JSON.stringify(val);
      default:
        return isFinite(val) ? val : null;
    }
  }
  fastStableStringify$1 = function(val) {
    var returnVal = stringify2(val, false);
    if (returnVal !== void 0) {
      return "" + returnVal;
    }
  };
  return fastStableStringify$1;
}
var fastStableStringifyExports = /* @__PURE__ */ requireFastStableStringify();
var fastStableStringify = /* @__PURE__ */ getDefaultExportFromCjs(fastStableStringifyExports);
const MINIMUM_SLOT_PER_EPOCH = 32;
function trailingZeros(n) {
  let trailingZeros2 = 0;
  while (n > 1) {
    n /= 2;
    trailingZeros2++;
  }
  return trailingZeros2;
}
function nextPowerOfTwo(n) {
  if (n === 0) return 1;
  n--;
  n |= n >> 1;
  n |= n >> 2;
  n |= n >> 4;
  n |= n >> 8;
  n |= n >> 16;
  n |= n >> 32;
  return n + 1;
}
class EpochSchedule {
  constructor(slotsPerEpoch, leaderScheduleSlotOffset, warmup, firstNormalEpoch, firstNormalSlot) {
    this.slotsPerEpoch = void 0;
    this.leaderScheduleSlotOffset = void 0;
    this.warmup = void 0;
    this.firstNormalEpoch = void 0;
    this.firstNormalSlot = void 0;
    this.slotsPerEpoch = slotsPerEpoch;
    this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;
    this.warmup = warmup;
    this.firstNormalEpoch = firstNormalEpoch;
    this.firstNormalSlot = firstNormalSlot;
  }
  getEpoch(slot) {
    return this.getEpochAndSlotIndex(slot)[0];
  }
  getEpochAndSlotIndex(slot) {
    if (slot < this.firstNormalSlot) {
      const epoch = trailingZeros(nextPowerOfTwo(slot + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1;
      const epochLen = this.getSlotsInEpoch(epoch);
      const slotIndex = slot - (epochLen - MINIMUM_SLOT_PER_EPOCH);
      return [epoch, slotIndex];
    } else {
      const normalSlotIndex = slot - this.firstNormalSlot;
      const normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);
      const epoch = this.firstNormalEpoch + normalEpochIndex;
      const slotIndex = normalSlotIndex % this.slotsPerEpoch;
      return [epoch, slotIndex];
    }
  }
  getFirstSlotInEpoch(epoch) {
    if (epoch <= this.firstNormalEpoch) {
      return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH;
    } else {
      return (epoch - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;
    }
  }
  getLastSlotInEpoch(epoch) {
    return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;
  }
  getSlotsInEpoch(epoch) {
    if (epoch < this.firstNormalEpoch) {
      return Math.pow(2, epoch + trailingZeros(MINIMUM_SLOT_PER_EPOCH));
    } else {
      return this.slotsPerEpoch;
    }
  }
}
var fetchImpl = globalThis.fetch;
class RpcWebSocketClient extends CommonClient {
  constructor(address, options, generate_request_id) {
    const webSocketFactory = (url) => {
      const rpc = WebSocket(url, {
        autoconnect: true,
        max_reconnects: 5,
        reconnect: true,
        reconnect_interval: 1e3,
        ...options
      });
      if ("socket" in rpc) {
        this.underlyingSocket = rpc.socket;
      } else {
        this.underlyingSocket = rpc;
      }
      return rpc;
    };
    super(webSocketFactory, address, options, generate_request_id);
    this.underlyingSocket = void 0;
  }
  call(...args) {
    const readyState = this.underlyingSocket?.readyState;
    if (readyState === 1) {
      return super.call(...args);
    }
    return Promise.reject(new Error("Tried to call a JSON-RPC method `" + args[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + readyState + ")"));
  }
  notify(...args) {
    const readyState = this.underlyingSocket?.readyState;
    if (readyState === 1) {
      return super.notify(...args);
    }
    return Promise.reject(new Error("Tried to send a JSON-RPC notification `" + args[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + readyState + ")"));
  }
}
function decodeData(type2, data) {
  let decoded;
  try {
    decoded = type2.layout.decode(data);
  } catch (err) {
    throw new Error("invalid instruction; " + err);
  }
  if (decoded.typeIndex !== type2.index) {
    throw new Error(`invalid account data; account type mismatch ${decoded.typeIndex} != ${type2.index}`);
  }
  return decoded;
}
const LOOKUP_TABLE_META_SIZE = 56;
class AddressLookupTableAccount {
  constructor(args) {
    this.key = void 0;
    this.state = void 0;
    this.key = args.key;
    this.state = args.state;
  }
  isActive() {
    const U64_MAX = BigInt("0xffffffffffffffff");
    return this.state.deactivationSlot === U64_MAX;
  }
  static deserialize(accountData) {
    const meta = decodeData(LookupTableMetaLayout, accountData);
    const serializedAddressesLen = accountData.length - LOOKUP_TABLE_META_SIZE;
    assert(serializedAddressesLen >= 0, "lookup table is invalid");
    assert(serializedAddressesLen % 32 === 0, "lookup table is invalid");
    const numSerializedAddresses = serializedAddressesLen / 32;
    const {
      addresses
    } = LayoutExports.struct([LayoutExports.seq(publicKey(), numSerializedAddresses, "addresses")]).decode(accountData.slice(LOOKUP_TABLE_META_SIZE));
    return {
      deactivationSlot: meta.deactivationSlot,
      lastExtendedSlot: meta.lastExtendedSlot,
      lastExtendedSlotStartIndex: meta.lastExtendedStartIndex,
      authority: meta.authority.length !== 0 ? new PublicKey(meta.authority[0]) : void 0,
      addresses: addresses.map((address) => new PublicKey(address))
    };
  }
}
const LookupTableMetaLayout = {
  index: 1,
  layout: LayoutExports.struct([
    LayoutExports.u32("typeIndex"),
    u64("deactivationSlot"),
    LayoutExports.nu64("lastExtendedSlot"),
    LayoutExports.u8("lastExtendedStartIndex"),
    LayoutExports.u8(),
    // option
    LayoutExports.seq(publicKey(), LayoutExports.offset(LayoutExports.u8(), -1), "authority")
  ])
};
const URL_RE = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
function makeWebsocketUrl(endpoint2) {
  const matches = endpoint2.match(URL_RE);
  if (matches == null) {
    throw TypeError(`Failed to validate endpoint URL \`${endpoint2}\``);
  }
  const [
    _2,
    // eslint-disable-line @typescript-eslint/no-unused-vars
    hostish,
    portWithColon,
    rest
  ] = matches;
  const protocol = endpoint2.startsWith("https:") ? "wss:" : "ws:";
  const startPort = portWithColon == null ? null : parseInt(portWithColon.slice(1), 10);
  const websocketPort = (
    // Only shift the port by +1 as a convention for ws(s) only if given endpoint
    // is explicitly specifying the endpoint port (HTTP-based RPC), assuming
    // we're directly trying to connect to agave-validator's ws listening port.
    // When the endpoint omits the port, we're connecting to the protocol
    // default ports: http(80) or https(443) and it's assumed we're behind a reverse
    // proxy which manages WebSocket upgrade and backend port redirection.
    startPort == null ? "" : `:${startPort + 1}`
  );
  return `${protocol}//${hostish}${websocketPort}${rest}`;
}
const PublicKeyFromString = coerce(instance(PublicKey), string(), (value) => new PublicKey(value));
const RawAccountDataResult = tuple([string(), literal("base64")]);
const BufferFromRawAccountData = coerce(instance(bufferExports.Buffer), RawAccountDataResult, (value) => bufferExports.Buffer.from(value[0], "base64"));
const BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1e3;
function assertEndpointUrl(putativeUrl) {
  if (/^https?:/.test(putativeUrl) === false) {
    throw new TypeError("Endpoint URL must start with `http:` or `https:`.");
  }
  return putativeUrl;
}
function extractCommitmentFromConfig(commitmentOrConfig) {
  let commitment;
  let config;
  if (typeof commitmentOrConfig === "string") {
    commitment = commitmentOrConfig;
  } else if (commitmentOrConfig) {
    const {
      commitment: specifiedCommitment,
      ...specifiedConfig
    } = commitmentOrConfig;
    commitment = specifiedCommitment;
    config = specifiedConfig;
  }
  return {
    commitment,
    config
  };
}
function applyDefaultMemcmpEncodingToFilters(filters) {
  return filters.map((filter) => "memcmp" in filter ? {
    ...filter,
    memcmp: {
      ...filter.memcmp,
      encoding: filter.memcmp.encoding ?? "base58"
    }
  } : filter);
}
function createRpcResult(result) {
  return union([type({
    jsonrpc: literal("2.0"),
    id: string(),
    result
  }), type({
    jsonrpc: literal("2.0"),
    id: string(),
    error: type({
      code: unknown(),
      message: string(),
      data: optional(any())
    })
  })]);
}
const UnknownRpcResult = createRpcResult(unknown());
function jsonRpcResult(schema) {
  return coerce(createRpcResult(schema), UnknownRpcResult, (value) => {
    if ("error" in value) {
      return value;
    } else {
      return {
        ...value,
        result: create(value.result, schema)
      };
    }
  });
}
function jsonRpcResultAndContext(value) {
  return jsonRpcResult(type({
    context: type({
      slot: number()
    }),
    value
  }));
}
function notificationResultAndContext(value) {
  return type({
    context: type({
      slot: number()
    }),
    value
  });
}
function versionedMessageFromResponse(version2, response) {
  if (version2 === 0) {
    return new MessageV0({
      header: response.header,
      staticAccountKeys: response.accountKeys.map((accountKey) => new PublicKey(accountKey)),
      recentBlockhash: response.recentBlockhash,
      compiledInstructions: response.instructions.map((ix) => ({
        programIdIndex: ix.programIdIndex,
        accountKeyIndexes: ix.accounts,
        data: bs58.decode(ix.data)
      })),
      addressTableLookups: response.addressTableLookups
    });
  } else {
    return new Message(response);
  }
}
const GetInflationGovernorResult = type({
  foundation: number(),
  foundationTerm: number(),
  initial: number(),
  taper: number(),
  terminal: number()
});
const GetInflationRewardResult = jsonRpcResult(array(nullable(type({
  epoch: number(),
  effectiveSlot: number(),
  amount: number(),
  postBalance: number(),
  commission: optional(nullable(number()))
}))));
const GetRecentPrioritizationFeesResult = array(type({
  slot: number(),
  prioritizationFee: number()
}));
const GetInflationRateResult = type({
  total: number(),
  validator: number(),
  foundation: number(),
  epoch: number()
});
const GetEpochInfoResult = type({
  epoch: number(),
  slotIndex: number(),
  slotsInEpoch: number(),
  absoluteSlot: number(),
  blockHeight: optional(number()),
  transactionCount: optional(number())
});
const GetEpochScheduleResult = type({
  slotsPerEpoch: number(),
  leaderScheduleSlotOffset: number(),
  warmup: boolean(),
  firstNormalEpoch: number(),
  firstNormalSlot: number()
});
const GetLeaderScheduleResult = record(string(), array(number()));
const TransactionErrorResult = nullable(union([type({}), string()]));
const SignatureStatusResult = type({
  err: TransactionErrorResult
});
const SignatureReceivedResult = literal("receivedSignature");
const VersionResult = type({
  "solana-core": string(),
  "feature-set": optional(number())
});
const ParsedInstructionStruct = type({
  program: string(),
  programId: PublicKeyFromString,
  parsed: unknown()
});
const PartiallyDecodedInstructionStruct = type({
  programId: PublicKeyFromString,
  accounts: array(PublicKeyFromString),
  data: string()
});
const SimulatedTransactionResponseStruct = jsonRpcResultAndContext(type({
  err: nullable(union([type({}), string()])),
  logs: nullable(array(string())),
  accounts: optional(nullable(array(nullable(type({
    executable: boolean(),
    owner: string(),
    lamports: number(),
    data: array(string()),
    rentEpoch: optional(number())
  }))))),
  unitsConsumed: optional(number()),
  returnData: optional(nullable(type({
    programId: string(),
    data: tuple([string(), literal("base64")])
  }))),
  innerInstructions: optional(nullable(array(type({
    index: number(),
    instructions: array(union([ParsedInstructionStruct, PartiallyDecodedInstructionStruct]))
  }))))
}));
const BlockProductionResponseStruct = jsonRpcResultAndContext(type({
  byIdentity: record(string(), array(number())),
  range: type({
    firstSlot: number(),
    lastSlot: number()
  })
}));
function createRpcClient(url, httpHeaders, customFetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent) {
  const fetch2 = customFetch ? customFetch : fetchImpl;
  let agent;
  {
    if (httpAgent != null) {
      console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");
    }
  }
  let fetchWithMiddleware;
  if (fetchMiddleware) {
    fetchWithMiddleware = async (info, init) => {
      const modifiedFetchArgs = await new Promise((resolve, reject) => {
        try {
          fetchMiddleware(info, init, (modifiedInfo, modifiedInit) => resolve([modifiedInfo, modifiedInit]));
        } catch (error) {
          reject(error);
        }
      });
      return await fetch2(...modifiedFetchArgs);
    };
  }
  const clientBrowser = new RpcClient(async (request, callback) => {
    const options = {
      method: "POST",
      body: request,
      agent,
      headers: Object.assign({
        "Content-Type": "application/json"
      }, httpHeaders || {}, COMMON_HTTP_HEADERS)
    };
    try {
      let too_many_requests_retries = 5;
      let res;
      let waitTime = 500;
      for (; ; ) {
        if (fetchWithMiddleware) {
          res = await fetchWithMiddleware(url, options);
        } else {
          res = await fetch2(url, options);
        }
        if (res.status !== 429) {
          break;
        }
        if (disableRetryOnRateLimit === true) {
          break;
        }
        too_many_requests_retries -= 1;
        if (too_many_requests_retries === 0) {
          break;
        }
        console.error(`Server responded with ${res.status} ${res.statusText}.  Retrying after ${waitTime}ms delay...`);
        await sleep(waitTime);
        waitTime *= 2;
      }
      const text = await res.text();
      if (res.ok) {
        callback(null, text);
      } else {
        callback(new Error(`${res.status} ${res.statusText}: ${text}`));
      }
    } catch (err) {
      if (err instanceof Error) callback(err);
    }
  }, {});
  return clientBrowser;
}
function createRpcRequest(client) {
  return (method, args) => {
    return new Promise((resolve, reject) => {
      client.request(method, args, (err, response) => {
        if (err) {
          reject(err);
          return;
        }
        resolve(response);
      });
    });
  };
}
function createRpcBatchRequest(client) {
  return (requests) => {
    return new Promise((resolve, reject) => {
      if (requests.length === 0) resolve([]);
      const batch = requests.map((params) => {
        return client.request(params.methodName, params.args);
      });
      client.request(batch, (err, response) => {
        if (err) {
          reject(err);
          return;
        }
        resolve(response);
      });
    });
  };
}
const GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);
const GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult);
const GetRecentPrioritizationFeesRpcResult = jsonRpcResult(GetRecentPrioritizationFeesResult);
const GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);
const GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);
const GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);
const SlotRpcResult = jsonRpcResult(number());
const GetSupplyRpcResult = jsonRpcResultAndContext(type({
  total: number(),
  circulating: number(),
  nonCirculating: number(),
  nonCirculatingAccounts: array(PublicKeyFromString)
}));
const TokenAmountResult = type({
  amount: string(),
  uiAmount: nullable(number()),
  decimals: number(),
  uiAmountString: optional(string())
});
const GetTokenLargestAccountsResult = jsonRpcResultAndContext(array(type({
  address: PublicKeyFromString,
  amount: string(),
  uiAmount: nullable(number()),
  decimals: number(),
  uiAmountString: optional(string())
})));
const GetTokenAccountsByOwner = jsonRpcResultAndContext(array(type({
  pubkey: PublicKeyFromString,
  account: type({
    executable: boolean(),
    owner: PublicKeyFromString,
    lamports: number(),
    data: BufferFromRawAccountData,
    rentEpoch: number()
  })
})));
const ParsedAccountDataResult = type({
  program: string(),
  parsed: unknown(),
  space: number()
});
const GetParsedTokenAccountsByOwner = jsonRpcResultAndContext(array(type({
  pubkey: PublicKeyFromString,
  account: type({
    executable: boolean(),
    owner: PublicKeyFromString,
    lamports: number(),
    data: ParsedAccountDataResult,
    rentEpoch: number()
  })
})));
const GetLargestAccountsRpcResult = jsonRpcResultAndContext(array(type({
  lamports: number(),
  address: PublicKeyFromString
})));
const AccountInfoResult = type({
  executable: boolean(),
  owner: PublicKeyFromString,
  lamports: number(),
  data: BufferFromRawAccountData,
  rentEpoch: number()
});
const KeyedAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
});
const ParsedOrRawAccountData = coerce(union([instance(bufferExports.Buffer), ParsedAccountDataResult]), union([RawAccountDataResult, ParsedAccountDataResult]), (value) => {
  if (Array.isArray(value)) {
    return create(value, BufferFromRawAccountData);
  } else {
    return value;
  }
});
const ParsedAccountInfoResult = type({
  executable: boolean(),
  owner: PublicKeyFromString,
  lamports: number(),
  data: ParsedOrRawAccountData,
  rentEpoch: number()
});
const KeyedParsedAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: ParsedAccountInfoResult
});
const StakeActivationResult = type({
  state: union([literal("active"), literal("inactive"), literal("activating"), literal("deactivating")]),
  active: number(),
  inactive: number()
});
const GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult(array(type({
  signature: string(),
  slot: number(),
  err: TransactionErrorResult,
  memo: nullable(string()),
  blockTime: optional(nullable(number()))
})));
const GetSignaturesForAddressRpcResult = jsonRpcResult(array(type({
  signature: string(),
  slot: number(),
  err: TransactionErrorResult,
  memo: nullable(string()),
  blockTime: optional(nullable(number()))
})));
const AccountNotificationResult = type({
  subscription: number(),
  result: notificationResultAndContext(AccountInfoResult)
});
const ProgramAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
});
const ProgramAccountNotificationResult = type({
  subscription: number(),
  result: notificationResultAndContext(ProgramAccountInfoResult)
});
const SlotInfoResult = type({
  parent: number(),
  slot: number(),
  root: number()
});
const SlotNotificationResult = type({
  subscription: number(),
  result: SlotInfoResult
});
const SlotUpdateResult = union([type({
  type: union([literal("firstShredReceived"), literal("completed"), literal("optimisticConfirmation"), literal("root")]),
  slot: number(),
  timestamp: number()
}), type({
  type: literal("createdBank"),
  parent: number(),
  slot: number(),
  timestamp: number()
}), type({
  type: literal("frozen"),
  slot: number(),
  timestamp: number(),
  stats: type({
    numTransactionEntries: number(),
    numSuccessfulTransactions: number(),
    numFailedTransactions: number(),
    maxTransactionsPerEntry: number()
  })
}), type({
  type: literal("dead"),
  slot: number(),
  timestamp: number(),
  err: string()
})]);
const SlotUpdateNotificationResult = type({
  subscription: number(),
  result: SlotUpdateResult
});
const SignatureNotificationResult = type({
  subscription: number(),
  result: notificationResultAndContext(union([SignatureStatusResult, SignatureReceivedResult]))
});
const RootNotificationResult = type({
  subscription: number(),
  result: number()
});
const ContactInfoResult = type({
  pubkey: string(),
  gossip: nullable(string()),
  tpu: nullable(string()),
  rpc: nullable(string()),
  version: nullable(string())
});
const VoteAccountInfoResult = type({
  votePubkey: string(),
  nodePubkey: string(),
  activatedStake: number(),
  epochVoteAccount: boolean(),
  epochCredits: array(tuple([number(), number(), number()])),
  commission: number(),
  lastVote: number(),
  rootSlot: nullable(number())
});
const GetVoteAccounts = jsonRpcResult(type({
  current: array(VoteAccountInfoResult),
  delinquent: array(VoteAccountInfoResult)
}));
const ConfirmationStatus = union([literal("processed"), literal("confirmed"), literal("finalized")]);
const SignatureStatusResponse = type({
  slot: number(),
  confirmations: nullable(number()),
  err: TransactionErrorResult,
  confirmationStatus: optional(ConfirmationStatus)
});
const GetSignatureStatusesRpcResult = jsonRpcResultAndContext(array(nullable(SignatureStatusResponse)));
const GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult(number());
const AddressTableLookupStruct = type({
  accountKey: PublicKeyFromString,
  writableIndexes: array(number()),
  readonlyIndexes: array(number())
});
const ConfirmedTransactionResult = type({
  signatures: array(string()),
  message: type({
    accountKeys: array(string()),
    header: type({
      numRequiredSignatures: number(),
      numReadonlySignedAccounts: number(),
      numReadonlyUnsignedAccounts: number()
    }),
    instructions: array(type({
      accounts: array(number()),
      data: string(),
      programIdIndex: number()
    })),
    recentBlockhash: string(),
    addressTableLookups: optional(array(AddressTableLookupStruct))
  })
});
const AnnotatedAccountKey = type({
  pubkey: PublicKeyFromString,
  signer: boolean(),
  writable: boolean(),
  source: optional(union([literal("transaction"), literal("lookupTable")]))
});
const ConfirmedTransactionAccountsModeResult = type({
  accountKeys: array(AnnotatedAccountKey),
  signatures: array(string())
});
const ParsedInstructionResult = type({
  parsed: unknown(),
  program: string(),
  programId: PublicKeyFromString
});
const RawInstructionResult = type({
  accounts: array(PublicKeyFromString),
  data: string(),
  programId: PublicKeyFromString
});
const InstructionResult = union([RawInstructionResult, ParsedInstructionResult]);
const UnknownInstructionResult = union([type({
  parsed: unknown(),
  program: string(),
  programId: string()
}), type({
  accounts: array(string()),
  data: string(),
  programId: string()
})]);
const ParsedOrRawInstruction = coerce(InstructionResult, UnknownInstructionResult, (value) => {
  if ("accounts" in value) {
    return create(value, RawInstructionResult);
  } else {
    return create(value, ParsedInstructionResult);
  }
});
const ParsedConfirmedTransactionResult = type({
  signatures: array(string()),
  message: type({
    accountKeys: array(AnnotatedAccountKey),
    instructions: array(ParsedOrRawInstruction),
    recentBlockhash: string(),
    addressTableLookups: optional(nullable(array(AddressTableLookupStruct)))
  })
});
const TokenBalanceResult = type({
  accountIndex: number(),
  mint: string(),
  owner: optional(string()),
  programId: optional(string()),
  uiTokenAmount: TokenAmountResult
});
const LoadedAddressesResult = type({
  writable: array(PublicKeyFromString),
  readonly: array(PublicKeyFromString)
});
const ConfirmedTransactionMetaResult = type({
  err: TransactionErrorResult,
  fee: number(),
  innerInstructions: optional(nullable(array(type({
    index: number(),
    instructions: array(type({
      accounts: array(number()),
      data: string(),
      programIdIndex: number()
    }))
  })))),
  preBalances: array(number()),
  postBalances: array(number()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult))),
  loadedAddresses: optional(LoadedAddressesResult),
  computeUnitsConsumed: optional(number())
});
const ParsedConfirmedTransactionMetaResult = type({
  err: TransactionErrorResult,
  fee: number(),
  innerInstructions: optional(nullable(array(type({
    index: number(),
    instructions: array(ParsedOrRawInstruction)
  })))),
  preBalances: array(number()),
  postBalances: array(number()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult))),
  loadedAddresses: optional(LoadedAddressesResult),
  computeUnitsConsumed: optional(number())
});
const TransactionVersionStruct = union([literal(0), literal("legacy")]);
const RewardsResult = type({
  pubkey: string(),
  lamports: number(),
  postBalance: nullable(number()),
  rewardType: nullable(string()),
  commission: optional(nullable(number()))
});
const GetBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionResult,
    meta: nullable(ConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
const GetNoneModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
const GetAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: nullable(ConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
const GetParsedBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ParsedConfirmedTransactionResult,
    meta: nullable(ParsedConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
const GetParsedAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: nullable(ParsedConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
const GetParsedNoneModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
})));
const GetConfirmedBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionResult,
    meta: nullable(ConfirmedTransactionMetaResult)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number())
})));
const GetBlockSignaturesRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  signatures: array(string()),
  blockTime: nullable(number())
})));
const GetTransactionRpcResult = jsonRpcResult(nullable(type({
  slot: number(),
  meta: nullable(ConfirmedTransactionMetaResult),
  blockTime: optional(nullable(number())),
  transaction: ConfirmedTransactionResult,
  version: optional(TransactionVersionStruct)
})));
const GetParsedTransactionRpcResult = jsonRpcResult(nullable(type({
  slot: number(),
  transaction: ParsedConfirmedTransactionResult,
  meta: nullable(ParsedConfirmedTransactionMetaResult),
  blockTime: optional(nullable(number())),
  version: optional(TransactionVersionStruct)
})));
const GetLatestBlockhashRpcResult = jsonRpcResultAndContext(type({
  blockhash: string(),
  lastValidBlockHeight: number()
}));
const IsBlockhashValidRpcResult = jsonRpcResultAndContext(boolean());
const PerfSampleResult = type({
  slot: number(),
  numTransactions: number(),
  numSlots: number(),
  samplePeriodSecs: number()
});
const GetRecentPerformanceSamplesRpcResult = jsonRpcResult(array(PerfSampleResult));
const GetFeeCalculatorRpcResult = jsonRpcResultAndContext(nullable(type({
  feeCalculator: type({
    lamportsPerSignature: number()
  })
})));
const RequestAirdropRpcResult = jsonRpcResult(string());
const SendTransactionRpcResult = jsonRpcResult(string());
const LogsResult = type({
  err: TransactionErrorResult,
  logs: array(string()),
  signature: string()
});
const LogsNotificationResult = type({
  result: notificationResultAndContext(LogsResult),
  subscription: number()
});
const COMMON_HTTP_HEADERS = {
  "solana-client": `js/${"1.0.0-maintenance"}`
};
class Connection {
  /**
   * Establish a JSON RPC connection
   *
   * @param endpoint URL to the fullnode JSON RPC endpoint
   * @param commitmentOrConfig optional default commitment level or optional ConnectionConfig configuration object
   */
  constructor(endpoint2, _commitmentOrConfig) {
    this._commitment = void 0;
    this._confirmTransactionInitialTimeout = void 0;
    this._rpcEndpoint = void 0;
    this._rpcWsEndpoint = void 0;
    this._rpcClient = void 0;
    this._rpcRequest = void 0;
    this._rpcBatchRequest = void 0;
    this._rpcWebSocket = void 0;
    this._rpcWebSocketConnected = false;
    this._rpcWebSocketHeartbeat = null;
    this._rpcWebSocketIdleTimeout = null;
    this._rpcWebSocketGeneration = 0;
    this._disableBlockhashCaching = false;
    this._pollingBlockhash = false;
    this._blockhashInfo = {
      latestBlockhash: null,
      lastFetch: 0,
      transactionSignatures: [],
      simulatedSignatures: []
    };
    this._nextClientSubscriptionId = 0;
    this._subscriptionDisposeFunctionsByClientSubscriptionId = {};
    this._subscriptionHashByClientSubscriptionId = {};
    this._subscriptionStateChangeCallbacksByHash = {};
    this._subscriptionCallbacksByServerSubscriptionId = {};
    this._subscriptionsByHash = {};
    this._subscriptionsAutoDisposedByRpc = /* @__PURE__ */ new Set();
    this.getBlockHeight = /* @__PURE__ */ (() => {
      const requestPromises = {};
      return async (commitmentOrConfig) => {
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const args = this._buildArgs([], commitment, void 0, config);
        const requestHash = fastStableStringify(args);
        requestPromises[requestHash] = requestPromises[requestHash] ?? (async () => {
          try {
            const unsafeRes = await this._rpcRequest("getBlockHeight", args);
            const res = create(unsafeRes, jsonRpcResult(number()));
            if ("error" in res) {
              throw new SolanaJSONRPCError(res.error, "failed to get block height information");
            }
            return res.result;
          } finally {
            delete requestPromises[requestHash];
          }
        })();
        return await requestPromises[requestHash];
      };
    })();
    let wsEndpoint;
    let httpHeaders;
    let fetch2;
    let fetchMiddleware;
    let disableRetryOnRateLimit;
    let httpAgent;
    if (_commitmentOrConfig && typeof _commitmentOrConfig === "string") {
      this._commitment = _commitmentOrConfig;
    } else if (_commitmentOrConfig) {
      this._commitment = _commitmentOrConfig.commitment;
      this._confirmTransactionInitialTimeout = _commitmentOrConfig.confirmTransactionInitialTimeout;
      wsEndpoint = _commitmentOrConfig.wsEndpoint;
      httpHeaders = _commitmentOrConfig.httpHeaders;
      fetch2 = _commitmentOrConfig.fetch;
      fetchMiddleware = _commitmentOrConfig.fetchMiddleware;
      disableRetryOnRateLimit = _commitmentOrConfig.disableRetryOnRateLimit;
      httpAgent = _commitmentOrConfig.httpAgent;
    }
    this._rpcEndpoint = assertEndpointUrl(endpoint2);
    this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl(endpoint2);
    this._rpcClient = createRpcClient(endpoint2, httpHeaders, fetch2, fetchMiddleware, disableRetryOnRateLimit, httpAgent);
    this._rpcRequest = createRpcRequest(this._rpcClient);
    this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient);
    this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {
      autoconnect: false,
      max_reconnects: Infinity
    });
    this._rpcWebSocket.on("open", this._wsOnOpen.bind(this));
    this._rpcWebSocket.on("error", this._wsOnError.bind(this));
    this._rpcWebSocket.on("close", this._wsOnClose.bind(this));
    this._rpcWebSocket.on("accountNotification", this._wsOnAccountNotification.bind(this));
    this._rpcWebSocket.on("programNotification", this._wsOnProgramAccountNotification.bind(this));
    this._rpcWebSocket.on("slotNotification", this._wsOnSlotNotification.bind(this));
    this._rpcWebSocket.on("slotsUpdatesNotification", this._wsOnSlotUpdatesNotification.bind(this));
    this._rpcWebSocket.on("signatureNotification", this._wsOnSignatureNotification.bind(this));
    this._rpcWebSocket.on("rootNotification", this._wsOnRootNotification.bind(this));
    this._rpcWebSocket.on("logsNotification", this._wsOnLogsNotification.bind(this));
  }
  /**
   * The default commitment used for requests
   */
  get commitment() {
    return this._commitment;
  }
  /**
   * The RPC endpoint
   */
  get rpcEndpoint() {
    return this._rpcEndpoint;
  }
  /**
   * Fetch the balance for the specified public key, return with context
   */
  async getBalanceAndContext(publicKey2, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([publicKey2.toBase58()], commitment, void 0, config);
    const unsafeRes = await this._rpcRequest("getBalance", args);
    const res = create(unsafeRes, jsonRpcResultAndContext(number()));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get balance for ${publicKey2.toBase58()}`);
    }
    return res.result;
  }
  /**
   * Fetch the balance for the specified public key
   */
  async getBalance(publicKey2, commitmentOrConfig) {
    return await this.getBalanceAndContext(publicKey2, commitmentOrConfig).then((x2) => x2.value).catch((e3) => {
      throw new Error("failed to get balance of account " + publicKey2.toBase58() + ": " + e3);
    });
  }
  /**
   * Fetch the estimated production time of a block
   */
  async getBlockTime(slot) {
    const unsafeRes = await this._rpcRequest("getBlockTime", [slot]);
    const res = create(unsafeRes, jsonRpcResult(nullable(number())));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get block time for slot ${slot}`);
    }
    return res.result;
  }
  /**
   * Fetch the lowest slot that the node has information about in its ledger.
   * This value may increase over time if the node is configured to purge older ledger data
   */
  async getMinimumLedgerSlot() {
    const unsafeRes = await this._rpcRequest("minimumLedgerSlot", []);
    const res = create(unsafeRes, jsonRpcResult(number()));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get minimum ledger slot");
    }
    return res.result;
  }
  /**
   * Fetch the slot of the lowest confirmed block that has not been purged from the ledger
   */
  async getFirstAvailableBlock() {
    const unsafeRes = await this._rpcRequest("getFirstAvailableBlock", []);
    const res = create(unsafeRes, SlotRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get first available block");
    }
    return res.result;
  }
  /**
   * Fetch information about the current supply
   */
  async getSupply(config) {
    let configArg = {};
    if (typeof config === "string") {
      configArg = {
        commitment: config
      };
    } else if (config) {
      configArg = {
        ...config,
        commitment: config && config.commitment || this.commitment
      };
    } else {
      configArg = {
        commitment: this.commitment
      };
    }
    const unsafeRes = await this._rpcRequest("getSupply", [configArg]);
    const res = create(unsafeRes, GetSupplyRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get supply");
    }
    return res.result;
  }
  /**
   * Fetch the current supply of a token mint
   */
  async getTokenSupply(tokenMintAddress, commitment) {
    const args = this._buildArgs([tokenMintAddress.toBase58()], commitment);
    const unsafeRes = await this._rpcRequest("getTokenSupply", args);
    const res = create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get token supply");
    }
    return res.result;
  }
  /**
   * Fetch the current balance of a token account
   */
  async getTokenAccountBalance(tokenAddress, commitment) {
    const args = this._buildArgs([tokenAddress.toBase58()], commitment);
    const unsafeRes = await this._rpcRequest("getTokenAccountBalance", args);
    const res = create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get token account balance");
    }
    return res.result;
  }
  /**
   * Fetch all the token accounts owned by the specified account
   *
   * @return {Promise<RpcResponseAndContext<GetProgramAccountsResponse>}
   */
  async getTokenAccountsByOwner(ownerAddress, filter, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    let _args = [ownerAddress.toBase58()];
    if ("mint" in filter) {
      _args.push({
        mint: filter.mint.toBase58()
      });
    } else {
      _args.push({
        programId: filter.programId.toBase58()
      });
    }
    const args = this._buildArgs(_args, commitment, "base64", config);
    const unsafeRes = await this._rpcRequest("getTokenAccountsByOwner", args);
    const res = create(unsafeRes, GetTokenAccountsByOwner);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);
    }
    return res.result;
  }
  /**
   * Fetch parsed token accounts owned by the specified account
   *
   * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<ParsedAccountData>}>>>}
   */
  async getParsedTokenAccountsByOwner(ownerAddress, filter, commitment) {
    let _args = [ownerAddress.toBase58()];
    if ("mint" in filter) {
      _args.push({
        mint: filter.mint.toBase58()
      });
    } else {
      _args.push({
        programId: filter.programId.toBase58()
      });
    }
    const args = this._buildArgs(_args, commitment, "jsonParsed");
    const unsafeRes = await this._rpcRequest("getTokenAccountsByOwner", args);
    const res = create(unsafeRes, GetParsedTokenAccountsByOwner);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);
    }
    return res.result;
  }
  /**
   * Fetch the 20 largest accounts with their current balances
   */
  async getLargestAccounts(config) {
    const arg = {
      ...config,
      commitment: config && config.commitment || this.commitment
    };
    const args = arg.filter || arg.commitment ? [arg] : [];
    const unsafeRes = await this._rpcRequest("getLargestAccounts", args);
    const res = create(unsafeRes, GetLargestAccountsRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get largest accounts");
    }
    return res.result;
  }
  /**
   * Fetch the 20 largest token accounts with their current balances
   * for a given mint.
   */
  async getTokenLargestAccounts(mintAddress, commitment) {
    const args = this._buildArgs([mintAddress.toBase58()], commitment);
    const unsafeRes = await this._rpcRequest("getTokenLargestAccounts", args);
    const res = create(unsafeRes, GetTokenLargestAccountsResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get token largest accounts");
    }
    return res.result;
  }
  /**
   * Fetch all the account info for the specified public key, return with context
   */
  async getAccountInfoAndContext(publicKey2, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([publicKey2.toBase58()], commitment, "base64", config);
    const unsafeRes = await this._rpcRequest("getAccountInfo", args);
    const res = create(unsafeRes, jsonRpcResultAndContext(nullable(AccountInfoResult)));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey2.toBase58()}`);
    }
    return res.result;
  }
  /**
   * Fetch parsed account info for the specified public key
   */
  async getParsedAccountInfo(publicKey2, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([publicKey2.toBase58()], commitment, "jsonParsed", config);
    const unsafeRes = await this._rpcRequest("getAccountInfo", args);
    const res = create(unsafeRes, jsonRpcResultAndContext(nullable(ParsedAccountInfoResult)));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey2.toBase58()}`);
    }
    return res.result;
  }
  /**
   * Fetch all the account info for the specified public key
   */
  async getAccountInfo(publicKey2, commitmentOrConfig) {
    try {
      const res = await this.getAccountInfoAndContext(publicKey2, commitmentOrConfig);
      return res.value;
    } catch (e3) {
      throw new Error("failed to get info about account " + publicKey2.toBase58() + ": " + e3);
    }
  }
  /**
   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context
   */
  async getMultipleParsedAccounts(publicKeys, rawConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(rawConfig);
    const keys2 = publicKeys.map((key) => key.toBase58());
    const args = this._buildArgs([keys2], commitment, "jsonParsed", config);
    const unsafeRes = await this._rpcRequest("getMultipleAccounts", args);
    const res = create(unsafeRes, jsonRpcResultAndContext(array(nullable(ParsedAccountInfoResult))));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys2}`);
    }
    return res.result;
  }
  /**
   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context
   */
  async getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const keys2 = publicKeys.map((key) => key.toBase58());
    const args = this._buildArgs([keys2], commitment, "base64", config);
    const unsafeRes = await this._rpcRequest("getMultipleAccounts", args);
    const res = create(unsafeRes, jsonRpcResultAndContext(array(nullable(AccountInfoResult))));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys2}`);
    }
    return res.result;
  }
  /**
   * Fetch all the account info for multiple accounts specified by an array of public keys
   */
  async getMultipleAccountsInfo(publicKeys, commitmentOrConfig) {
    const res = await this.getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig);
    return res.value;
  }
  /**
   * Returns epoch activation information for a stake account that has been delegated
   *
   * @deprecated Deprecated since RPC v1.18; will be removed in a future version.
   */
  async getStakeActivation(publicKey2, commitmentOrConfig, epoch) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([publicKey2.toBase58()], commitment, void 0, {
      ...config,
      epoch: epoch != null ? epoch : config?.epoch
    });
    const unsafeRes = await this._rpcRequest("getStakeActivation", args);
    const res = create(unsafeRes, jsonRpcResult(StakeActivationResult));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get Stake Activation ${publicKey2.toBase58()}`);
    }
    return res.result;
  }
  /**
   * Fetch all the accounts owned by the specified program id
   *
   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>}
   */
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  async getProgramAccounts(programId, configOrCommitment) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(configOrCommitment);
    const {
      encoding: encoding2,
      ...configWithoutEncoding
    } = config || {};
    const args = this._buildArgs([programId.toBase58()], commitment, encoding2 || "base64", {
      ...configWithoutEncoding,
      ...configWithoutEncoding.filters ? {
        filters: applyDefaultMemcmpEncodingToFilters(configWithoutEncoding.filters)
      } : null
    });
    const unsafeRes = await this._rpcRequest("getProgramAccounts", args);
    const baseSchema = array(KeyedAccountInfoResult);
    const res = configWithoutEncoding.withContext === true ? create(unsafeRes, jsonRpcResultAndContext(baseSchema)) : create(unsafeRes, jsonRpcResult(baseSchema));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);
    }
    return res.result;
  }
  /**
   * Fetch and parse all the accounts owned by the specified program id
   *
   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer | ParsedAccountData>}>>}
   */
  async getParsedProgramAccounts(programId, configOrCommitment) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(configOrCommitment);
    const args = this._buildArgs([programId.toBase58()], commitment, "jsonParsed", config);
    const unsafeRes = await this._rpcRequest("getProgramAccounts", args);
    const res = create(unsafeRes, jsonRpcResult(array(KeyedParsedAccountInfoResult)));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);
    }
    return res.result;
  }
  /** @deprecated Instead, call `confirmTransaction` and pass in {@link TransactionConfirmationStrategy} */
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  async confirmTransaction(strategy, commitment) {
    let rawSignature;
    if (typeof strategy == "string") {
      rawSignature = strategy;
    } else {
      const config = strategy;
      if (config.abortSignal?.aborted) {
        return Promise.reject(config.abortSignal.reason);
      }
      rawSignature = config.signature;
    }
    let decodedSignature;
    try {
      decodedSignature = bs58.decode(rawSignature);
    } catch (err) {
      throw new Error("signature must be base58 encoded: " + rawSignature);
    }
    assert(decodedSignature.length === 64, "signature has invalid length");
    if (typeof strategy === "string") {
      return await this.confirmTransactionUsingLegacyTimeoutStrategy({
        commitment: commitment || this.commitment,
        signature: rawSignature
      });
    } else if ("lastValidBlockHeight" in strategy) {
      return await this.confirmTransactionUsingBlockHeightExceedanceStrategy({
        commitment: commitment || this.commitment,
        strategy
      });
    } else {
      return await this.confirmTransactionUsingDurableNonceStrategy({
        commitment: commitment || this.commitment,
        strategy
      });
    }
  }
  getCancellationPromise(signal) {
    return new Promise((_2, reject) => {
      if (signal == null) {
        return;
      }
      if (signal.aborted) {
        reject(signal.reason);
      } else {
        signal.addEventListener("abort", () => {
          reject(signal.reason);
        });
      }
    });
  }
  getTransactionConfirmationPromise({
    commitment,
    signature: signature2
  }) {
    let signatureSubscriptionId;
    let disposeSignatureSubscriptionStateChangeObserver;
    let done = false;
    const confirmationPromise = new Promise((resolve, reject) => {
      try {
        signatureSubscriptionId = this.onSignature(signature2, (result, context) => {
          signatureSubscriptionId = void 0;
          const response = {
            context,
            value: result
          };
          resolve({
            __type: TransactionStatus.PROCESSED,
            response
          });
        }, commitment);
        const subscriptionSetupPromise = new Promise((resolveSubscriptionSetup) => {
          if (signatureSubscriptionId == null) {
            resolveSubscriptionSetup();
          } else {
            disposeSignatureSubscriptionStateChangeObserver = this._onSubscriptionStateChange(signatureSubscriptionId, (nextState) => {
              if (nextState === "subscribed") {
                resolveSubscriptionSetup();
              }
            });
          }
        });
        (async () => {
          await subscriptionSetupPromise;
          if (done) return;
          const response = await this.getSignatureStatus(signature2);
          if (done) return;
          if (response == null) {
            return;
          }
          const {
            context,
            value
          } = response;
          if (value == null) {
            return;
          }
          if (value?.err) {
            reject(value.err);
          } else {
            switch (commitment) {
              case "confirmed":
              case "single":
              case "singleGossip": {
                if (value.confirmationStatus === "processed") {
                  return;
                }
                break;
              }
              case "finalized":
              case "max":
              case "root": {
                if (value.confirmationStatus === "processed" || value.confirmationStatus === "confirmed") {
                  return;
                }
                break;
              }
              // exhaust enums to ensure full coverage
              case "processed":
              case "recent":
            }
            done = true;
            resolve({
              __type: TransactionStatus.PROCESSED,
              response: {
                context,
                value
              }
            });
          }
        })();
      } catch (err) {
        reject(err);
      }
    });
    const abortConfirmation = () => {
      if (disposeSignatureSubscriptionStateChangeObserver) {
        disposeSignatureSubscriptionStateChangeObserver();
        disposeSignatureSubscriptionStateChangeObserver = void 0;
      }
      if (signatureSubscriptionId != null) {
        this.removeSignatureListener(signatureSubscriptionId);
        signatureSubscriptionId = void 0;
      }
    };
    return {
      abortConfirmation,
      confirmationPromise
    };
  }
  async confirmTransactionUsingBlockHeightExceedanceStrategy({
    commitment,
    strategy: {
      abortSignal,
      lastValidBlockHeight,
      signature: signature2
    }
  }) {
    let done = false;
    const expiryPromise = new Promise((resolve) => {
      const checkBlockHeight = async () => {
        try {
          const blockHeight = await this.getBlockHeight(commitment);
          return blockHeight;
        } catch (_e) {
          return -1;
        }
      };
      (async () => {
        let currentBlockHeight = await checkBlockHeight();
        if (done) return;
        while (currentBlockHeight <= lastValidBlockHeight) {
          await sleep(1e3);
          if (done) return;
          currentBlockHeight = await checkBlockHeight();
          if (done) return;
        }
        resolve({
          __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED
        });
      })();
    });
    const {
      abortConfirmation,
      confirmationPromise
    } = this.getTransactionConfirmationPromise({
      commitment,
      signature: signature2
    });
    const cancellationPromise = this.getCancellationPromise(abortSignal);
    let result;
    try {
      const outcome = await Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);
      if (outcome.__type === TransactionStatus.PROCESSED) {
        result = outcome.response;
      } else {
        throw new TransactionExpiredBlockheightExceededError(signature2);
      }
    } finally {
      done = true;
      abortConfirmation();
    }
    return result;
  }
  async confirmTransactionUsingDurableNonceStrategy({
    commitment,
    strategy: {
      abortSignal,
      minContextSlot,
      nonceAccountPubkey,
      nonceValue,
      signature: signature2
    }
  }) {
    let done = false;
    const expiryPromise = new Promise((resolve) => {
      let currentNonceValue = nonceValue;
      let lastCheckedSlot = null;
      const getCurrentNonceValue = async () => {
        try {
          const {
            context,
            value: nonceAccount
          } = await this.getNonceAndContext(nonceAccountPubkey, {
            commitment,
            minContextSlot
          });
          lastCheckedSlot = context.slot;
          return nonceAccount?.nonce;
        } catch (e3) {
          return currentNonceValue;
        }
      };
      (async () => {
        currentNonceValue = await getCurrentNonceValue();
        if (done) return;
        while (true) {
          if (nonceValue !== currentNonceValue) {
            resolve({
              __type: TransactionStatus.NONCE_INVALID,
              slotInWhichNonceDidAdvance: lastCheckedSlot
            });
            return;
          }
          await sleep(2e3);
          if (done) return;
          currentNonceValue = await getCurrentNonceValue();
          if (done) return;
        }
      })();
    });
    const {
      abortConfirmation,
      confirmationPromise
    } = this.getTransactionConfirmationPromise({
      commitment,
      signature: signature2
    });
    const cancellationPromise = this.getCancellationPromise(abortSignal);
    let result;
    try {
      const outcome = await Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);
      if (outcome.__type === TransactionStatus.PROCESSED) {
        result = outcome.response;
      } else {
        let signatureStatus;
        while (true) {
          const status = await this.getSignatureStatus(signature2);
          if (status == null) {
            break;
          }
          if (status.context.slot < (outcome.slotInWhichNonceDidAdvance ?? minContextSlot)) {
            await sleep(400);
            continue;
          }
          signatureStatus = status;
          break;
        }
        if (signatureStatus?.value) {
          const commitmentForStatus = commitment || "finalized";
          const {
            confirmationStatus
          } = signatureStatus.value;
          switch (commitmentForStatus) {
            case "processed":
            case "recent":
              if (confirmationStatus !== "processed" && confirmationStatus !== "confirmed" && confirmationStatus !== "finalized") {
                throw new TransactionExpiredNonceInvalidError(signature2);
              }
              break;
            case "confirmed":
            case "single":
            case "singleGossip":
              if (confirmationStatus !== "confirmed" && confirmationStatus !== "finalized") {
                throw new TransactionExpiredNonceInvalidError(signature2);
              }
              break;
            case "finalized":
            case "max":
            case "root":
              if (confirmationStatus !== "finalized") {
                throw new TransactionExpiredNonceInvalidError(signature2);
              }
              break;
            default:
              /* @__PURE__ */ ((_2) => {
              })(commitmentForStatus);
          }
          result = {
            context: signatureStatus.context,
            value: {
              err: signatureStatus.value.err
            }
          };
        } else {
          throw new TransactionExpiredNonceInvalidError(signature2);
        }
      }
    } finally {
      done = true;
      abortConfirmation();
    }
    return result;
  }
  async confirmTransactionUsingLegacyTimeoutStrategy({
    commitment,
    signature: signature2
  }) {
    let timeoutId;
    const expiryPromise = new Promise((resolve) => {
      let timeoutMs = this._confirmTransactionInitialTimeout || 60 * 1e3;
      switch (commitment) {
        case "processed":
        case "recent":
        case "single":
        case "confirmed":
        case "singleGossip": {
          timeoutMs = this._confirmTransactionInitialTimeout || 30 * 1e3;
          break;
        }
      }
      timeoutId = setTimeout(() => resolve({
        __type: TransactionStatus.TIMED_OUT,
        timeoutMs
      }), timeoutMs);
    });
    const {
      abortConfirmation,
      confirmationPromise
    } = this.getTransactionConfirmationPromise({
      commitment,
      signature: signature2
    });
    let result;
    try {
      const outcome = await Promise.race([confirmationPromise, expiryPromise]);
      if (outcome.__type === TransactionStatus.PROCESSED) {
        result = outcome.response;
      } else {
        throw new TransactionExpiredTimeoutError(signature2, outcome.timeoutMs / 1e3);
      }
    } finally {
      clearTimeout(timeoutId);
      abortConfirmation();
    }
    return result;
  }
  /**
   * Return the list of nodes that are currently participating in the cluster
   */
  async getClusterNodes() {
    const unsafeRes = await this._rpcRequest("getClusterNodes", []);
    const res = create(unsafeRes, jsonRpcResult(array(ContactInfoResult)));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get cluster nodes");
    }
    return res.result;
  }
  /**
   * Return the list of nodes that are currently participating in the cluster
   */
  async getVoteAccounts(commitment) {
    const args = this._buildArgs([], commitment);
    const unsafeRes = await this._rpcRequest("getVoteAccounts", args);
    const res = create(unsafeRes, GetVoteAccounts);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get vote accounts");
    }
    return res.result;
  }
  /**
   * Fetch the current slot that the node is processing
   */
  async getSlot(commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([], commitment, void 0, config);
    const unsafeRes = await this._rpcRequest("getSlot", args);
    const res = create(unsafeRes, jsonRpcResult(number()));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get slot");
    }
    return res.result;
  }
  /**
   * Fetch the current slot leader of the cluster
   */
  async getSlotLeader(commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([], commitment, void 0, config);
    const unsafeRes = await this._rpcRequest("getSlotLeader", args);
    const res = create(unsafeRes, jsonRpcResult(string()));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get slot leader");
    }
    return res.result;
  }
  /**
   * Fetch `limit` number of slot leaders starting from `startSlot`
   *
   * @param startSlot fetch slot leaders starting from this slot
   * @param limit number of slot leaders to return
   */
  async getSlotLeaders(startSlot, limit) {
    const args = [startSlot, limit];
    const unsafeRes = await this._rpcRequest("getSlotLeaders", args);
    const res = create(unsafeRes, jsonRpcResult(array(PublicKeyFromString)));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get slot leaders");
    }
    return res.result;
  }
  /**
   * Fetch the current status of a signature
   */
  async getSignatureStatus(signature2, config) {
    const {
      context,
      value: values
    } = await this.getSignatureStatuses([signature2], config);
    assert(values.length === 1);
    const value = values[0];
    return {
      context,
      value
    };
  }
  /**
   * Fetch the current statuses of a batch of signatures
   */
  async getSignatureStatuses(signatures, config) {
    const params = [signatures];
    if (config) {
      params.push(config);
    }
    const unsafeRes = await this._rpcRequest("getSignatureStatuses", params);
    const res = create(unsafeRes, GetSignatureStatusesRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get signature status");
    }
    return res.result;
  }
  /**
   * Fetch the current transaction count of the cluster
   */
  async getTransactionCount(commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([], commitment, void 0, config);
    const unsafeRes = await this._rpcRequest("getTransactionCount", args);
    const res = create(unsafeRes, jsonRpcResult(number()));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get transaction count");
    }
    return res.result;
  }
  /**
   * Fetch the current total currency supply of the cluster in lamports
   *
   * @deprecated Deprecated since RPC v1.2.8. Please use {@link getSupply} instead.
   */
  async getTotalSupply(commitment) {
    const result = await this.getSupply({
      commitment,
      excludeNonCirculatingAccountsList: true
    });
    return result.value.total;
  }
  /**
   * Fetch the cluster InflationGovernor parameters
   */
  async getInflationGovernor(commitment) {
    const args = this._buildArgs([], commitment);
    const unsafeRes = await this._rpcRequest("getInflationGovernor", args);
    const res = create(unsafeRes, GetInflationGovernorRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get inflation");
    }
    return res.result;
  }
  /**
   * Fetch the inflation reward for a list of addresses for an epoch
   */
  async getInflationReward(addresses, epoch, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([addresses.map((pubkey) => pubkey.toBase58())], commitment, void 0, {
      ...config,
      epoch: epoch != null ? epoch : config?.epoch
    });
    const unsafeRes = await this._rpcRequest("getInflationReward", args);
    const res = create(unsafeRes, GetInflationRewardResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get inflation reward");
    }
    return res.result;
  }
  /**
   * Fetch the specific inflation values for the current epoch
   */
  async getInflationRate() {
    const unsafeRes = await this._rpcRequest("getInflationRate", []);
    const res = create(unsafeRes, GetInflationRateRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get inflation rate");
    }
    return res.result;
  }
  /**
   * Fetch the Epoch Info parameters
   */
  async getEpochInfo(commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([], commitment, void 0, config);
    const unsafeRes = await this._rpcRequest("getEpochInfo", args);
    const res = create(unsafeRes, GetEpochInfoRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get epoch info");
    }
    return res.result;
  }
  /**
   * Fetch the Epoch Schedule parameters
   */
  async getEpochSchedule() {
    const unsafeRes = await this._rpcRequest("getEpochSchedule", []);
    const res = create(unsafeRes, GetEpochScheduleRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get epoch schedule");
    }
    const epochSchedule = res.result;
    return new EpochSchedule(epochSchedule.slotsPerEpoch, epochSchedule.leaderScheduleSlotOffset, epochSchedule.warmup, epochSchedule.firstNormalEpoch, epochSchedule.firstNormalSlot);
  }
  /**
   * Fetch the leader schedule for the current epoch
   * @return {Promise<RpcResponseAndContext<LeaderSchedule>>}
   */
  async getLeaderSchedule() {
    const unsafeRes = await this._rpcRequest("getLeaderSchedule", []);
    const res = create(unsafeRes, GetLeaderScheduleRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get leader schedule");
    }
    return res.result;
  }
  /**
   * Fetch the minimum balance needed to exempt an account of `dataLength`
   * size from rent
   */
  async getMinimumBalanceForRentExemption(dataLength, commitment) {
    const args = this._buildArgs([dataLength], commitment);
    const unsafeRes = await this._rpcRequest("getMinimumBalanceForRentExemption", args);
    const res = create(unsafeRes, GetMinimumBalanceForRentExemptionRpcResult);
    if ("error" in res) {
      console.warn("Unable to fetch minimum balance for rent exemption");
      return 0;
    }
    return res.result;
  }
  /**
   * Fetch a recent blockhash from the cluster, return with context
   * @return {Promise<RpcResponseAndContext<{blockhash: Blockhash, feeCalculator: FeeCalculator}>>}
   *
   * @deprecated Deprecated since RPC v1.9.0. Please use {@link getLatestBlockhash} instead.
   */
  async getRecentBlockhashAndContext(commitment) {
    const {
      context,
      value: {
        blockhash
      }
    } = await this.getLatestBlockhashAndContext(commitment);
    const feeCalculator = {
      get lamportsPerSignature() {
        throw new Error("The capability to fetch `lamportsPerSignature` using the `getRecentBlockhash` API is no longer offered by the network. Use the `getFeeForMessage` API to obtain the fee for a given message.");
      },
      toJSON() {
        return {};
      }
    };
    return {
      context,
      value: {
        blockhash,
        feeCalculator
      }
    };
  }
  /**
   * Fetch recent performance samples
   * @return {Promise<Array<PerfSample>>}
   */
  async getRecentPerformanceSamples(limit) {
    const unsafeRes = await this._rpcRequest("getRecentPerformanceSamples", limit ? [limit] : []);
    const res = create(unsafeRes, GetRecentPerformanceSamplesRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get recent performance samples");
    }
    return res.result;
  }
  /**
   * Fetch the fee calculator for a recent blockhash from the cluster, return with context
   *
   * @deprecated Deprecated since RPC v1.9.0. Please use {@link getFeeForMessage} instead.
   */
  async getFeeCalculatorForBlockhash(blockhash, commitment) {
    const args = this._buildArgs([blockhash], commitment);
    const unsafeRes = await this._rpcRequest("getFeeCalculatorForBlockhash", args);
    const res = create(unsafeRes, GetFeeCalculatorRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get fee calculator");
    }
    const {
      context,
      value
    } = res.result;
    return {
      context,
      value: value !== null ? value.feeCalculator : null
    };
  }
  /**
   * Fetch the fee for a message from the cluster, return with context
   */
  async getFeeForMessage(message, commitment) {
    const wireMessage = toBuffer(message.serialize()).toString("base64");
    const args = this._buildArgs([wireMessage], commitment);
    const unsafeRes = await this._rpcRequest("getFeeForMessage", args);
    const res = create(unsafeRes, jsonRpcResultAndContext(nullable(number())));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get fee for message");
    }
    if (res.result === null) {
      throw new Error("invalid blockhash");
    }
    return res.result;
  }
  /**
   * Fetch a list of prioritization fees from recent blocks.
   */
  async getRecentPrioritizationFees(config) {
    const accounts = config?.lockedWritableAccounts?.map((key) => key.toBase58());
    const args = accounts?.length ? [accounts] : [];
    const unsafeRes = await this._rpcRequest("getRecentPrioritizationFees", args);
    const res = create(unsafeRes, GetRecentPrioritizationFeesRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get recent prioritization fees");
    }
    return res.result;
  }
  /**
   * Fetch a recent blockhash from the cluster
   * @return {Promise<{blockhash: Blockhash, feeCalculator: FeeCalculator}>}
   *
   * @deprecated Deprecated since RPC v1.8.0. Please use {@link getLatestBlockhash} instead.
   */
  async getRecentBlockhash(commitment) {
    try {
      const res = await this.getRecentBlockhashAndContext(commitment);
      return res.value;
    } catch (e3) {
      throw new Error("failed to get recent blockhash: " + e3);
    }
  }
  /**
   * Fetch the latest blockhash from the cluster
   * @return {Promise<BlockhashWithExpiryBlockHeight>}
   */
  async getLatestBlockhash(commitmentOrConfig) {
    try {
      const res = await this.getLatestBlockhashAndContext(commitmentOrConfig);
      return res.value;
    } catch (e3) {
      throw new Error("failed to get recent blockhash: " + e3);
    }
  }
  /**
   * Fetch the latest blockhash from the cluster
   * @return {Promise<BlockhashWithExpiryBlockHeight>}
   */
  async getLatestBlockhashAndContext(commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs([], commitment, void 0, config);
    const unsafeRes = await this._rpcRequest("getLatestBlockhash", args);
    const res = create(unsafeRes, GetLatestBlockhashRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get latest blockhash");
    }
    return res.result;
  }
  /**
   * Returns whether a blockhash is still valid or not
   */
  async isBlockhashValid(blockhash, rawConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(rawConfig);
    const args = this._buildArgs([blockhash], commitment, void 0, config);
    const unsafeRes = await this._rpcRequest("isBlockhashValid", args);
    const res = create(unsafeRes, IsBlockhashValidRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to determine if the blockhash `" + blockhash + "`is valid");
    }
    return res.result;
  }
  /**
   * Fetch the node version
   */
  async getVersion() {
    const unsafeRes = await this._rpcRequest("getVersion", []);
    const res = create(unsafeRes, jsonRpcResult(VersionResult));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get version");
    }
    return res.result;
  }
  /**
   * Fetch the genesis hash
   */
  async getGenesisHash() {
    const unsafeRes = await this._rpcRequest("getGenesisHash", []);
    const res = create(unsafeRes, jsonRpcResult(string()));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get genesis hash");
    }
    return res.result;
  }
  /**
   * Fetch a processed block from the cluster.
   *
   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
   * setting the `maxSupportedTransactionVersion` property.
   */
  /**
   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
   * setting the `maxSupportedTransactionVersion` property.
   */
  // eslint-disable-next-line no-dupe-class-members
  /**
   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
   * setting the `maxSupportedTransactionVersion` property.
   */
  // eslint-disable-next-line no-dupe-class-members
  /**
   * Fetch a processed block from the cluster.
   */
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  /**
   * Fetch a processed block from the cluster.
   */
  // eslint-disable-next-line no-dupe-class-members
  async getBlock(slot, rawConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(rawConfig);
    const args = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, config);
    const unsafeRes = await this._rpcRequest("getBlock", args);
    try {
      switch (config?.transactionDetails) {
        case "accounts": {
          const res = create(unsafeRes, GetAccountsModeBlockRpcResult);
          if ("error" in res) {
            throw res.error;
          }
          return res.result;
        }
        case "none": {
          const res = create(unsafeRes, GetNoneModeBlockRpcResult);
          if ("error" in res) {
            throw res.error;
          }
          return res.result;
        }
        default: {
          const res = create(unsafeRes, GetBlockRpcResult);
          if ("error" in res) {
            throw res.error;
          }
          const {
            result
          } = res;
          return result ? {
            ...result,
            transactions: result.transactions.map(({
              transaction,
              meta,
              version: version2
            }) => ({
              meta,
              transaction: {
                ...transaction,
                message: versionedMessageFromResponse(version2, transaction.message)
              },
              version: version2
            }))
          } : null;
        }
      }
    } catch (e3) {
      throw new SolanaJSONRPCError(e3, "failed to get confirmed block");
    }
  }
  /**
   * Fetch parsed transaction details for a confirmed or finalized block
   */
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  async getParsedBlock(slot, rawConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(rawConfig);
    const args = this._buildArgsAtLeastConfirmed([slot], commitment, "jsonParsed", config);
    const unsafeRes = await this._rpcRequest("getBlock", args);
    try {
      switch (config?.transactionDetails) {
        case "accounts": {
          const res = create(unsafeRes, GetParsedAccountsModeBlockRpcResult);
          if ("error" in res) {
            throw res.error;
          }
          return res.result;
        }
        case "none": {
          const res = create(unsafeRes, GetParsedNoneModeBlockRpcResult);
          if ("error" in res) {
            throw res.error;
          }
          return res.result;
        }
        default: {
          const res = create(unsafeRes, GetParsedBlockRpcResult);
          if ("error" in res) {
            throw res.error;
          }
          return res.result;
        }
      }
    } catch (e3) {
      throw new SolanaJSONRPCError(e3, "failed to get block");
    }
  }
  /*
   * Returns recent block production information from the current or previous epoch
   */
  async getBlockProduction(configOrCommitment) {
    let extra;
    let commitment;
    if (typeof configOrCommitment === "string") {
      commitment = configOrCommitment;
    } else if (configOrCommitment) {
      const {
        commitment: c,
        ...rest
      } = configOrCommitment;
      commitment = c;
      extra = rest;
    }
    const args = this._buildArgs([], commitment, "base64", extra);
    const unsafeRes = await this._rpcRequest("getBlockProduction", args);
    const res = create(unsafeRes, BlockProductionResponseStruct);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get block production information");
    }
    return res.result;
  }
  /**
   * Fetch a confirmed or finalized transaction from the cluster.
   *
   * @deprecated Instead, call `getTransaction` using a
   * `GetVersionedTransactionConfig` by setting the
   * `maxSupportedTransactionVersion` property.
   */
  /**
   * Fetch a confirmed or finalized transaction from the cluster.
   */
  // eslint-disable-next-line no-dupe-class-members
  /**
   * Fetch a confirmed or finalized transaction from the cluster.
   */
  // eslint-disable-next-line no-dupe-class-members
  async getTransaction(signature2, rawConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(rawConfig);
    const args = this._buildArgsAtLeastConfirmed([signature2], commitment, void 0, config);
    const unsafeRes = await this._rpcRequest("getTransaction", args);
    const res = create(unsafeRes, GetTransactionRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get transaction");
    }
    const result = res.result;
    if (!result) return result;
    return {
      ...result,
      transaction: {
        ...result.transaction,
        message: versionedMessageFromResponse(result.version, result.transaction.message)
      }
    };
  }
  /**
   * Fetch parsed transaction details for a confirmed or finalized transaction
   */
  async getParsedTransaction(signature2, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed", config);
    const unsafeRes = await this._rpcRequest("getTransaction", args);
    const res = create(unsafeRes, GetParsedTransactionRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get transaction");
    }
    return res.result;
  }
  /**
   * Fetch parsed transaction details for a batch of confirmed transactions
   */
  async getParsedTransactions(signatures, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const batch = signatures.map((signature2) => {
      const args = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed", config);
      return {
        methodName: "getTransaction",
        args
      };
    });
    const unsafeRes = await this._rpcBatchRequest(batch);
    const res = unsafeRes.map((unsafeRes2) => {
      const res2 = create(unsafeRes2, GetParsedTransactionRpcResult);
      if ("error" in res2) {
        throw new SolanaJSONRPCError(res2.error, "failed to get transactions");
      }
      return res2.result;
    });
    return res;
  }
  /**
   * Fetch transaction details for a batch of confirmed transactions.
   * Similar to {@link getParsedTransactions} but returns a {@link TransactionResponse}.
   *
   * @deprecated Instead, call `getTransactions` using a
   * `GetVersionedTransactionConfig` by setting the
   * `maxSupportedTransactionVersion` property.
   */
  /**
   * Fetch transaction details for a batch of confirmed transactions.
   * Similar to {@link getParsedTransactions} but returns a {@link
   * VersionedTransactionResponse}.
   */
  // eslint-disable-next-line no-dupe-class-members
  /**
   * Fetch transaction details for a batch of confirmed transactions.
   * Similar to {@link getParsedTransactions} but returns a {@link
   * VersionedTransactionResponse}.
   */
  // eslint-disable-next-line no-dupe-class-members
  async getTransactions(signatures, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const batch = signatures.map((signature2) => {
      const args = this._buildArgsAtLeastConfirmed([signature2], commitment, void 0, config);
      return {
        methodName: "getTransaction",
        args
      };
    });
    const unsafeRes = await this._rpcBatchRequest(batch);
    const res = unsafeRes.map((unsafeRes2) => {
      const res2 = create(unsafeRes2, GetTransactionRpcResult);
      if ("error" in res2) {
        throw new SolanaJSONRPCError(res2.error, "failed to get transactions");
      }
      const result = res2.result;
      if (!result) return result;
      return {
        ...result,
        transaction: {
          ...result.transaction,
          message: versionedMessageFromResponse(result.version, result.transaction.message)
        }
      };
    });
    return res;
  }
  /**
   * Fetch a list of Transactions and transaction statuses from the cluster
   * for a confirmed block.
   *
   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getBlock} instead.
   */
  async getConfirmedBlock(slot, commitment) {
    const args = this._buildArgsAtLeastConfirmed([slot], commitment);
    const unsafeRes = await this._rpcRequest("getBlock", args);
    const res = create(unsafeRes, GetConfirmedBlockRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get confirmed block");
    }
    const result = res.result;
    if (!result) {
      throw new Error("Confirmed block " + slot + " not found");
    }
    const block = {
      ...result,
      transactions: result.transactions.map(({
        transaction,
        meta
      }) => {
        const message = new Message(transaction.message);
        return {
          meta,
          transaction: {
            ...transaction,
            message
          }
        };
      })
    };
    return {
      ...block,
      transactions: block.transactions.map(({
        transaction,
        meta
      }) => {
        return {
          meta,
          transaction: Transaction.populate(transaction.message, transaction.signatures)
        };
      })
    };
  }
  /**
   * Fetch confirmed blocks between two slots
   */
  async getBlocks(startSlot, endSlot, commitment) {
    const args = this._buildArgsAtLeastConfirmed(endSlot !== void 0 ? [startSlot, endSlot] : [startSlot], commitment);
    const unsafeRes = await this._rpcRequest("getBlocks", args);
    const res = create(unsafeRes, jsonRpcResult(array(number())));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get blocks");
    }
    return res.result;
  }
  /**
   * Fetch a list of Signatures from the cluster for a block, excluding rewards
   */
  async getBlockSignatures(slot, commitment) {
    const args = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, {
      transactionDetails: "signatures",
      rewards: false
    });
    const unsafeRes = await this._rpcRequest("getBlock", args);
    const res = create(unsafeRes, GetBlockSignaturesRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get block");
    }
    const result = res.result;
    if (!result) {
      throw new Error("Block " + slot + " not found");
    }
    return result;
  }
  /**
   * Fetch a list of Signatures from the cluster for a confirmed block, excluding rewards
   *
   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getBlockSignatures} instead.
   */
  async getConfirmedBlockSignatures(slot, commitment) {
    const args = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, {
      transactionDetails: "signatures",
      rewards: false
    });
    const unsafeRes = await this._rpcRequest("getBlock", args);
    const res = create(unsafeRes, GetBlockSignaturesRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get confirmed block");
    }
    const result = res.result;
    if (!result) {
      throw new Error("Confirmed block " + slot + " not found");
    }
    return result;
  }
  /**
   * Fetch a transaction details for a confirmed transaction
   *
   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getTransaction} instead.
   */
  async getConfirmedTransaction(signature2, commitment) {
    const args = this._buildArgsAtLeastConfirmed([signature2], commitment);
    const unsafeRes = await this._rpcRequest("getTransaction", args);
    const res = create(unsafeRes, GetTransactionRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get transaction");
    }
    const result = res.result;
    if (!result) return result;
    const message = new Message(result.transaction.message);
    const signatures = result.transaction.signatures;
    return {
      ...result,
      transaction: Transaction.populate(message, signatures)
    };
  }
  /**
   * Fetch parsed transaction details for a confirmed transaction
   *
   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getParsedTransaction} instead.
   */
  async getParsedConfirmedTransaction(signature2, commitment) {
    const args = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed");
    const unsafeRes = await this._rpcRequest("getTransaction", args);
    const res = create(unsafeRes, GetParsedTransactionRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get confirmed transaction");
    }
    return res.result;
  }
  /**
   * Fetch parsed transaction details for a batch of confirmed transactions
   *
   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getParsedTransactions} instead.
   */
  async getParsedConfirmedTransactions(signatures, commitment) {
    const batch = signatures.map((signature2) => {
      const args = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed");
      return {
        methodName: "getTransaction",
        args
      };
    });
    const unsafeRes = await this._rpcBatchRequest(batch);
    const res = unsafeRes.map((unsafeRes2) => {
      const res2 = create(unsafeRes2, GetParsedTransactionRpcResult);
      if ("error" in res2) {
        throw new SolanaJSONRPCError(res2.error, "failed to get confirmed transactions");
      }
      return res2.result;
    });
    return res;
  }
  /**
   * Fetch a list of all the confirmed signatures for transactions involving an address
   * within a specified slot range. Max range allowed is 10,000 slots.
   *
   * @deprecated Deprecated since RPC v1.3. Please use {@link getConfirmedSignaturesForAddress2} instead.
   *
   * @param address queried address
   * @param startSlot start slot, inclusive
   * @param endSlot end slot, inclusive
   */
  async getConfirmedSignaturesForAddress(address, startSlot, endSlot) {
    let options = {};
    let firstAvailableBlock = await this.getFirstAvailableBlock();
    while (!("until" in options)) {
      startSlot--;
      if (startSlot <= 0 || startSlot < firstAvailableBlock) {
        break;
      }
      try {
        const block = await this.getConfirmedBlockSignatures(startSlot, "finalized");
        if (block.signatures.length > 0) {
          options.until = block.signatures[block.signatures.length - 1].toString();
        }
      } catch (err) {
        if (err instanceof Error && err.message.includes("skipped")) {
          continue;
        } else {
          throw err;
        }
      }
    }
    let highestConfirmedRoot = await this.getSlot("finalized");
    while (!("before" in options)) {
      endSlot++;
      if (endSlot > highestConfirmedRoot) {
        break;
      }
      try {
        const block = await this.getConfirmedBlockSignatures(endSlot);
        if (block.signatures.length > 0) {
          options.before = block.signatures[block.signatures.length - 1].toString();
        }
      } catch (err) {
        if (err instanceof Error && err.message.includes("skipped")) {
          continue;
        } else {
          throw err;
        }
      }
    }
    const confirmedSignatureInfo = await this.getConfirmedSignaturesForAddress2(address, options);
    return confirmedSignatureInfo.map((info) => info.signature);
  }
  /**
   * Returns confirmed signatures for transactions involving an
   * address backwards in time from the provided signature or most recent confirmed block
   *
   * @deprecated Deprecated since RPC v1.7.0. Please use {@link getSignaturesForAddress} instead.
   */
  async getConfirmedSignaturesForAddress2(address, options, commitment) {
    const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, void 0, options);
    const unsafeRes = await this._rpcRequest("getConfirmedSignaturesForAddress2", args);
    const res = create(unsafeRes, GetConfirmedSignaturesForAddress2RpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get confirmed signatures for address");
    }
    return res.result;
  }
  /**
   * Returns confirmed signatures for transactions involving an
   * address backwards in time from the provided signature or most recent confirmed block
   *
   *
   * @param address queried address
   * @param options
   */
  async getSignaturesForAddress(address, options, commitment) {
    const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, void 0, options);
    const unsafeRes = await this._rpcRequest("getSignaturesForAddress", args);
    const res = create(unsafeRes, GetSignaturesForAddressRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, "failed to get signatures for address");
    }
    return res.result;
  }
  async getAddressLookupTable(accountKey, config) {
    const {
      context,
      value: accountInfo
    } = await this.getAccountInfoAndContext(accountKey, config);
    let value = null;
    if (accountInfo !== null) {
      value = new AddressLookupTableAccount({
        key: accountKey,
        state: AddressLookupTableAccount.deserialize(accountInfo.data)
      });
    }
    return {
      context,
      value
    };
  }
  /**
   * Fetch the contents of a Nonce account from the cluster, return with context
   */
  async getNonceAndContext(nonceAccount, commitmentOrConfig) {
    const {
      context,
      value: accountInfo
    } = await this.getAccountInfoAndContext(nonceAccount, commitmentOrConfig);
    let value = null;
    if (accountInfo !== null) {
      value = NonceAccount.fromAccountData(accountInfo.data);
    }
    return {
      context,
      value
    };
  }
  /**
   * Fetch the contents of a Nonce account from the cluster
   */
  async getNonce(nonceAccount, commitmentOrConfig) {
    return await this.getNonceAndContext(nonceAccount, commitmentOrConfig).then((x2) => x2.value).catch((e3) => {
      throw new Error("failed to get nonce for account " + nonceAccount.toBase58() + ": " + e3);
    });
  }
  /**
   * Request an allocation of lamports to the specified address
   *
   * ```typescript
   * import { Connection, PublicKey, LAMPORTS_PER_SOL } from "@solana/web3.js";
   *
   * (async () => {
   *   const connection = new Connection("https://api.testnet.solana.com", "confirmed");
   *   const myAddress = new PublicKey("2nr1bHFT86W9tGnyvmYW4vcHKsQB3sVQfnddasz4kExM");
   *   const signature = await connection.requestAirdrop(myAddress, LAMPORTS_PER_SOL);
   *   await connection.confirmTransaction(signature);
   * })();
   * ```
   */
  async requestAirdrop(to, lamports) {
    const unsafeRes = await this._rpcRequest("requestAirdrop", [to.toBase58(), lamports]);
    const res = create(unsafeRes, RequestAirdropRpcResult);
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `airdrop to ${to.toBase58()} failed`);
    }
    return res.result;
  }
  /**
   * @internal
   */
  async _blockhashWithExpiryBlockHeight(disableCache) {
    if (!disableCache) {
      while (this._pollingBlockhash) {
        await sleep(100);
      }
      const timeSinceFetch = Date.now() - this._blockhashInfo.lastFetch;
      const expired = timeSinceFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;
      if (this._blockhashInfo.latestBlockhash !== null && !expired) {
        return this._blockhashInfo.latestBlockhash;
      }
    }
    return await this._pollNewBlockhash();
  }
  /**
   * @internal
   */
  async _pollNewBlockhash() {
    this._pollingBlockhash = true;
    try {
      const startTime = Date.now();
      const cachedLatestBlockhash = this._blockhashInfo.latestBlockhash;
      const cachedBlockhash = cachedLatestBlockhash ? cachedLatestBlockhash.blockhash : null;
      for (let i = 0; i < 50; i++) {
        const latestBlockhash = await this.getLatestBlockhash("finalized");
        if (cachedBlockhash !== latestBlockhash.blockhash) {
          this._blockhashInfo = {
            latestBlockhash,
            lastFetch: Date.now(),
            transactionSignatures: [],
            simulatedSignatures: []
          };
          return latestBlockhash;
        }
        await sleep(MS_PER_SLOT / 2);
      }
      throw new Error(`Unable to obtain a new blockhash after ${Date.now() - startTime}ms`);
    } finally {
      this._pollingBlockhash = false;
    }
  }
  /**
   * get the stake minimum delegation
   */
  async getStakeMinimumDelegation(config) {
    const {
      commitment,
      config: configArg
    } = extractCommitmentFromConfig(config);
    const args = this._buildArgs([], commitment, "base64", configArg);
    const unsafeRes = await this._rpcRequest("getStakeMinimumDelegation", args);
    const res = create(unsafeRes, jsonRpcResultAndContext(number()));
    if ("error" in res) {
      throw new SolanaJSONRPCError(res.error, `failed to get stake minimum delegation`);
    }
    return res.result;
  }
  /**
   * Simulate a transaction
   *
   * @deprecated Instead, call {@link simulateTransaction} with {@link
   * VersionedTransaction} and {@link SimulateTransactionConfig} parameters
   */
  /**
   * Simulate a transaction
   */
  // eslint-disable-next-line no-dupe-class-members
  /**
   * Simulate a transaction
   */
  // eslint-disable-next-line no-dupe-class-members
  async simulateTransaction(transactionOrMessage, configOrSigners, includeAccounts) {
    if ("message" in transactionOrMessage) {
      const versionedTx = transactionOrMessage;
      const wireTransaction2 = versionedTx.serialize();
      const encodedTransaction2 = bufferExports.Buffer.from(wireTransaction2).toString("base64");
      if (Array.isArray(configOrSigners) || includeAccounts !== void 0) {
        throw new Error("Invalid arguments");
      }
      const config2 = configOrSigners || {};
      config2.encoding = "base64";
      if (!("commitment" in config2)) {
        config2.commitment = this.commitment;
      }
      if (configOrSigners && typeof configOrSigners === "object" && "innerInstructions" in configOrSigners) {
        config2.innerInstructions = configOrSigners.innerInstructions;
      }
      const args2 = [encodedTransaction2, config2];
      const unsafeRes2 = await this._rpcRequest("simulateTransaction", args2);
      const res2 = create(unsafeRes2, SimulatedTransactionResponseStruct);
      if ("error" in res2) {
        throw new Error("failed to simulate transaction: " + res2.error.message);
      }
      return res2.result;
    }
    let transaction;
    if (transactionOrMessage instanceof Transaction) {
      let originalTx = transactionOrMessage;
      transaction = new Transaction();
      transaction.feePayer = originalTx.feePayer;
      transaction.instructions = transactionOrMessage.instructions;
      transaction.nonceInfo = originalTx.nonceInfo;
      transaction.signatures = originalTx.signatures;
    } else {
      transaction = Transaction.populate(transactionOrMessage);
      transaction._message = transaction._json = void 0;
    }
    if (configOrSigners !== void 0 && !Array.isArray(configOrSigners)) {
      throw new Error("Invalid arguments");
    }
    const signers = configOrSigners;
    if (transaction.nonceInfo && signers) {
      transaction.sign(...signers);
    } else {
      let disableCache = this._disableBlockhashCaching;
      for (; ; ) {
        const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);
        transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
        transaction.recentBlockhash = latestBlockhash.blockhash;
        if (!signers) break;
        transaction.sign(...signers);
        if (!transaction.signature) {
          throw new Error("!signature");
        }
        const signature2 = transaction.signature.toString("base64");
        if (!this._blockhashInfo.simulatedSignatures.includes(signature2) && !this._blockhashInfo.transactionSignatures.includes(signature2)) {
          this._blockhashInfo.simulatedSignatures.push(signature2);
          break;
        } else {
          disableCache = true;
        }
      }
    }
    const message = transaction._compile();
    const signData = message.serialize();
    const wireTransaction = transaction._serialize(signData);
    const encodedTransaction = wireTransaction.toString("base64");
    const config = {
      encoding: "base64",
      commitment: this.commitment
    };
    if (includeAccounts) {
      const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map((key) => key.toBase58());
      config["accounts"] = {
        encoding: "base64",
        addresses
      };
    }
    if (signers) {
      config.sigVerify = true;
    }
    if (configOrSigners && typeof configOrSigners === "object" && "innerInstructions" in configOrSigners) {
      config.innerInstructions = configOrSigners.innerInstructions;
    }
    const args = [encodedTransaction, config];
    const unsafeRes = await this._rpcRequest("simulateTransaction", args);
    const res = create(unsafeRes, SimulatedTransactionResponseStruct);
    if ("error" in res) {
      let logs;
      if ("data" in res.error) {
        logs = res.error.data.logs;
        if (logs && Array.isArray(logs)) {
          const traceIndent = "\n    ";
          const logTrace = traceIndent + logs.join(traceIndent);
          console.error(res.error.message, logTrace);
        }
      }
      throw new SendTransactionError({
        action: "simulate",
        signature: "",
        transactionMessage: res.error.message,
        logs
      });
    }
    return res.result;
  }
  /**
   * Sign and send a transaction
   *
   * @deprecated Instead, call {@link sendTransaction} with a {@link
   * VersionedTransaction}
   */
  /**
   * Send a signed transaction
   */
  // eslint-disable-next-line no-dupe-class-members
  /**
   * Sign and send a transaction
   */
  // eslint-disable-next-line no-dupe-class-members
  async sendTransaction(transaction, signersOrOptions, options) {
    if ("version" in transaction) {
      if (signersOrOptions && Array.isArray(signersOrOptions)) {
        throw new Error("Invalid arguments");
      }
      const wireTransaction2 = transaction.serialize();
      return await this.sendRawTransaction(wireTransaction2, signersOrOptions);
    }
    if (signersOrOptions === void 0 || !Array.isArray(signersOrOptions)) {
      throw new Error("Invalid arguments");
    }
    const signers = signersOrOptions;
    if (transaction.nonceInfo) {
      transaction.sign(...signers);
    } else {
      let disableCache = this._disableBlockhashCaching;
      for (; ; ) {
        const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);
        transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
        transaction.recentBlockhash = latestBlockhash.blockhash;
        transaction.sign(...signers);
        if (!transaction.signature) {
          throw new Error("!signature");
        }
        const signature2 = transaction.signature.toString("base64");
        if (!this._blockhashInfo.transactionSignatures.includes(signature2)) {
          this._blockhashInfo.transactionSignatures.push(signature2);
          break;
        } else {
          disableCache = true;
        }
      }
    }
    const wireTransaction = transaction.serialize();
    return await this.sendRawTransaction(wireTransaction, options);
  }
  /**
   * Send a transaction that has already been signed and serialized into the
   * wire format
   */
  async sendRawTransaction(rawTransaction, options) {
    const encodedTransaction = toBuffer(rawTransaction).toString("base64");
    const result = await this.sendEncodedTransaction(encodedTransaction, options);
    return result;
  }
  /**
   * Send a transaction that has already been signed, serialized into the
   * wire format, and encoded as a base64 string
   */
  async sendEncodedTransaction(encodedTransaction, options) {
    const config = {
      encoding: "base64"
    };
    const skipPreflight = options && options.skipPreflight;
    const preflightCommitment = skipPreflight === true ? "processed" : options && options.preflightCommitment || this.commitment;
    if (options && options.maxRetries != null) {
      config.maxRetries = options.maxRetries;
    }
    if (options && options.minContextSlot != null) {
      config.minContextSlot = options.minContextSlot;
    }
    if (skipPreflight) {
      config.skipPreflight = skipPreflight;
    }
    if (preflightCommitment) {
      config.preflightCommitment = preflightCommitment;
    }
    const args = [encodedTransaction, config];
    const unsafeRes = await this._rpcRequest("sendTransaction", args);
    const res = create(unsafeRes, SendTransactionRpcResult);
    if ("error" in res) {
      let logs = void 0;
      if ("data" in res.error) {
        logs = res.error.data.logs;
      }
      throw new SendTransactionError({
        action: skipPreflight ? "send" : "simulate",
        signature: "",
        transactionMessage: res.error.message,
        logs
      });
    }
    return res.result;
  }
  /**
   * @internal
   */
  _wsOnOpen() {
    this._rpcWebSocketConnected = true;
    this._rpcWebSocketHeartbeat = setInterval(() => {
      (async () => {
        try {
          await this._rpcWebSocket.notify("ping");
        } catch {
        }
      })();
    }, 5e3);
    this._updateSubscriptions();
  }
  /**
   * @internal
   */
  _wsOnError(err) {
    this._rpcWebSocketConnected = false;
    console.error("ws error:", err.message);
  }
  /**
   * @internal
   */
  _wsOnClose(code) {
    this._rpcWebSocketConnected = false;
    this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER;
    if (this._rpcWebSocketIdleTimeout) {
      clearTimeout(this._rpcWebSocketIdleTimeout);
      this._rpcWebSocketIdleTimeout = null;
    }
    if (this._rpcWebSocketHeartbeat) {
      clearInterval(this._rpcWebSocketHeartbeat);
      this._rpcWebSocketHeartbeat = null;
    }
    if (code === 1e3) {
      this._updateSubscriptions();
      return;
    }
    this._subscriptionCallbacksByServerSubscriptionId = {};
    Object.entries(this._subscriptionsByHash).forEach(([hash, subscription]) => {
      this._setSubscription(hash, {
        ...subscription,
        state: "pending"
      });
    });
  }
  /**
   * @internal
   */
  _setSubscription(hash, nextSubscription) {
    const prevState = this._subscriptionsByHash[hash]?.state;
    this._subscriptionsByHash[hash] = nextSubscription;
    if (prevState !== nextSubscription.state) {
      const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash];
      if (stateChangeCallbacks) {
        stateChangeCallbacks.forEach((cb) => {
          try {
            cb(nextSubscription.state);
          } catch {
          }
        });
      }
    }
  }
  /**
   * @internal
   */
  _onSubscriptionStateChange(clientSubscriptionId, callback) {
    var _a2;
    const hash = this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
    if (hash == null) {
      return () => {
      };
    }
    const stateChangeCallbacks = (_a2 = this._subscriptionStateChangeCallbacksByHash)[hash] || (_a2[hash] = /* @__PURE__ */ new Set());
    stateChangeCallbacks.add(callback);
    return () => {
      stateChangeCallbacks.delete(callback);
      if (stateChangeCallbacks.size === 0) {
        delete this._subscriptionStateChangeCallbacksByHash[hash];
      }
    };
  }
  /**
   * @internal
   */
  async _updateSubscriptions() {
    if (Object.keys(this._subscriptionsByHash).length === 0) {
      if (this._rpcWebSocketConnected) {
        this._rpcWebSocketConnected = false;
        this._rpcWebSocketIdleTimeout = setTimeout(() => {
          this._rpcWebSocketIdleTimeout = null;
          try {
            this._rpcWebSocket.close();
          } catch (err) {
            if (err instanceof Error) {
              console.log(`Error when closing socket connection: ${err.message}`);
            }
          }
        }, 500);
      }
      return;
    }
    if (this._rpcWebSocketIdleTimeout !== null) {
      clearTimeout(this._rpcWebSocketIdleTimeout);
      this._rpcWebSocketIdleTimeout = null;
      this._rpcWebSocketConnected = true;
    }
    if (!this._rpcWebSocketConnected) {
      this._rpcWebSocket.connect();
      return;
    }
    const activeWebSocketGeneration = this._rpcWebSocketGeneration;
    const isCurrentConnectionStillActive = () => {
      return activeWebSocketGeneration === this._rpcWebSocketGeneration;
    };
    await Promise.all(
      // Don't be tempted to change this to `Object.entries`. We call
      // `_updateSubscriptions` recursively when processing the state,
      // so it's important that we look up the *current* version of
      // each subscription, every time we process a hash.
      Object.keys(this._subscriptionsByHash).map(async (hash) => {
        const subscription = this._subscriptionsByHash[hash];
        if (subscription === void 0) {
          return;
        }
        switch (subscription.state) {
          case "pending":
          case "unsubscribed":
            if (subscription.callbacks.size === 0) {
              delete this._subscriptionsByHash[hash];
              if (subscription.state === "unsubscribed") {
                delete this._subscriptionCallbacksByServerSubscriptionId[subscription.serverSubscriptionId];
              }
              await this._updateSubscriptions();
              return;
            }
            await (async () => {
              const {
                args,
                method
              } = subscription;
              try {
                this._setSubscription(hash, {
                  ...subscription,
                  state: "subscribing"
                });
                const serverSubscriptionId = await this._rpcWebSocket.call(method, args);
                this._setSubscription(hash, {
                  ...subscription,
                  serverSubscriptionId,
                  state: "subscribed"
                });
                this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId] = subscription.callbacks;
                await this._updateSubscriptions();
              } catch (e3) {
                console.error(`Received ${e3 instanceof Error ? "" : "JSON-RPC "}error calling \`${method}\``, {
                  args,
                  error: e3
                });
                if (!isCurrentConnectionStillActive()) {
                  return;
                }
                this._setSubscription(hash, {
                  ...subscription,
                  state: "pending"
                });
                await this._updateSubscriptions();
              }
            })();
            break;
          case "subscribed":
            if (subscription.callbacks.size === 0) {
              await (async () => {
                const {
                  serverSubscriptionId,
                  unsubscribeMethod
                } = subscription;
                if (this._subscriptionsAutoDisposedByRpc.has(serverSubscriptionId)) {
                  this._subscriptionsAutoDisposedByRpc.delete(serverSubscriptionId);
                } else {
                  this._setSubscription(hash, {
                    ...subscription,
                    state: "unsubscribing"
                  });
                  this._setSubscription(hash, {
                    ...subscription,
                    state: "unsubscribing"
                  });
                  try {
                    await this._rpcWebSocket.call(unsubscribeMethod, [serverSubscriptionId]);
                  } catch (e3) {
                    if (e3 instanceof Error) {
                      console.error(`${unsubscribeMethod} error:`, e3.message);
                    }
                    if (!isCurrentConnectionStillActive()) {
                      return;
                    }
                    this._setSubscription(hash, {
                      ...subscription,
                      state: "subscribed"
                    });
                    await this._updateSubscriptions();
                    return;
                  }
                }
                this._setSubscription(hash, {
                  ...subscription,
                  state: "unsubscribed"
                });
                await this._updateSubscriptions();
              })();
            }
            break;
        }
      })
    );
  }
  /**
   * @internal
   */
  _handleServerNotification(serverSubscriptionId, callbackArgs) {
    const callbacks = this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId];
    if (callbacks === void 0) {
      return;
    }
    callbacks.forEach((cb) => {
      try {
        cb(
          ...callbackArgs
        );
      } catch (e3) {
        console.error(e3);
      }
    });
  }
  /**
   * @internal
   */
  _wsOnAccountNotification(notification) {
    const {
      result,
      subscription
    } = create(notification, AccountNotificationResult);
    this._handleServerNotification(subscription, [result.value, result.context]);
  }
  /**
   * @internal
   */
  _makeSubscription(subscriptionConfig, args) {
    const clientSubscriptionId = this._nextClientSubscriptionId++;
    const hash = fastStableStringify([subscriptionConfig.method, args]);
    const existingSubscription = this._subscriptionsByHash[hash];
    if (existingSubscription === void 0) {
      this._subscriptionsByHash[hash] = {
        ...subscriptionConfig,
        args,
        callbacks: /* @__PURE__ */ new Set([subscriptionConfig.callback]),
        state: "pending"
      };
    } else {
      existingSubscription.callbacks.add(subscriptionConfig.callback);
    }
    this._subscriptionHashByClientSubscriptionId[clientSubscriptionId] = hash;
    this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId] = async () => {
      delete this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
      delete this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
      const subscription = this._subscriptionsByHash[hash];
      assert(subscription !== void 0, `Could not find a \`Subscription\` when tearing down client subscription #${clientSubscriptionId}`);
      subscription.callbacks.delete(subscriptionConfig.callback);
      await this._updateSubscriptions();
    };
    this._updateSubscriptions();
    return clientSubscriptionId;
  }
  /**
   * Register a callback to be invoked whenever the specified account changes
   *
   * @param publicKey Public key of the account to monitor
   * @param callback Function to invoke whenever the account is changed
   * @param config
   * @return subscription id
   */
  /** @deprecated Instead, pass in an {@link AccountSubscriptionConfig} */
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  onAccountChange(publicKey2, callback, commitmentOrConfig) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs(
      [publicKey2.toBase58()],
      commitment || this._commitment || "finalized",
      // Apply connection/server default.
      "base64",
      config
    );
    return this._makeSubscription({
      callback,
      method: "accountSubscribe",
      unsubscribeMethod: "accountUnsubscribe"
    }, args);
  }
  /**
   * Deregister an account notification callback
   *
   * @param clientSubscriptionId client subscription id to deregister
   */
  async removeAccountChangeListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, "account change");
  }
  /**
   * @internal
   */
  _wsOnProgramAccountNotification(notification) {
    const {
      result,
      subscription
    } = create(notification, ProgramAccountNotificationResult);
    this._handleServerNotification(subscription, [{
      accountId: result.value.pubkey,
      accountInfo: result.value.account
    }, result.context]);
  }
  /**
   * Register a callback to be invoked whenever accounts owned by the
   * specified program change
   *
   * @param programId Public key of the program to monitor
   * @param callback Function to invoke whenever the account is changed
   * @param config
   * @return subscription id
   */
  /** @deprecated Instead, pass in a {@link ProgramAccountSubscriptionConfig} */
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  onProgramAccountChange(programId, callback, commitmentOrConfig, maybeFilters) {
    const {
      commitment,
      config
    } = extractCommitmentFromConfig(commitmentOrConfig);
    const args = this._buildArgs(
      [programId.toBase58()],
      commitment || this._commitment || "finalized",
      // Apply connection/server default.
      "base64",
      config ? config : maybeFilters ? {
        filters: applyDefaultMemcmpEncodingToFilters(maybeFilters)
      } : void 0
      /* extra */
    );
    return this._makeSubscription({
      callback,
      method: "programSubscribe",
      unsubscribeMethod: "programUnsubscribe"
    }, args);
  }
  /**
   * Deregister an account notification callback
   *
   * @param clientSubscriptionId client subscription id to deregister
   */
  async removeProgramAccountChangeListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, "program account change");
  }
  /**
   * Registers a callback to be invoked whenever logs are emitted.
   */
  onLogs(filter, callback, commitment) {
    const args = this._buildArgs(
      [typeof filter === "object" ? {
        mentions: [filter.toString()]
      } : filter],
      commitment || this._commitment || "finalized"
      // Apply connection/server default.
    );
    return this._makeSubscription({
      callback,
      method: "logsSubscribe",
      unsubscribeMethod: "logsUnsubscribe"
    }, args);
  }
  /**
   * Deregister a logs callback.
   *
   * @param clientSubscriptionId client subscription id to deregister.
   */
  async removeOnLogsListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, "logs");
  }
  /**
   * @internal
   */
  _wsOnLogsNotification(notification) {
    const {
      result,
      subscription
    } = create(notification, LogsNotificationResult);
    this._handleServerNotification(subscription, [result.value, result.context]);
  }
  /**
   * @internal
   */
  _wsOnSlotNotification(notification) {
    const {
      result,
      subscription
    } = create(notification, SlotNotificationResult);
    this._handleServerNotification(subscription, [result]);
  }
  /**
   * Register a callback to be invoked upon slot changes
   *
   * @param callback Function to invoke whenever the slot changes
   * @return subscription id
   */
  onSlotChange(callback) {
    return this._makeSubscription(
      {
        callback,
        method: "slotSubscribe",
        unsubscribeMethod: "slotUnsubscribe"
      },
      []
      /* args */
    );
  }
  /**
   * Deregister a slot notification callback
   *
   * @param clientSubscriptionId client subscription id to deregister
   */
  async removeSlotChangeListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, "slot change");
  }
  /**
   * @internal
   */
  _wsOnSlotUpdatesNotification(notification) {
    const {
      result,
      subscription
    } = create(notification, SlotUpdateNotificationResult);
    this._handleServerNotification(subscription, [result]);
  }
  /**
   * Register a callback to be invoked upon slot updates. {@link SlotUpdate}'s
   * may be useful to track live progress of a cluster.
   *
   * @param callback Function to invoke whenever the slot updates
   * @return subscription id
   */
  onSlotUpdate(callback) {
    return this._makeSubscription(
      {
        callback,
        method: "slotsUpdatesSubscribe",
        unsubscribeMethod: "slotsUpdatesUnsubscribe"
      },
      []
      /* args */
    );
  }
  /**
   * Deregister a slot update notification callback
   *
   * @param clientSubscriptionId client subscription id to deregister
   */
  async removeSlotUpdateListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, "slot update");
  }
  /**
   * @internal
   */
  async _unsubscribeClientSubscription(clientSubscriptionId, subscriptionName) {
    const dispose = this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
    if (dispose) {
      await dispose();
    } else {
      console.warn(`Ignored unsubscribe request because an active subscription with id \`${clientSubscriptionId}\` for '${subscriptionName}' events could not be found.`);
    }
  }
  _buildArgs(args, override, encoding2, extra) {
    const commitment = override || this._commitment;
    if (commitment || encoding2 || extra) {
      let options = {};
      if (encoding2) {
        options.encoding = encoding2;
      }
      if (commitment) {
        options.commitment = commitment;
      }
      if (extra) {
        options = Object.assign(options, extra);
      }
      args.push(options);
    }
    return args;
  }
  /**
   * @internal
   */
  _buildArgsAtLeastConfirmed(args, override, encoding2, extra) {
    const commitment = override || this._commitment;
    if (commitment && !["confirmed", "finalized"].includes(commitment)) {
      throw new Error("Using Connection with default commitment: `" + this._commitment + "`, but method requires at least `confirmed`");
    }
    return this._buildArgs(args, override, encoding2, extra);
  }
  /**
   * @internal
   */
  _wsOnSignatureNotification(notification) {
    const {
      result,
      subscription
    } = create(notification, SignatureNotificationResult);
    if (result.value !== "receivedSignature") {
      this._subscriptionsAutoDisposedByRpc.add(subscription);
    }
    this._handleServerNotification(subscription, result.value === "receivedSignature" ? [{
      type: "received"
    }, result.context] : [{
      type: "status",
      result: result.value
    }, result.context]);
  }
  /**
   * Register a callback to be invoked upon signature updates
   *
   * @param signature Transaction signature string in base 58
   * @param callback Function to invoke on signature notifications
   * @param commitment Specify the commitment level signature must reach before notification
   * @return subscription id
   */
  onSignature(signature2, callback, commitment) {
    const args = this._buildArgs(
      [signature2],
      commitment || this._commitment || "finalized"
      // Apply connection/server default.
    );
    const clientSubscriptionId = this._makeSubscription({
      callback: (notification, context) => {
        if (notification.type === "status") {
          callback(notification.result, context);
          try {
            this.removeSignatureListener(clientSubscriptionId);
          } catch (_err) {
          }
        }
      },
      method: "signatureSubscribe",
      unsubscribeMethod: "signatureUnsubscribe"
    }, args);
    return clientSubscriptionId;
  }
  /**
   * Register a callback to be invoked when a transaction is
   * received and/or processed.
   *
   * @param signature Transaction signature string in base 58
   * @param callback Function to invoke on signature notifications
   * @param options Enable received notifications and set the commitment
   *   level that signature must reach before notification
   * @return subscription id
   */
  onSignatureWithOptions(signature2, callback, options) {
    const {
      commitment,
      ...extra
    } = {
      ...options,
      commitment: options && options.commitment || this._commitment || "finalized"
      // Apply connection/server default.
    };
    const args = this._buildArgs([signature2], commitment, void 0, extra);
    const clientSubscriptionId = this._makeSubscription({
      callback: (notification, context) => {
        callback(notification, context);
        try {
          this.removeSignatureListener(clientSubscriptionId);
        } catch (_err) {
        }
      },
      method: "signatureSubscribe",
      unsubscribeMethod: "signatureUnsubscribe"
    }, args);
    return clientSubscriptionId;
  }
  /**
   * Deregister a signature notification callback
   *
   * @param clientSubscriptionId client subscription id to deregister
   */
  async removeSignatureListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, "signature result");
  }
  /**
   * @internal
   */
  _wsOnRootNotification(notification) {
    const {
      result,
      subscription
    } = create(notification, RootNotificationResult);
    this._handleServerNotification(subscription, [result]);
  }
  /**
   * Register a callback to be invoked upon root changes
   *
   * @param callback Function to invoke whenever the root changes
   * @return subscription id
   */
  onRootChange(callback) {
    return this._makeSubscription(
      {
        callback,
        method: "rootSubscribe",
        unsubscribeMethod: "rootUnsubscribe"
      },
      []
      /* args */
    );
  }
  /**
   * Deregister a root notification callback
   *
   * @param clientSubscriptionId client subscription id to deregister
   */
  async removeRootChangeListener(clientSubscriptionId) {
    await this._unsubscribeClientSubscription(clientSubscriptionId, "root change");
  }
}
Object.freeze({
  CreateLookupTable: {
    index: 0,
    layout: LayoutExports.struct([LayoutExports.u32("instruction"), u64("recentSlot"), LayoutExports.u8("bumpSeed")])
  },
  FreezeLookupTable: {
    index: 1,
    layout: LayoutExports.struct([LayoutExports.u32("instruction")])
  },
  ExtendLookupTable: {
    index: 2,
    layout: LayoutExports.struct([LayoutExports.u32("instruction"), u64(), LayoutExports.seq(publicKey(), LayoutExports.offset(LayoutExports.u32(), -8), "addresses")])
  },
  DeactivateLookupTable: {
    index: 3,
    layout: LayoutExports.struct([LayoutExports.u32("instruction")])
  },
  CloseLookupTable: {
    index: 4,
    layout: LayoutExports.struct([LayoutExports.u32("instruction")])
  }
});
new PublicKey("AddressLookupTab1e1111111111111111111111111");
Object.freeze({
  RequestUnits: {
    index: 0,
    layout: LayoutExports.struct([LayoutExports.u8("instruction"), LayoutExports.u32("units"), LayoutExports.u32("additionalFee")])
  },
  RequestHeapFrame: {
    index: 1,
    layout: LayoutExports.struct([LayoutExports.u8("instruction"), LayoutExports.u32("bytes")])
  },
  SetComputeUnitLimit: {
    index: 2,
    layout: LayoutExports.struct([LayoutExports.u8("instruction"), LayoutExports.u32("units")])
  },
  SetComputeUnitPrice: {
    index: 3,
    layout: LayoutExports.struct([LayoutExports.u8("instruction"), u64("microLamports")])
  }
});
new PublicKey("ComputeBudget111111111111111111111111111111");
LayoutExports.struct([LayoutExports.u8("numSignatures"), LayoutExports.u8("padding"), LayoutExports.u16("signatureOffset"), LayoutExports.u16("signatureInstructionIndex"), LayoutExports.u16("publicKeyOffset"), LayoutExports.u16("publicKeyInstructionIndex"), LayoutExports.u16("messageDataOffset"), LayoutExports.u16("messageDataSize"), LayoutExports.u16("messageInstructionIndex")]);
new PublicKey("Ed25519SigVerify111111111111111111111111111");
secp256k1.utils.isValidPrivateKey;
LayoutExports.struct([LayoutExports.u8("numSignatures"), LayoutExports.u16("signatureOffset"), LayoutExports.u8("signatureInstructionIndex"), LayoutExports.u16("ethAddressOffset"), LayoutExports.u8("ethAddressInstructionIndex"), LayoutExports.u16("messageDataOffset"), LayoutExports.u16("messageDataSize"), LayoutExports.u8("messageInstructionIndex"), LayoutExports.blob(20, "ethAddress"), LayoutExports.blob(64, "signature"), LayoutExports.u8("recoveryId")]);
new PublicKey("KeccakSecp256k11111111111111111111111111111");
var _Lockup;
new PublicKey("StakeConfig11111111111111111111111111111111");
class Lockup {
  /**
   * Create a new Lockup object
   */
  constructor(unixTimestamp, epoch, custodian) {
    this.unixTimestamp = void 0;
    this.epoch = void 0;
    this.custodian = void 0;
    this.unixTimestamp = unixTimestamp;
    this.epoch = epoch;
    this.custodian = custodian;
  }
  /**
   * Default, inactive Lockup value
   */
}
_Lockup = Lockup;
Lockup.default = new _Lockup(0, 0, PublicKey.default);
Object.freeze({
  Initialize: {
    index: 0,
    layout: LayoutExports.struct([LayoutExports.u32("instruction"), authorized(), lockup()])
  },
  Authorize: {
    index: 1,
    layout: LayoutExports.struct([LayoutExports.u32("instruction"), publicKey("newAuthorized"), LayoutExports.u32("stakeAuthorizationType")])
  },
  Delegate: {
    index: 2,
    layout: LayoutExports.struct([LayoutExports.u32("instruction")])
  },
  Split: {
    index: 3,
    layout: LayoutExports.struct([LayoutExports.u32("instruction"), LayoutExports.ns64("lamports")])
  },
  Withdraw: {
    index: 4,
    layout: LayoutExports.struct([LayoutExports.u32("instruction"), LayoutExports.ns64("lamports")])
  },
  Deactivate: {
    index: 5,
    layout: LayoutExports.struct([LayoutExports.u32("instruction")])
  },
  Merge: {
    index: 7,
    layout: LayoutExports.struct([LayoutExports.u32("instruction")])
  },
  AuthorizeWithSeed: {
    index: 8,
    layout: LayoutExports.struct([LayoutExports.u32("instruction"), publicKey("newAuthorized"), LayoutExports.u32("stakeAuthorizationType"), rustString("authoritySeed"), publicKey("authorityOwner")])
  }
});
new PublicKey("Stake11111111111111111111111111111111111111");
Object.freeze({
  InitializeAccount: {
    index: 0,
    layout: LayoutExports.struct([LayoutExports.u32("instruction"), voteInit()])
  },
  Authorize: {
    index: 1,
    layout: LayoutExports.struct([LayoutExports.u32("instruction"), publicKey("newAuthorized"), LayoutExports.u32("voteAuthorizationType")])
  },
  Withdraw: {
    index: 3,
    layout: LayoutExports.struct([LayoutExports.u32("instruction"), LayoutExports.ns64("lamports")])
  },
  UpdateValidatorIdentity: {
    index: 4,
    layout: LayoutExports.struct([LayoutExports.u32("instruction")])
  },
  AuthorizeWithSeed: {
    index: 10,
    layout: LayoutExports.struct([LayoutExports.u32("instruction"), voteAuthorizeWithSeedArgs()])
  }
});
new PublicKey("Vote111111111111111111111111111111111111111");
new PublicKey("Va1idator1nfo111111111111111111111111111111");
type({
  name: string(),
  website: optional(string()),
  details: optional(string()),
  iconUrl: optional(string()),
  keybaseUsername: optional(string())
});
new PublicKey("Vote111111111111111111111111111111111111111");
LayoutExports.struct([
  publicKey("nodePubkey"),
  publicKey("authorizedWithdrawer"),
  LayoutExports.u8("commission"),
  LayoutExports.nu64(),
  // votes.length
  LayoutExports.seq(LayoutExports.struct([LayoutExports.nu64("slot"), LayoutExports.u32("confirmationCount")]), LayoutExports.offset(LayoutExports.u32(), -8), "votes"),
  LayoutExports.u8("rootSlotValid"),
  LayoutExports.nu64("rootSlot"),
  LayoutExports.nu64(),
  // authorizedVoters.length
  LayoutExports.seq(LayoutExports.struct([LayoutExports.nu64("epoch"), publicKey("authorizedVoter")]), LayoutExports.offset(LayoutExports.u32(), -8), "authorizedVoters"),
  LayoutExports.struct([LayoutExports.seq(LayoutExports.struct([publicKey("authorizedPubkey"), LayoutExports.nu64("epochOfLastAuthorizedSwitch"), LayoutExports.nu64("targetEpoch")]), 32, "buf"), LayoutExports.nu64("idx"), LayoutExports.u8("isEmpty")], "priorVoters"),
  LayoutExports.nu64(),
  // epochCredits.length
  LayoutExports.seq(LayoutExports.struct([LayoutExports.nu64("epoch"), LayoutExports.nu64("credits"), LayoutExports.nu64("prevCredits")]), LayoutExports.offset(LayoutExports.u32(), -8), "epochCredits"),
  LayoutExports.struct([LayoutExports.nu64("slot"), LayoutExports.nu64("timestamp")], "lastTimestamp")
]);
const LAMPORTS_PER_SOL = 1e9;
const PhantomWalletName = "Phantom";
class PhantomWalletAdapter extends BaseMessageSignerWalletAdapter {
  constructor(config = {}) {
    super();
    this.name = PhantomWalletName;
    this.url = "https://phantom.app";
    this.icon = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiB2aWV3Qm94PSIwIDAgMTA4IDEwOCIgZmlsbD0ibm9uZSI+CjxyZWN0IHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiByeD0iMjYiIGZpbGw9IiNBQjlGRjIiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00Ni41MjY3IDY5LjkyMjlDNDIuMDA1NCA3Ni44NTA5IDM0LjQyOTIgODUuNjE4MiAyNC4zNDggODUuNjE4MkMxOS41ODI0IDg1LjYxODIgMTUgODMuNjU2MyAxNSA3NS4xMzQyQzE1IDUzLjQzMDUgNDQuNjMyNiAxOS44MzI3IDcyLjEyNjggMTkuODMyN0M4Ny43NjggMTkuODMyNyA5NCAzMC42ODQ2IDk0IDQzLjAwNzlDOTQgNTguODI1OCA4My43MzU1IDc2LjkxMjIgNzMuNTMyMSA3Ni45MTIyQzcwLjI5MzkgNzYuOTEyMiA2OC43MDUzIDc1LjEzNDIgNjguNzA1MyA3Mi4zMTRDNjguNzA1MyA3MS41NzgzIDY4LjgyNzUgNzAuNzgxMiA2OS4wNzE5IDY5LjkyMjlDNjUuNTg5MyA3NS44Njk5IDU4Ljg2ODUgODEuMzg3OCA1Mi41NzU0IDgxLjM4NzhDNDcuOTkzIDgxLjM4NzggNDUuNjcxMyA3OC41MDYzIDQ1LjY3MTMgNzQuNDU5OEM0NS42NzEzIDcyLjk4ODQgNDUuOTc2OCA3MS40NTU2IDQ2LjUyNjcgNjkuOTIyOVpNODMuNjc2MSA0Mi41Nzk0QzgzLjY3NjEgNDYuMTcwNCA4MS41NTc1IDQ3Ljk2NTggNzkuMTg3NSA0Ny45NjU4Qzc2Ljc4MTYgNDcuOTY1OCA3NC42OTg5IDQ2LjE3MDQgNzQuNjk4OSA0Mi41Nzk0Qzc0LjY5ODkgMzguOTg4NSA3Ni43ODE2IDM3LjE5MzEgNzkuMTg3NSAzNy4xOTMxQzgxLjU1NzUgMzcuMTkzMSA4My42NzYxIDM4Ljk4ODUgODMuNjc2MSA0Mi41Nzk0Wk03MC4yMTAzIDQyLjU3OTVDNzAuMjEwMyA0Ni4xNzA0IDY4LjA5MTYgNDcuOTY1OCA2NS43MjE2IDQ3Ljk2NThDNjMuMzE1NyA0Ny45NjU4IDYxLjIzMyA0Ni4xNzA0IDYxLjIzMyA0Mi41Nzk1QzYxLjIzMyAzOC45ODg1IDYzLjMxNTcgMzcuMTkzMSA2NS43MjE2IDM3LjE5MzFDNjguMDkxNiAzNy4xOTMxIDcwLjIxMDMgMzguOTg4NSA3MC4yMTAzIDQyLjU3OTVaIiBmaWxsPSIjRkZGREY4Ii8+Cjwvc3ZnPg==";
    this.supportedTransactionVersions = /* @__PURE__ */ new Set(["legacy", 0]);
    this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
    this._disconnected = () => {
      const wallet = this._wallet;
      if (wallet) {
        wallet.off("disconnect", this._disconnected);
        wallet.off("accountChanged", this._accountChanged);
        this._wallet = null;
        this._publicKey = null;
        this.emit("error", new WalletDisconnectedError());
        this.emit("disconnect");
      }
    };
    this._accountChanged = (newPublicKey) => {
      const publicKey2 = this._publicKey;
      if (!publicKey2)
        return;
      try {
        newPublicKey = new PublicKey(newPublicKey.toBytes());
      } catch (error) {
        this.emit("error", new WalletPublicKeyError(error?.message, error));
        return;
      }
      if (publicKey2.equals(newPublicKey))
        return;
      this._publicKey = newPublicKey;
      this.emit("connect", newPublicKey);
    };
    this._connecting = false;
    this._wallet = null;
    this._publicKey = null;
    if (this._readyState !== WalletReadyState.Unsupported) {
      if (isIosAndRedirectable()) {
        this._readyState = WalletReadyState.Loadable;
        this.emit("readyStateChange", this._readyState);
      } else {
        scopePollingDetectionStrategy(() => {
          if (window.phantom?.solana?.isPhantom || window.solana?.isPhantom) {
            this._readyState = WalletReadyState.Installed;
            this.emit("readyStateChange", this._readyState);
            return true;
          }
          return false;
        });
      }
    }
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get readyState() {
    return this._readyState;
  }
  async autoConnect() {
    if (this.readyState === WalletReadyState.Installed) {
      await this.connect();
    }
  }
  async connect() {
    try {
      if (this.connected || this.connecting)
        return;
      if (this.readyState === WalletReadyState.Loadable) {
        const url = encodeURIComponent(window.location.href);
        const ref = encodeURIComponent(window.location.origin);
        window.location.href = `https://phantom.app/ul/browse/${url}?ref=${ref}`;
        return;
      }
      if (this.readyState !== WalletReadyState.Installed)
        throw new WalletNotReadyError();
      this._connecting = true;
      const wallet = window.phantom?.solana || window.solana;
      if (!wallet.isConnected) {
        try {
          await wallet.connect();
        } catch (error) {
          throw new WalletConnectionError(error?.message, error);
        }
      }
      if (!wallet.publicKey)
        throw new WalletAccountError();
      let publicKey2;
      try {
        publicKey2 = new PublicKey(wallet.publicKey.toBytes());
      } catch (error) {
        throw new WalletPublicKeyError(error?.message, error);
      }
      wallet.on("disconnect", this._disconnected);
      wallet.on("accountChanged", this._accountChanged);
      this._wallet = wallet;
      this._publicKey = publicKey2;
      this.emit("connect", publicKey2);
    } catch (error) {
      this.emit("error", error);
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    const wallet = this._wallet;
    if (wallet) {
      wallet.off("disconnect", this._disconnected);
      wallet.off("accountChanged", this._accountChanged);
      this._wallet = null;
      this._publicKey = null;
      try {
        await wallet.disconnect();
      } catch (error) {
        this.emit("error", new WalletDisconnectionError(error?.message, error));
      }
    }
    this.emit("disconnect");
  }
  async sendTransaction(transaction, connection, options = {}) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        const { signers, ...sendOptions } = options;
        if (isVersionedTransaction(transaction)) {
          signers?.length && transaction.sign(signers);
        } else {
          transaction = await this.prepareTransaction(transaction, connection, sendOptions);
          signers?.length && transaction.partialSign(...signers);
        }
        sendOptions.preflightCommitment = sendOptions.preflightCommitment || connection.commitment;
        const { signature: signature2 } = await wallet.signAndSendTransaction(transaction, sendOptions);
        return signature2;
      } catch (error) {
        if (error instanceof WalletError)
          throw error;
        throw new WalletSendTransactionError(error?.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signTransaction(transaction) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signTransaction(transaction) || transaction;
      } catch (error) {
        throw new WalletSignTransactionError(error?.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signAllTransactions(transactions) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signAllTransactions(transactions) || transactions;
      } catch (error) {
        throw new WalletSignTransactionError(error?.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signMessage(message) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        const { signature: signature2 } = await wallet.signMessage(message);
        return signature2;
      } catch (error) {
        throw new WalletSignMessageError(error?.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
}
var __classPrivateFieldGet$7 = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var __classPrivateFieldSet$7 = function(receiver, state, value, kind, f2) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var _RegisterWalletEvent_detail;
function registerWallet(wallet) {
  const callback = ({ register: register2 }) => register2(wallet);
  try {
    window.dispatchEvent(new RegisterWalletEvent(callback));
  } catch (error) {
    console.error("wallet-standard:register-wallet event could not be dispatched\n", error);
  }
  try {
    window.addEventListener("wallet-standard:app-ready", ({ detail: api }) => callback(api));
  } catch (error) {
    console.error("wallet-standard:app-ready event listener could not be added\n", error);
  }
}
class RegisterWalletEvent extends Event {
  get detail() {
    return __classPrivateFieldGet$7(this, _RegisterWalletEvent_detail, "f");
  }
  get type() {
    return "wallet-standard:register-wallet";
  }
  constructor(callback) {
    super("wallet-standard:register-wallet", {
      bubbles: false,
      cancelable: false,
      composed: false
    });
    _RegisterWalletEvent_detail.set(this, void 0);
    __classPrivateFieldSet$7(this, _RegisterWalletEvent_detail, callback, "f");
  }
  /** @deprecated */
  preventDefault() {
    throw new Error("preventDefault cannot be called");
  }
  /** @deprecated */
  stopImmediatePropagation() {
    throw new Error("stopImmediatePropagation cannot be called");
  }
  /** @deprecated */
  stopPropagation() {
    throw new Error("stopPropagation cannot be called");
  }
}
_RegisterWalletEvent_detail = /* @__PURE__ */ new WeakMap();
const SOLANA_MAINNET_CHAIN = "solana:mainnet";
const SOLANA_DEVNET_CHAIN = "solana:devnet";
const SOLANA_TESTNET_CHAIN = "solana:testnet";
const icon = "data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjMxIiB2aWV3Qm94PSIwIDAgMzEgMzEiIHdpZHRoPSIzMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGxpbmVhckdyYWRpZW50IGlkPSJhIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjIwLjI1IiB4Mj0iMjYuNTcxIiB5MT0iMjcuMTczIiB5Mj0iMTkuODU4Ij48c3RvcCBvZmZzZXQ9Ii4wOCIgc3RvcC1jb2xvcj0iIzk5NDVmZiIvPjxzdG9wIG9mZnNldD0iLjMiIHN0b3AtY29sb3I9IiM4NzUyZjMiLz48c3RvcCBvZmZzZXQ9Ii41IiBzdG9wLWNvbG9yPSIjNTQ5N2Q1Ii8+PHN0b3Agb2Zmc2V0PSIuNiIgc3RvcC1jb2xvcj0iIzQzYjRjYSIvPjxzdG9wIG9mZnNldD0iLjcyIiBzdG9wLWNvbG9yPSIjMjhlMGI5Ii8+PHN0b3Agb2Zmc2V0PSIuOTciIHN0b3AtY29sb3I9IiMxOWZiOWIiLz48L2xpbmVhckdyYWRpZW50PjxnIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iLjA5NCI+PHBhdGggZD0ibTI2LjEwOSAzLjY0My05LjM2OSA2Ljk1OSAxLjczMy00LjEwNSA3LjYzNy0yLjg1M3oiIGZpbGw9IiNlMjc2MWIiIHN0cm9rZT0iI2UyNzYxYiIvPjxnIGZpbGw9IiNlNDc2MWIiIHN0cm9rZT0iI2U0NzYxYiI+PHBhdGggZD0ibTQuNDgxIDMuNjQzIDkuMjk0IDcuMDI0LTEuNjQ4LTQuMTcxem0xOC4yNTggMTYuMTMtMi40OTUgMy44MjMgNS4zMzkgMS40NjkgMS41MzUtNS4yMDctNC4zNzgtLjA4NXptLTE5LjI0Ny4wODUgMS41MjUgNS4yMDcgNS4zMzktMS40NjktMi40OTUtMy44MjN6Ii8+PHBhdGggZD0ibTEwLjA1NSAxMy4zMTMtMS40ODggMi4yNTEgNS4zMDEuMjM1LS4xODgtNS42OTd6bTEwLjQ4IDAtMy42NzItMy4yNzctLjEyMiA1Ljc2MyA1LjI5Mi0uMjM1LTEuNDk3LTIuMjUxem0tMTAuMTc4IDEwLjI4MyAzLjE4My0xLjU1NC0yLjc0OS0yLjE0Ny0uNDMzIDMuNzAxem02LjY5NS0xLjU1NCAzLjE5MiAxLjU1NC0uNDQzLTMuNzAxeiIvPjwvZz48cGF0aCBkPSJtMjAuMjQ0IDIzLjU5Ni0zLjE5Mi0xLjU1NC4yNTQgMi4wODEtLjAyOC44NzZ6bS05Ljg4NyAwIDIuOTY2IDEuNDAzLS4wMTktLjg3Ni4yMzUtMi4wODEtMy4xODMgMS41NTR6IiBmaWxsPSIjZDdjMWIzIiBzdHJva2U9IiNkN2MxYjMiLz48cGF0aCBkPSJtMTMuMzY5IDE4LjUyMS0yLjY1NS0uNzgxIDEuODc0LS44NTd6bTMuODUxIDAgLjc4MS0xLjYzOCAxLjg4My44NTctMi42NjUuNzgxeiIgZmlsbD0iIzIzMzQ0NyIgc3Ryb2tlPSIjMjMzNDQ3Ii8+PHBhdGggZD0ibTEwLjM1NyAyMy41OTYuNDUyLTMuODIzLTIuOTQ3LjA4NXptOS40MzUtMy44MjMuNDUyIDMuODIzIDIuNDk1LTMuNzM4em0yLjI0MS00LjIwOS01LjI5Mi4yMzUuNDkgMi43MjEuNzgyLTEuNjM4IDEuODgzLjg1N3ptLTExLjMxOCAyLjE3NSAxLjg4My0uODU3Ljc3MiAxLjYzOC40OTktMi43MjEtNS4zMDEtLjIzNXoiIGZpbGw9IiNjZDYxMTYiIHN0cm9rZT0iI2NkNjExNiIvPjxwYXRoIGQ9Im04LjU2NyAxNS41NjQgMi4yMjIgNC4zMzEtLjA3NS0yLjE1NnptMTEuMzI4IDIuMTc1LS4wOTQgMi4xNTYgMi4yMzItNC4zMzEtMi4xMzcgMi4xNzV6bS02LjAyNi0xLjk0LS40OTkgMi43MjEuNjIxIDMuMjExLjE0MS00LjIyOC0uMjY0LTEuNzA0em0yLjg3MiAwLS4yNTQgMS42OTUuMTEzIDQuMjM3LjYzMS0zLjIxMXoiIGZpbGw9IiNlNDc1MWYiIHN0cm9rZT0iI2U0NzUxZiIvPjxwYXRoIGQ9Im0xNy4yMyAxOC41Mi0uNjMxIDMuMjExLjQ1Mi4zMTEgMi43NS0yLjE0Ny4wOTQtMi4xNTZ6bS02LjUxNi0uNzgxLjA3NSAyLjE1NiAyLjc1IDIuMTQ3LjQ1Mi0uMzExLS42MjItMy4yMTF6IiBmaWxsPSIjZjY4NTFiIiBzdHJva2U9IiNmNjg1MWIiLz48cGF0aCBkPSJtMTcuMjc3IDI0Ljk5OS4wMjgtLjg3Ni0uMjM1LS4yMDdoLTMuNTVsLS4yMTcuMjA3LjAxOS44NzYtMi45NjYtMS40MDMgMS4wMzYuODQ4IDIuMSAxLjQ1OWgzLjYwNmwyLjEwOS0xLjQ1OSAxLjAzNi0uODQ4eiIgZmlsbD0iI2MwYWQ5ZSIgc3Ryb2tlPSIjYzBhZDllIi8+PHBhdGggZD0ibTE3LjA1MSAyMi4wNDItLjQ1Mi0uMzExaC0yLjYwOGwtLjQ1Mi4zMTEtLjIzNSAyLjA4MS4yMTctLjIwN2gzLjU1bC4yMzUuMjA3LS4yNTQtMi4wODF6IiBmaWxsPSIjMTYxNjE2IiBzdHJva2U9IiMxNjE2MTYiLz48cGF0aCBkPSJtMjYuNTA1IDExLjA1My44LTMuODQyLTEuMTk2LTMuNTY5LTkuMDU4IDYuNzIzIDMuNDg0IDIuOTQ3IDQuOTI1IDEuNDQxIDEuMDkyLTEuMjcxLS40NzEtLjMzOS43NTMtLjY4Ny0uNTg0LS40NTIuNzUzLS41NzQtLjQ5OS0uMzc3em0tMjMuMjExLTMuODQxLjggMy44NDItLjUwOC4zNzcuNzUzLjU3NC0uNTc0LjQ1Mi43NTMuNjg3LS40NzEuMzM5IDEuMDgzIDEuMjcxIDQuOTI1LTEuNDQxIDMuNDg0LTIuOTQ3LTkuMDU5LTYuNzIzeiIgZmlsbD0iIzc2M2QxNiIgc3Ryb2tlPSIjNzYzZDE2Ii8+PHBhdGggZD0ibTI1LjQ2IDE0Ljc1NC00LjkyNS0xLjQ0MSAxLjQ5NyAyLjI1MS0yLjIzMiA0LjMzMSAyLjkzOC0uMDM4aDQuMzc4bC0xLjY1Ny01LjEwNHptLTE1LjQwNS0xLjQ0MS00LjkyNSAxLjQ0MS0xLjYzOCA1LjEwNGg0LjM2OWwyLjkyOC4wMzgtMi4yMjItNC4zMzEgMS40ODgtMi4yNTF6bTYuNjg1IDIuNDg2LjMxMS01LjQzMyAxLjQzMS0zLjg3aC02LjM1NmwxLjQxMyAzLjg3LjMyOSA1LjQzMy4xMTMgMS43MTQuMDA5IDQuMjE5aDIuNjFsLjAxOS00LjIxOS4xMjItMS43MTR6IiBmaWxsPSIjZjY4NTFiIiBzdHJva2U9IiNmNjg1MWIiLz48L2c+PGNpcmNsZSBjeD0iMjMuNSIgY3k9IjIzLjUiIGZpbGw9IiMwMDAiIHI9IjYuNSIvPjxwYXRoIGQ9Im0yNy40NzMgMjUuNTQ1LTEuMzEgMS4zNjhjLS4wMjkuMDMtLjA2My4wNTMtLjEwMS4wN2EuMzEuMzEgMCAwIDEgLS4xMjEuMDI0aC02LjIwOWMtLjAzIDAtLjA1OS0uMDA4LS4wODMtLjAyNGEuMTUuMTUgMCAwIDEgLS4wNTYtLjA2NWMtLjAxMi0uMDI2LS4wMTUtLjA1Ni0uMDEtLjA4NHMuMDE4LS4wNTUuMDM5LS4wNzZsMS4zMTEtMS4zNjhjLjAyOC0uMDMuMDYzLS4wNTMuMTAxLS4wNjlhLjMxLjMxIDAgMCAxIC4xMjEtLjAyNWg2LjIwOGMuMDMgMCAuMDU5LjAwOC4wODMuMDI0YS4xNS4xNSAwIDAgMSAuMDU2LjA2NWMuMDEyLjAyNi4wMTUuMDU2LjAxLjA4NHMtLjAxOC4wNTUtLjAzOS4wNzZ6bS0xLjMxLTIuNzU2Yy0uMDI5LS4wMy0uMDYzLS4wNTMtLjEwMS0uMDdhLjMxLjMxIDAgMCAwIC0uMTIxLS4wMjRoLTYuMjA5Yy0uMDMgMC0uMDU5LjAwOC0uMDgzLjAyNHMtLjA0NC4wMzgtLjA1Ni4wNjUtLjAxNS4wNTYtLjAxLjA4NC4wMTguMDU1LjAzOS4wNzZsMS4zMTEgMS4zNjhjLjAyOC4wMy4wNjMuMDUzLjEwMS4wNjlhLjMxLjMxIDAgMCAwIC4xMjEuMDI1aDYuMjA4Yy4wMyAwIC4wNTktLjAwOC4wODMtLjAyNGEuMTUuMTUgMCAwIDAgLjA1Ni0uMDY1Yy4wMTItLjAyNi4wMTUtLjA1Ni4wMS0uMDg0cy0uMDE4LS4wNTUtLjAzOS0uMDc2em0tNi40MzEtLjk4M2g2LjIwOWEuMzEuMzEgMCAwIDAgLjEyMS0uMDI0Yy4wMzgtLjAxNi4wNzMtLjA0LjEwMS0uMDdsMS4zMS0xLjM2OGMuMDItLjAyMS4wMzQtLjA0Ny4wMzktLjA3NnMuMDAxLS4wNTgtLjAxLS4wODRhLjE1LjE1IDAgMCAwIC0uMDU2LS4wNjVjLS4wMjUtLjAxNi0uMDU0LS4wMjQtLjA4My0uMDI0aC02LjIwOGEuMzEuMzEgMCAwIDAgLS4xMjEuMDI1Yy0uMDM4LjAxNi0uMDcyLjA0LS4xMDEuMDY5bC0xLjMxIDEuMzY4Yy0uMDIuMDIxLS4wMzQuMDQ3LS4wMzkuMDc2cy0uMDAxLjA1OC4wMS4wODQuMDMxLjA0OS4wNTYuMDY1LjA1NC4wMjQuMDgzLjAyNHoiIGZpbGw9InVybCgjYSkiLz48L3N2Zz4=";
var __classPrivateFieldGet$6 = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var __classPrivateFieldSet$6 = function(receiver, state, value, kind, f2) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var _SolflareMetaMaskWallet_instances, _SolflareMetaMaskWallet_listeners, _SolflareMetaMaskWallet_version, _SolflareMetaMaskWallet_name, _SolflareMetaMaskWallet_icon, _SolflareMetaMaskWallet_solflareMetaMask, _SolflareMetaMaskWallet_on, _SolflareMetaMaskWallet_emit, _SolflareMetaMaskWallet_off, _SolflareMetaMaskWallet_connect, _SolflareMetaMaskWallet_disconnect, _SolflareMetaMaskWallet_signAndSendTransaction, _SolflareMetaMaskWallet_signTransaction, _SolflareMetaMaskWallet_signMessage;
class SolflareMetaMaskWallet {
  constructor() {
    _SolflareMetaMaskWallet_instances.add(this);
    _SolflareMetaMaskWallet_listeners.set(this, {});
    _SolflareMetaMaskWallet_version.set(this, "1.0.0");
    _SolflareMetaMaskWallet_name.set(this, "MetaMask");
    _SolflareMetaMaskWallet_icon.set(this, icon);
    _SolflareMetaMaskWallet_solflareMetaMask.set(this, null);
    _SolflareMetaMaskWallet_on.set(this, (event, listener) => {
      __classPrivateFieldGet$6(this, _SolflareMetaMaskWallet_listeners, "f")[event]?.push(listener) || (__classPrivateFieldGet$6(this, _SolflareMetaMaskWallet_listeners, "f")[event] = [listener]);
      return () => __classPrivateFieldGet$6(this, _SolflareMetaMaskWallet_instances, "m", _SolflareMetaMaskWallet_off).call(this, event, listener);
    });
    _SolflareMetaMaskWallet_connect.set(this, async () => {
      if (!__classPrivateFieldGet$6(this, _SolflareMetaMaskWallet_solflareMetaMask, "f")) {
        let SolflareMetaMaskClass;
        try {
          SolflareMetaMaskClass = (await import("./index-B8Y7eJ2G.js")).default;
        } catch (error) {
          throw new Error("Unable to load Solflare MetaMask SDK");
        }
        __classPrivateFieldSet$6(this, _SolflareMetaMaskWallet_solflareMetaMask, new SolflareMetaMaskClass(), "f");
        __classPrivateFieldGet$6(this, _SolflareMetaMaskWallet_solflareMetaMask, "f").on("standard_change", (properties) => __classPrivateFieldGet$6(this, _SolflareMetaMaskWallet_instances, "m", _SolflareMetaMaskWallet_emit).call(this, "change", properties));
      }
      if (!this.accounts.length) {
        await __classPrivateFieldGet$6(this, _SolflareMetaMaskWallet_solflareMetaMask, "f").connect();
      }
      return { accounts: this.accounts };
    });
    _SolflareMetaMaskWallet_disconnect.set(this, async () => {
      if (!__classPrivateFieldGet$6(this, _SolflareMetaMaskWallet_solflareMetaMask, "f"))
        return;
      await __classPrivateFieldGet$6(this, _SolflareMetaMaskWallet_solflareMetaMask, "f").disconnect();
    });
    _SolflareMetaMaskWallet_signAndSendTransaction.set(this, async (...inputs) => {
      if (!__classPrivateFieldGet$6(this, _SolflareMetaMaskWallet_solflareMetaMask, "f"))
        throw new WalletNotConnectedError();
      return await __classPrivateFieldGet$6(this, _SolflareMetaMaskWallet_solflareMetaMask, "f").standardSignAndSendTransaction(...inputs);
    });
    _SolflareMetaMaskWallet_signTransaction.set(this, async (...inputs) => {
      if (!__classPrivateFieldGet$6(this, _SolflareMetaMaskWallet_solflareMetaMask, "f"))
        throw new WalletNotConnectedError();
      return await __classPrivateFieldGet$6(this, _SolflareMetaMaskWallet_solflareMetaMask, "f").standardSignTransaction(...inputs);
    });
    _SolflareMetaMaskWallet_signMessage.set(this, async (...inputs) => {
      if (!__classPrivateFieldGet$6(this, _SolflareMetaMaskWallet_solflareMetaMask, "f"))
        throw new WalletNotConnectedError();
      return await __classPrivateFieldGet$6(this, _SolflareMetaMaskWallet_solflareMetaMask, "f").standardSignMessage(...inputs);
    });
  }
  get version() {
    return __classPrivateFieldGet$6(this, _SolflareMetaMaskWallet_version, "f");
  }
  get name() {
    return __classPrivateFieldGet$6(this, _SolflareMetaMaskWallet_name, "f");
  }
  get icon() {
    return __classPrivateFieldGet$6(this, _SolflareMetaMaskWallet_icon, "f");
  }
  get chains() {
    return [SOLANA_MAINNET_CHAIN, SOLANA_DEVNET_CHAIN, SOLANA_TESTNET_CHAIN];
  }
  get features() {
    return {
      [StandardConnect]: {
        version: "1.0.0",
        connect: __classPrivateFieldGet$6(this, _SolflareMetaMaskWallet_connect, "f")
      },
      [StandardDisconnect]: {
        version: "1.0.0",
        disconnect: __classPrivateFieldGet$6(this, _SolflareMetaMaskWallet_disconnect, "f")
      },
      [StandardEvents]: {
        version: "1.0.0",
        on: __classPrivateFieldGet$6(this, _SolflareMetaMaskWallet_on, "f")
      },
      [SolanaSignAndSendTransaction]: {
        version: "1.0.0",
        supportedTransactionVersions: ["legacy", 0],
        signAndSendTransaction: __classPrivateFieldGet$6(this, _SolflareMetaMaskWallet_signAndSendTransaction, "f")
      },
      [SolanaSignTransaction]: {
        version: "1.0.0",
        supportedTransactionVersions: ["legacy", 0],
        signTransaction: __classPrivateFieldGet$6(this, _SolflareMetaMaskWallet_signTransaction, "f")
      },
      [SolanaSignMessage]: {
        version: "1.0.0",
        signMessage: __classPrivateFieldGet$6(this, _SolflareMetaMaskWallet_signMessage, "f")
      }
    };
  }
  get accounts() {
    return __classPrivateFieldGet$6(this, _SolflareMetaMaskWallet_solflareMetaMask, "f") ? __classPrivateFieldGet$6(this, _SolflareMetaMaskWallet_solflareMetaMask, "f").standardAccounts : [];
  }
}
_SolflareMetaMaskWallet_listeners = /* @__PURE__ */ new WeakMap(), _SolflareMetaMaskWallet_version = /* @__PURE__ */ new WeakMap(), _SolflareMetaMaskWallet_name = /* @__PURE__ */ new WeakMap(), _SolflareMetaMaskWallet_icon = /* @__PURE__ */ new WeakMap(), _SolflareMetaMaskWallet_solflareMetaMask = /* @__PURE__ */ new WeakMap(), _SolflareMetaMaskWallet_on = /* @__PURE__ */ new WeakMap(), _SolflareMetaMaskWallet_connect = /* @__PURE__ */ new WeakMap(), _SolflareMetaMaskWallet_disconnect = /* @__PURE__ */ new WeakMap(), _SolflareMetaMaskWallet_signAndSendTransaction = /* @__PURE__ */ new WeakMap(), _SolflareMetaMaskWallet_signTransaction = /* @__PURE__ */ new WeakMap(), _SolflareMetaMaskWallet_signMessage = /* @__PURE__ */ new WeakMap(), _SolflareMetaMaskWallet_instances = /* @__PURE__ */ new WeakSet(), _SolflareMetaMaskWallet_emit = function _SolflareMetaMaskWallet_emit2(event, ...args) {
  __classPrivateFieldGet$6(this, _SolflareMetaMaskWallet_listeners, "f")[event]?.forEach((listener) => listener.apply(null, args));
}, _SolflareMetaMaskWallet_off = function _SolflareMetaMaskWallet_off2(event, listener) {
  __classPrivateFieldGet$6(this, _SolflareMetaMaskWallet_listeners, "f")[event] = __classPrivateFieldGet$6(this, _SolflareMetaMaskWallet_listeners, "f")[event]?.filter((existingListener) => listener !== existingListener);
};
let registered = false;
function register() {
  if (registered)
    return;
  registerWallet(new SolflareMetaMaskWallet());
  registered = true;
}
async function detectAndRegisterSolflareMetaMaskWallet() {
  const id = "solflare-detect-metamask";
  function postMessage() {
    window.postMessage({
      target: "metamask-contentscript",
      data: {
        name: "metamask-provider",
        data: {
          id,
          jsonrpc: "2.0",
          method: "wallet_getSnaps"
        }
      }
    }, window.location.origin);
  }
  function onMessage(event) {
    const message = event.data;
    if (message?.target === "metamask-inpage" && message.data?.name === "metamask-provider") {
      if (message.data.data?.id === id) {
        window.removeEventListener("message", onMessage);
        if (!message.data.data.error) {
          register();
        }
      } else {
        postMessage();
      }
    }
  }
  window.addEventListener("message", onMessage);
  window.setTimeout(() => window.removeEventListener("message", onMessage), 5e3);
  postMessage();
}
const SolflareWalletName = "Solflare";
class SolflareWalletAdapter extends BaseMessageSignerWalletAdapter {
  constructor(config = {}) {
    super();
    this.name = SolflareWalletName;
    this.url = "https://solflare.com";
    this.icon = "data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjUwIiB2aWV3Qm94PSIwIDAgNTAgNTAiIHdpZHRoPSI1MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGxpbmVhckdyYWRpZW50IGlkPSJhIj48c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiNmZmMxMGIiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNmYjNmMmUiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iYiIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSI2LjQ3ODM1IiB4Mj0iMzQuOTEwNyIgeGxpbms6aHJlZj0iI2EiIHkxPSI3LjkyIiB5Mj0iMzMuNjU5MyIvPjxyYWRpYWxHcmFkaWVudCBpZD0iYyIgY3g9IjAiIGN5PSIwIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDQuOTkyMTg4MzIgMTIuMDYzODc5NjMgLTEyLjE4MTEzNjU1IDUuMDQwNzEwNzQgMjIuNTIwMiAyMC42MTgzKSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHI9IjEiIHhsaW5rOmhyZWY9IiNhIi8+PHBhdGggZD0ibTI1LjE3MDggNDcuOTEwNGMuNTI1IDAgLjk1MDcuNDIxLjk1MDcuOTQwM3MtLjQyNTcuOTQwMi0uOTUwNy45NDAyLS45NTA3LS40MjA5LS45NTA3LS45NDAyLjQyNTctLjk0MDMuOTUwNy0uOTQwM3ptLTEuMDMyOC00NC45MTU2NWMuNDY0Ni4wMzgzNi44Mzk4LjM5MDQuOTAyNy44NDY4MWwxLjEzMDcgOC4yMTU3NGMuMzc5OCAyLjcxNDMgMy42NTM1IDMuODkwNCA1LjY3NDMgMi4wNDU5bDExLjMyOTEtMTAuMzExNThjLjI3MzMtLjI0ODczLjY5ODktLjIzMTQ5Ljk1MDcuMDM4NTEuMjMwOS4yNDc3Mi4yMzc5LjYyNjk3LjAxNjEuODgyNzdsLTkuODc5MSAxMS4zOTU4Yy0xLjgxODcgMi4wOTQyLS40NzY4IDUuMzY0MyAyLjI5NTYgNS41OTc4bDguNzE2OC44NDAzYy40MzQxLjA0MTguNzUxNy40MjM0LjcwOTMuODUyNC0uMDM0OS4zNTM3LS4zMDc0LjYzOTUtLjY2MjguNjk0OWwtOS4xNTk0IDEuNDMwMmMtMi42NTkzLjM2MjUtMy44NjM2IDMuNTExNy0yLjEzMzkgNS41NTc2bDMuMjIgMy43OTYxYy4yNTk0LjMwNTguMjE4OC43NjE1LS4wOTA4IDEuMDE3OC0uMjYyMi4yMTcyLS42NDE5LjIyNTYtLjkxMzguMDIwM2wtMy45Njk0LTIuOTk3OGMtMi4xNDIxLTEuNjEwOS01LjIyOTctLjI0MTctNS40NTYxIDIuNDI0M2wtLjg3NDcgMTAuMzk3NmMtLjAzNjIuNDI5NS0uNDE3OC43NDg3LS44NTI1LjcxMy0uMzY5LS4wMzAzLS42NjcxLS4zMDk3LS43MTcxLS42NzIxbC0xLjM4NzEtMTAuMDQzN2MtLjM3MTctMi43MTQ0LTMuNjQ1NC0zLjg5MDQtNS42NzQzLTIuMDQ1OWwtMTIuMDUxOTUgMTAuOTc0Yy0uMjQ5NDcuMjI3MS0uNjM4MDkuMjExNC0uODY4LS4wMzUtLjIxMDk0LS4yMjYyLS4yMTczNS0uNTcyNC0uMDE0OTMtLjgwNmwxMC41MTgxOC0xMi4xMzg1YzEuODE4Ny0yLjA5NDIuNDg0OS01LjM2NDQtMi4yODc2LTUuNTk3OGwtOC43MTg3Mi0uODQwNWMtLjQzNDEzLS4wNDE4LS43NTE3Mi0uNDIzNS0uNzA5MzYtLjg1MjQuMDM0OTMtLjM1MzcuMzA3MzktLjYzOTQuNjYyNy0uNjk1bDkuMTUzMzgtMS40Mjk5YzIuNjU5NC0uMzYyNSAzLjg3MTgtMy41MTE3IDIuMTQyMS01LjU1NzZsLTIuMTkyLTIuNTg0MWMtLjMyMTctLjM3OTItLjI3MTMtLjk0NDMuMTEyNi0xLjI2MjEuMzI1My0uMjY5NC43OTYzLS4yNzk3IDEuMTMzNC0uMDI0OWwyLjY5MTggMi4wMzQ3YzIuMTQyMSAxLjYxMDkgNS4yMjk3LjI0MTcgNS40NTYxLTIuNDI0M2wuNzI0MS04LjU1OTk4Yy4wNDU3LS41NDA4LjUyNjUtLjk0MjU3IDEuMDczOS0uODk3Mzd6bS0yMy4xODczMyAyMC40Mzk2NWMuNTI1MDQgMCAuOTUwNjcuNDIxLjk1MDY3Ljk0MDNzLS40MjU2My45NDAzLS45NTA2Ny45NDAzYy0uNTI1MDQxIDAtLjk1MDY3LS40MjEtLjk1MDY3LS45NDAzcy40MjU2MjktLjk0MDMuOTUwNjctLjk0MDN6bTQ3LjY3OTczLS45NTQ3Yy41MjUgMCAuOTUwNy40MjEuOTUwNy45NDAzcy0uNDI1Ny45NDAyLS45NTA3Ljk0MDItLjk1MDctLjQyMDktLjk1MDctLjk0MDIuNDI1Ny0uOTQwMy45NTA3LS45NDAzem0tMjQuNjI5Ni0yMi40Nzk3Yy41MjUgMCAuOTUwNi40MjA5NzMuOTUwNi45NDAyNyAwIC41MTkzLS40MjU2Ljk0MDI3LS45NTA2Ljk0MDI3LS41MjUxIDAtLjk1MDctLjQyMDk3LS45NTA3LS45NDAyNyAwLS41MTkyOTcuNDI1Ni0uOTQwMjcuOTUwNy0uOTQwMjd6IiBmaWxsPSJ1cmwoI2IpIi8+PHBhdGggZD0ibTI0LjU3MSAzMi43NzkyYzQuOTU5NiAwIDguOTgwMi0zLjk3NjUgOC45ODAyLTguODgxOSAwLTQuOTA1My00LjAyMDYtOC44ODE5LTguOTgwMi04Ljg4MTlzLTguOTgwMiAzLjk3NjYtOC45ODAyIDguODgxOWMwIDQuOTA1NCA0LjAyMDYgOC44ODE5IDguOTgwMiA4Ljg4MTl6IiBmaWxsPSJ1cmwoI2MpIi8+PC9zdmc+";
    this.supportedTransactionVersions = /* @__PURE__ */ new Set(["legacy", 0]);
    this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.Loadable;
    this._disconnected = () => {
      const wallet = this._wallet;
      if (wallet) {
        wallet.off("disconnect", this._disconnected);
        this._wallet = null;
        this._publicKey = null;
        this.emit("error", new WalletDisconnectedError());
        this.emit("disconnect");
      }
    };
    this._accountChanged = (newPublicKey) => {
      if (!newPublicKey)
        return;
      const publicKey2 = this._publicKey;
      if (!publicKey2)
        return;
      try {
        newPublicKey = new PublicKey(newPublicKey.toBytes());
      } catch (error) {
        this.emit("error", new WalletPublicKeyError(error?.message, error));
        return;
      }
      if (publicKey2.equals(newPublicKey))
        return;
      this._publicKey = newPublicKey;
      this.emit("connect", newPublicKey);
    };
    this._connecting = false;
    this._publicKey = null;
    this._wallet = null;
    this._config = config;
    if (this._readyState !== WalletReadyState.Unsupported) {
      scopePollingDetectionStrategy(() => {
        if (window.solflare?.isSolflare || window.SolflareApp) {
          this._readyState = WalletReadyState.Installed;
          this.emit("readyStateChange", this._readyState);
          return true;
        }
        return false;
      });
      detectAndRegisterSolflareMetaMaskWallet();
    }
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get connected() {
    return !!this._wallet?.connected;
  }
  get readyState() {
    return this._readyState;
  }
  async autoConnect() {
    if (!(this.readyState === WalletReadyState.Loadable && isIosAndRedirectable())) {
      await this.connect();
    }
  }
  async connect() {
    try {
      if (this.connected || this.connecting)
        return;
      if (this._readyState !== WalletReadyState.Loadable && this._readyState !== WalletReadyState.Installed)
        throw new WalletNotReadyError();
      if (this.readyState === WalletReadyState.Loadable && isIosAndRedirectable()) {
        const url = encodeURIComponent(window.location.href);
        const ref = encodeURIComponent(window.location.origin);
        window.location.href = `https://solflare.com/ul/v1/browse/${url}?ref=${ref}`;
        return;
      }
      let SolflareClass;
      try {
        SolflareClass = (await import("./index-C0n6dgYw.js")).default;
      } catch (error) {
        throw new WalletLoadError(error?.message, error);
      }
      let wallet;
      try {
        wallet = new SolflareClass({ network: this._config.network });
      } catch (error) {
        throw new WalletConfigError(error?.message, error);
      }
      this._connecting = true;
      if (!wallet.connected) {
        try {
          await wallet.connect();
        } catch (error) {
          throw new WalletConnectionError(error?.message, error);
        }
      }
      if (!wallet.publicKey)
        throw new WalletConnectionError();
      let publicKey2;
      try {
        publicKey2 = new PublicKey(wallet.publicKey.toBytes());
      } catch (error) {
        throw new WalletPublicKeyError(error?.message, error);
      }
      wallet.on("disconnect", this._disconnected);
      wallet.on("accountChanged", this._accountChanged);
      this._wallet = wallet;
      this._publicKey = publicKey2;
      this.emit("connect", publicKey2);
    } catch (error) {
      this.emit("error", error);
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    const wallet = this._wallet;
    if (wallet) {
      wallet.off("disconnect", this._disconnected);
      wallet.off("accountChanged", this._accountChanged);
      this._wallet = null;
      this._publicKey = null;
      try {
        await wallet.disconnect();
      } catch (error) {
        this.emit("error", new WalletDisconnectionError(error?.message, error));
      }
    }
    this.emit("disconnect");
  }
  async sendTransaction(transaction, connection, options = {}) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        const { signers, ...sendOptions } = options;
        if (isVersionedTransaction(transaction)) {
          signers?.length && transaction.sign(signers);
        } else {
          transaction = await this.prepareTransaction(transaction, connection, sendOptions);
          signers?.length && transaction.partialSign(...signers);
        }
        sendOptions.preflightCommitment = sendOptions.preflightCommitment || connection.commitment;
        return await wallet.signAndSendTransaction(transaction, sendOptions);
      } catch (error) {
        if (error instanceof WalletError)
          throw error;
        throw new WalletSendTransactionError(error?.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signTransaction(transaction) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signTransaction(transaction) || transaction;
      } catch (error) {
        throw new WalletSignTransactionError(error?.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signAllTransactions(transactions) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signAllTransactions(transactions) || transactions;
      } catch (error) {
        throw new WalletSignTransactionError(error?.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signMessage(message) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signMessage(message, "utf8");
      } catch (error) {
        throw new WalletSignMessageError(error?.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
}
const BackpackWalletName = "Backpack";
class BackpackWalletAdapter extends BaseMessageSignerWalletAdapter {
  constructor(config = {}) {
    super();
    this.name = BackpackWalletName;
    this.url = "https://backpack.app";
    this.icon = "data:image/png;base64,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";
    this.supportedTransactionVersions = null;
    this._readyState = typeof window === "undefined" || typeof document === "undefined" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;
    this._disconnected = () => {
      const wallet = this._wallet;
      if (wallet) {
        wallet.off("disconnect", this._disconnected);
        this._wallet = null;
        this._publicKey = null;
        this.emit("error", new WalletDisconnectedError());
        this.emit("disconnect");
      }
    };
    this._connecting = false;
    this._wallet = null;
    this._publicKey = null;
    if (this._readyState !== WalletReadyState.Unsupported) {
      scopePollingDetectionStrategy(() => {
        if (window.backpack?.isBackpack) {
          this._readyState = WalletReadyState.Installed;
          this.emit("readyStateChange", this._readyState);
          return true;
        }
        return false;
      });
    }
  }
  get publicKey() {
    return this._publicKey;
  }
  get connecting() {
    return this._connecting;
  }
  get connected() {
    return !!this._wallet?.isConnected;
  }
  get readyState() {
    return this._readyState;
  }
  async connect() {
    try {
      if (this.connected || this.connecting)
        return;
      if (this._readyState !== WalletReadyState.Installed)
        throw new WalletNotReadyError();
      this._connecting = true;
      const wallet = window.backpack;
      try {
        await wallet.connect();
      } catch (error) {
        throw new WalletConnectionError(error?.message, error);
      }
      if (!wallet.publicKey)
        throw new WalletAccountError();
      let publicKey2;
      try {
        publicKey2 = new PublicKey(wallet.publicKey.toBytes());
      } catch (error) {
        throw new WalletPublicKeyError(error?.message, error);
      }
      wallet.on("disconnect", this._disconnected);
      this._wallet = wallet;
      this._publicKey = publicKey2;
      this.emit("connect", publicKey2);
    } catch (error) {
      this.emit("error", error);
      throw error;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    const wallet = this._wallet;
    if (wallet) {
      wallet.off("disconnect", this._disconnected);
      this._wallet = null;
      this._publicKey = null;
      try {
        await wallet.disconnect();
      } catch (error) {
        this.emit("error", new WalletDisconnectionError(error?.message, error));
      }
    }
    this.emit("disconnect");
  }
  async sendTransaction(transaction, connection, options = {}) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      const { signers, ...sendOptions } = options;
      try {
        return await wallet.send(transaction, signers, sendOptions, connection, this.publicKey);
      } catch (error) {
        throw new WalletSendTransactionError(error?.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signTransaction(transaction) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signTransaction(transaction, this.publicKey);
      } catch (error) {
        throw new WalletSignTransactionError(error?.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signAllTransactions(transactions) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signAllTransactions(transactions, this.publicKey);
      } catch (error) {
        throw new WalletSignTransactionError(error?.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
  async signMessage(message) {
    try {
      const wallet = this._wallet;
      if (!wallet)
        throw new WalletNotConnectedError();
      try {
        return await wallet.signMessage(message, this.publicKey);
      } catch (error) {
        throw new WalletSignMessageError(error?.message, error);
      }
    } catch (error) {
      this.emit("error", error);
      throw error;
    }
  }
}
function base(ALPHABET2) {
  if (ALPHABET2.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  const BASE_MAP = new Uint8Array(256);
  for (let j2 = 0; j2 < BASE_MAP.length; j2++) {
    BASE_MAP[j2] = 255;
  }
  for (let i = 0; i < ALPHABET2.length; i++) {
    const x2 = ALPHABET2.charAt(i);
    const xc = x2.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x2 + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  const BASE2 = ALPHABET2.length;
  const LEADER = ALPHABET2.charAt(0);
  const FACTOR = Math.log(BASE2) / Math.log(256);
  const iFACTOR = Math.log(256) / Math.log(BASE2);
  function encode2(source) {
    if (source instanceof Uint8Array) ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    let zeroes = 0;
    let length = 0;
    let pbegin = 0;
    const pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    const size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    const b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      let carry = source[pbegin];
      let i = 0;
      for (let it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE2 >>> 0;
        carry = carry / BASE2 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i;
      pbegin++;
    }
    let it2 = size - length;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    let str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET2.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    let psz = 0;
    let zeroes = 0;
    let length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    const size = (source.length - psz) * FACTOR + 1 >>> 0;
    const b256 = new Uint8Array(size);
    while (psz < source.length) {
      const charCode = source.charCodeAt(psz);
      if (charCode > 255) {
        return;
      }
      let carry = BASE_MAP[charCode];
      if (carry === 255) {
        return;
      }
      let i = 0;
      for (let it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {
        carry += BASE2 * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length = i;
      psz++;
    }
    let it4 = size - length;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    const vch = new Uint8Array(zeroes + (size - it4));
    let j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode2(string2) {
    const buffer2 = decodeUnsafe(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error("Non-base" + BASE2 + " character");
  }
  return {
    encode: encode2,
    decodeUnsafe,
    decode: decode2
  };
}
var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
const base58 = base(ALPHABET);
function formatSiwsMessage(message) {
  const issuedAtDate = new Date(Number(message.issued_at / BigInt(1e6)));
  const expirationDate = new Date(Number(message.expiration_time / BigInt(1e6)));
  let formattedMessage = `${message.domain} wants you to sign in with your Solana account:
`;
  formattedMessage += `${message.address}

`;
  formattedMessage += (message.statement || "") + "\n\n";
  formattedMessage += `URI: ${message.uri}
`;
  formattedMessage += `Version: ${message.version}
`;
  formattedMessage += `Chain ID: ${message.chain_id || "solana"}
`;
  formattedMessage += `Nonce: ${message.nonce}
`;
  formattedMessage += `Issued At: ${issuedAtDate.toISOString()}
`;
  formattedMessage += `Expiration Time: ${expirationDate.toISOString()}`;
  if (message.request_id) formattedMessage += `
Request ID: ${message.request_id}`;
  if (message.resources) {
    formattedMessage += `
Resources:`;
    message.resources.forEach((resource) => {
      formattedMessage += `
- ${resource}`;
    });
  }
  return formattedMessage;
}
const idlFactory = ({ IDL }) => {
  const RuntimeFeature = IDL.Variant({
    "IncludeUriInSeed": IDL.Null,
    "DisablePrincipalToSolMapping": IDL.Null,
    "DisableSolToPrincipalMapping": IDL.Null
  });
  IDL.Record({
    "uri": IDL.Text,
    "runtime_features": IDL.Opt(IDL.Vec(RuntimeFeature)),
    "domain": IDL.Text,
    "statement": IDL.Opt(IDL.Text),
    "scheme": IDL.Opt(IDL.Text),
    "salt": IDL.Text,
    "session_expires_in": IDL.Opt(IDL.Nat64),
    "targets": IDL.Opt(IDL.Vec(IDL.Text)),
    "chain_id": IDL.Opt(IDL.Text),
    "sign_in_expires_in": IDL.Opt(IDL.Nat64)
  });
  const Principal2 = IDL.Vec(IDL.Nat8);
  const Address = IDL.Text;
  const GetAddressResponse = IDL.Variant({ "Ok": Address, "Err": IDL.Text });
  const GetPrincipalResponse = IDL.Variant({
    "Ok": Principal2,
    "Err": IDL.Text
  });
  const PublicKey2 = IDL.Vec(IDL.Nat8);
  const SessionKey = PublicKey2;
  const Timestamp = IDL.Nat64;
  const Delegation2 = IDL.Record({
    "pubkey": PublicKey2,
    "targets": IDL.Opt(IDL.Vec(IDL.Principal)),
    "expiration": Timestamp
  });
  const SignedDelegation = IDL.Record({
    "signature": IDL.Vec(IDL.Nat8),
    "delegation": Delegation2
  });
  const GetDelegationResponse = IDL.Variant({
    "Ok": SignedDelegation,
    "Err": IDL.Text
  });
  const SiwsSignature = IDL.Text;
  const Nonce = IDL.Text;
  const CanisterPublicKey = PublicKey2;
  const LoginDetails = IDL.Record({
    "user_canister_pubkey": CanisterPublicKey,
    "expiration": Timestamp
  });
  const LoginResponse = IDL.Variant({ "Ok": LoginDetails, "Err": IDL.Text });
  const SiwsMessage = IDL.Record({
    "uri": IDL.Text,
    "issued_at": IDL.Nat64,
    "domain": IDL.Text,
    "statement": IDL.Text,
    "version": IDL.Nat32,
    "chain_id": IDL.Text,
    "address": Address,
    "nonce": IDL.Text,
    "expiration_time": IDL.Nat64
  });
  const PrepareLoginResponse = IDL.Variant({
    "Ok": SiwsMessage,
    "Err": IDL.Text
  });
  return IDL.Service({
    "get_address": IDL.Func([Principal2], [GetAddressResponse], ["query"]),
    "get_caller_address": IDL.Func([], [GetAddressResponse], ["query"]),
    "get_principal": IDL.Func([Address], [GetPrincipalResponse], ["query"]),
    "siws_get_delegation": IDL.Func(
      [Address, SessionKey, Timestamp],
      [GetDelegationResponse],
      ["query"]
    ),
    "siws_login": IDL.Func(
      [SiwsSignature, Address, SessionKey, Nonce],
      [LoginResponse],
      []
    ),
    "siws_prepare_login": IDL.Func([Address], [PrepareLoginResponse], [])
  });
};
var N = Object.create;
var H = Object.defineProperty;
var F = Object.getOwnPropertyDescriptor;
var j = Object.getOwnPropertyNames;
var V = Object.getPrototypeOf, G = Object.prototype.hasOwnProperty;
var z = (e3, t) => () => (t || e3((t = { exports: {} }).exports, t), t.exports);
var v = (e3, t, n, r) => {
  if (t && typeof t == "object" || typeof t == "function") for (let o of j(t)) !G.call(e3, o) && o !== n && H(e3, o, { get: () => t[o], enumerable: !(r = F(t, o)) || r.enumerable });
  return e3;
};
var J$1 = (e3, t, n) => (n = e3 != null ? N(V(e3)) : {}, v(!e3 || !e3.__esModule ? H(n, "default", { value: e3, enumerable: true }) : n, e3));
function W(e3) {
  return e3 instanceof Uint8Array || e3 != null && typeof e3 == "object" && e3.constructor.name === "Uint8Array";
}
function A(e3, ...t) {
  if (!W(e3)) throw new Error("Uint8Array expected");
  if (t.length > 0 && !t.includes(e3.length)) throw new Error(`Uint8Array expected of length ${t}, not of length=${e3.length}`);
}
function U(e3, t = true) {
  if (e3.destroyed) throw new Error("Hash instance has been destroyed");
  if (t && e3.finished) throw new Error("Hash#digest() has already been called");
}
function S(e3, t) {
  A(e3);
  let n = t.outputLen;
  if (e3.length < n) throw new Error(`digestInto() expects output buffer of length at least ${n}`);
}
var g = (e3) => new DataView(e3.buffer, e3.byteOffset, e3.byteLength), h = (e3, t) => e3 << 32 - t | e3 >>> t;
new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function $(e3) {
  if (typeof e3 != "string") throw new Error(`utf8ToBytes expected string, got ${typeof e3}`);
  return new Uint8Array(new TextEncoder().encode(e3));
}
function B(e3) {
  return typeof e3 == "string" && (e3 = $(e3)), A(e3), e3;
}
var d = class {
  clone() {
    return this._cloneInto();
  }
};
function T(e3) {
  let t = (r) => e3().update(B(r)).digest(), n = e3();
  return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = () => e3(), t;
}
function M(e3, t, n, r) {
  if (typeof e3.setBigUint64 == "function") return e3.setBigUint64(t, n, r);
  let o = BigInt(32), c = BigInt(4294967295), i = Number(n >> o & c), s = Number(n & c), u = r ? 4 : 0, a = r ? 0 : 4;
  e3.setUint32(t + u, i, r), e3.setUint32(t + a, s, r);
}
var C = (e3, t, n) => e3 & t ^ ~e3 & n, k = (e3, t, n) => e3 & t ^ e3 & n ^ t & n, w = class extends d {
  constructor(t, n, r, o) {
    super(), this.blockLen = t, this.outputLen = n, this.padOffset = r, this.isLE = o, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(t), this.view = g(this.buffer);
  }
  update(t) {
    U(this);
    let { view: n, buffer: r, blockLen: o } = this;
    t = B(t);
    let c = t.length;
    for (let i = 0; i < c; ) {
      let s = Math.min(o - this.pos, c - i);
      if (s === o) {
        let u = g(t);
        for (; o <= c - i; i += o) this.process(u, i);
        continue;
      }
      r.set(t.subarray(i, i + s), this.pos), this.pos += s, i += s, this.pos === o && (this.process(n, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    U(this), S(t, this), this.finished = true;
    let { buffer: n, view: r, blockLen: o, isLE: c } = this, { pos: i } = this;
    n[i++] = 128, this.buffer.subarray(i).fill(0), this.padOffset > o - i && (this.process(r, 0), i = 0);
    for (let f2 = i; f2 < o; f2++) n[f2] = 0;
    M(r, o - 8, BigInt(this.length * 8), c), this.process(r, 0);
    let s = g(t), u = this.outputLen;
    if (u % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    let a = u / 4, p = this.get();
    if (a > p.length) throw new Error("_sha2: outputLen bigger than state");
    for (let f2 = 0; f2 < a; f2++) s.setUint32(4 * f2, p[f2], c);
  }
  digest() {
    let { buffer: t, outputLen: n } = this;
    this.digestInto(t);
    let r = t.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    let { blockLen: n, buffer: r, length: o, finished: c, destroyed: i, pos: s } = this;
    return t.length = o, t.pos = s, t.finished = c, t.destroyed = i, o % n && t.buffer.set(r), t;
  }
};
var P = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]), x = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]), b = new Uint32Array(64), E = class extends w {
  constructor() {
    super(64, 32, 8, false), this.A = x[0] | 0, this.B = x[1] | 0, this.C = x[2] | 0, this.D = x[3] | 0, this.E = x[4] | 0, this.F = x[5] | 0, this.G = x[6] | 0, this.H = x[7] | 0;
  }
  get() {
    let { A: t, B: n, C: r, D: o, E: c, F: i, G: s, H: u } = this;
    return [t, n, r, o, c, i, s, u];
  }
  set(t, n, r, o, c, i, s, u) {
    this.A = t | 0, this.B = n | 0, this.C = r | 0, this.D = o | 0, this.E = c | 0, this.F = i | 0, this.G = s | 0, this.H = u | 0;
  }
  process(t, n) {
    for (let f2 = 0; f2 < 16; f2++, n += 4) b[f2] = t.getUint32(n, false);
    for (let f2 = 16; f2 < 64; f2++) {
      let y = b[f2 - 15], l = b[f2 - 2], I = h(y, 7) ^ h(y, 18) ^ y >>> 3, m = h(l, 17) ^ h(l, 19) ^ l >>> 10;
      b[f2] = m + b[f2 - 7] + I + b[f2 - 16] | 0;
    }
    let { A: r, B: o, C: c, D: i, E: s, F: u, G: a, H: p } = this;
    for (let f2 = 0; f2 < 64; f2++) {
      let y = h(s, 6) ^ h(s, 11) ^ h(s, 25), l = p + y + C(s, u, a) + P[f2] + b[f2] | 0, m = (h(r, 2) ^ h(r, 13) ^ h(r, 22)) + k(r, o, c) | 0;
      p = a, a = u, u = s, s = i + l | 0, i = c, c = o, o = r, r = l + m | 0;
    }
    r = r + this.A | 0, o = o + this.B | 0, c = c + this.C | 0, i = i + this.D | 0, s = s + this.E | 0, u = u + this.F | 0, a = a + this.G | 0, p = p + this.H | 0, this.set(r, o, c, i, s, u, a, p);
  }
  roundClean() {
    b.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}, L = class extends E {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
var O = T(() => new L());
var D = class e {
  constructor(t) {
    this.bytes = t;
  }
  static fromHex(t) {
    return new e(Uint8Array.from(bufferExports.Buffer.from(t, "hex")));
  }
  static fromPrincipal({ principal: t, subAccount: n = _.fromID(0) }) {
    let r = asciiStringToByteArray(`
account-id`), o = O.create();
    o.update(arrayOfNumberToUint8Array([...r, ...t.toUint8Array(), ...n.toUint8Array()]));
    let c = o.digest(), i = bigEndianCrc32(c), s = new Uint8Array([...i, ...c]);
    return new e(s);
  }
  toHex() {
    return uint8ArrayToHexString(this.bytes);
  }
  toUint8Array() {
    return this.bytes;
  }
  toNumbers() {
    return Array.from(this.bytes);
  }
  toAccountIdentifierHash() {
    return { hash: this.toUint8Array() };
  }
}, _ = class e2 {
  constructor(t) {
    this.bytes = t;
  }
  static fromBytes(t) {
    return t.length != 32 ? Error("Subaccount length must be 32-bytes") : new e2(t);
  }
  static fromPrincipal(t) {
    let n = new Uint8Array(32).fill(0), r = t.toUint8Array();
    n[0] = r.length;
    for (let o = 0; o < r.length; o++) n[1 + o] = r[o];
    return new e2(n);
  }
  static fromID(t) {
    if (t < 0) throw new Error("Number cannot be negative");
    if (t > Number.MAX_SAFE_INTEGER) throw new Error("Number is too large to fit in 32 bytes.");
    let n = new DataView(new ArrayBuffer(32));
    if (typeof n.setBigUint64 == "function") n.setBigUint64(24, BigInt(t));
    else {
      let o = BigInt(1) << BigInt(32);
      n.setUint32(24, Number(BigInt(t) >> BigInt(32))), n.setUint32(28, Number(BigInt(t) % o));
    }
    let r = new Uint8Array(n.buffer);
    return new e2(r);
  }
  toUint8Array() {
    return this.bytes;
  }
};
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
Principal.fromText("ryjl3-tyaaa-aaaaa-aaaba-cai");
Principal.fromText("qhbym-qaaaa-aaaaa-aaafq-cai");
BigInt(1095062083);
BigInt(1347768404);
BigInt(1e4);
BigInt(1e8);
var J = z((S2) => {
  S2.byteLength = gr;
  S2.toByteArray = Ar;
  S2.fromByteArray = Tr;
  var B2 = [], x2 = [], Er = typeof Uint8Array < "u" ? Uint8Array : Array, M2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (g2 = 0, X = M2.length; g2 < X; ++g2) B2[g2] = M2[g2], x2[M2.charCodeAt(g2)] = g2;
  var g2, X;
  x2[45] = 62;
  x2[95] = 63;
  function z2(i) {
    var r = i.length;
    if (r % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    var t = i.indexOf("=");
    t === -1 && (t = r);
    var e3 = t === r ? 0 : 4 - t % 4;
    return [t, e3];
  }
  function gr(i) {
    var r = z2(i), t = r[0], e3 = r[1];
    return (t + e3) * 3 / 4 - e3;
  }
  function Ir(i, r, t) {
    return (r + t) * 3 / 4 - t;
  }
  function Ar(i) {
    var r, t = z2(i), e3 = t[0], n = t[1], o = new Er(Ir(i, e3, n)), u = 0, f2 = n > 0 ? e3 - 4 : e3, h2;
    for (h2 = 0; h2 < f2; h2 += 4) r = x2[i.charCodeAt(h2)] << 18 | x2[i.charCodeAt(h2 + 1)] << 12 | x2[i.charCodeAt(h2 + 2)] << 6 | x2[i.charCodeAt(h2 + 3)], o[u++] = r >> 16 & 255, o[u++] = r >> 8 & 255, o[u++] = r & 255;
    return n === 2 && (r = x2[i.charCodeAt(h2)] << 2 | x2[i.charCodeAt(h2 + 1)] >> 4, o[u++] = r & 255), n === 1 && (r = x2[i.charCodeAt(h2)] << 10 | x2[i.charCodeAt(h2 + 1)] << 4 | x2[i.charCodeAt(h2 + 2)] >> 2, o[u++] = r >> 8 & 255, o[u++] = r & 255), o;
  }
  function Fr(i) {
    return B2[i >> 18 & 63] + B2[i >> 12 & 63] + B2[i >> 6 & 63] + B2[i & 63];
  }
  function Ur(i, r, t) {
    for (var e3, n = [], o = r; o < t; o += 3) e3 = (i[o] << 16 & 16711680) + (i[o + 1] << 8 & 65280) + (i[o + 2] & 255), n.push(Fr(e3));
    return n.join("");
  }
  function Tr(i) {
    for (var r, t = i.length, e3 = t % 3, n = [], o = 16383, u = 0, f2 = t - e3; u < f2; u += o) n.push(Ur(i, u, u + o > f2 ? f2 : u + o));
    return e3 === 1 ? (r = i[t - 1], n.push(B2[r >> 2] + B2[r << 4 & 63] + "==")) : e3 === 2 && (r = (i[t - 2] << 8) + i[t - 1], n.push(B2[r >> 10] + B2[r >> 4 & 63] + B2[r << 2 & 63] + "=")), n.join("");
  }
});
var K = z(($2) => {
  $2.read = function(i, r, t, e3, n) {
    var o, u, f2 = n * 8 - e3 - 1, h2 = (1 << f2) - 1, l = h2 >> 1, s = -7, p = t ? n - 1 : 0, A2 = t ? -1 : 1, w2 = i[r + p];
    for (p += A2, o = w2 & (1 << -s) - 1, w2 >>= -s, s += f2; s > 0; o = o * 256 + i[r + p], p += A2, s -= 8) ;
    for (u = o & (1 << -s) - 1, o >>= -s, s += e3; s > 0; u = u * 256 + i[r + p], p += A2, s -= 8) ;
    if (o === 0) o = 1 - l;
    else {
      if (o === h2) return u ? NaN : (w2 ? -1 : 1) * (1 / 0);
      u = u + Math.pow(2, e3), o = o - l;
    }
    return (w2 ? -1 : 1) * u * Math.pow(2, o - e3);
  };
  $2.write = function(i, r, t, e3, n, o) {
    var u, f2, h2, l = o * 8 - n - 1, s = (1 << l) - 1, p = s >> 1, A2 = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, w2 = e3 ? 0 : o - 1, b2 = e3 ? 1 : -1, yr = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;
    for (r = Math.abs(r), isNaN(r) || r === 1 / 0 ? (f2 = isNaN(r) ? 1 : 0, u = s) : (u = Math.floor(Math.log(r) / Math.LN2), r * (h2 = Math.pow(2, -u)) < 1 && (u--, h2 *= 2), u + p >= 1 ? r += A2 / h2 : r += A2 * Math.pow(2, 1 - p), r * h2 >= 2 && (u++, h2 /= 2), u + p >= s ? (f2 = 0, u = s) : u + p >= 1 ? (f2 = (r * h2 - 1) * Math.pow(2, n), u = u + p) : (f2 = r * Math.pow(2, p - 1) * Math.pow(2, n), u = 0)); n >= 8; i[t + w2] = f2 & 255, w2 += b2, f2 /= 256, n -= 8) ;
    for (u = u << n | f2, l += n; l > 0; i[t + w2] = u & 255, w2 += b2, u /= 256, l -= 8) ;
    i[t + w2 - b2] |= yr * 128;
  };
});
var ar = z((R) => {
  var D2 = J(), U2 = K(), Z = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  R.Buffer = c;
  R.SlowBuffer = br;
  R.INSPECT_MAX_BYTES = 50;
  var _2 = 2147483647;
  R.kMaxLength = _2;
  c.TYPED_ARRAY_SUPPORT = Rr();
  !c.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  function Rr() {
    try {
      let i = new Uint8Array(1), r = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(r, Uint8Array.prototype), Object.setPrototypeOf(i, r), i.foo() === 42;
    } catch {
      return false;
    }
  }
  Object.defineProperty(c.prototype, "parent", { enumerable: true, get: function() {
    if (c.isBuffer(this)) return this.buffer;
  } });
  Object.defineProperty(c.prototype, "offset", { enumerable: true, get: function() {
    if (c.isBuffer(this)) return this.byteOffset;
  } });
  function m(i) {
    if (i > _2) throw new RangeError('The value "' + i + '" is invalid for option "size"');
    let r = new Uint8Array(i);
    return Object.setPrototypeOf(r, c.prototype), r;
  }
  function c(i, r, t) {
    if (typeof i == "number") {
      if (typeof r == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
      return G2(i);
    }
    return tr(i, r, t);
  }
  c.poolSize = 8192;
  function tr(i, r, t) {
    if (typeof i == "string") return Sr(i, r);
    if (ArrayBuffer.isView(i)) return _r(i);
    if (i == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i);
    if (d2(i, ArrayBuffer) || i && d2(i.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (d2(i, SharedArrayBuffer) || i && d2(i.buffer, SharedArrayBuffer))) return O2(i, r, t);
    if (typeof i == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
    let e3 = i.valueOf && i.valueOf();
    if (e3 != null && e3 !== i) return c.from(e3, r, t);
    let n = kr(i);
    if (n) return n;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof i[Symbol.toPrimitive] == "function") return c.from(i[Symbol.toPrimitive]("string"), r, t);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i);
  }
  c.from = function(i, r, t) {
    return tr(i, r, t);
  };
  Object.setPrototypeOf(c.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(c, Uint8Array);
  function ir(i) {
    if (typeof i != "number") throw new TypeError('"size" argument must be of type number');
    if (i < 0) throw new RangeError('The value "' + i + '" is invalid for option "size"');
  }
  function Cr(i, r, t) {
    return ir(i), i <= 0 ? m(i) : r !== void 0 ? typeof t == "string" ? m(i).fill(r, t) : m(i).fill(r) : m(i);
  }
  c.alloc = function(i, r, t) {
    return Cr(i, r, t);
  };
  function G2(i) {
    return ir(i), m(i < 0 ? 0 : H2(i) | 0);
  }
  c.allocUnsafe = function(i) {
    return G2(i);
  };
  c.allocUnsafeSlow = function(i) {
    return G2(i);
  };
  function Sr(i, r) {
    if ((typeof r != "string" || r === "") && (r = "utf8"), !c.isEncoding(r)) throw new TypeError("Unknown encoding: " + r);
    let t = er(i, r) | 0, e3 = m(t), n = e3.write(i, r);
    return n !== t && (e3 = e3.slice(0, n)), e3;
  }
  function P2(i) {
    let r = i.length < 0 ? 0 : H2(i.length) | 0, t = m(r);
    for (let e3 = 0; e3 < r; e3 += 1) t[e3] = i[e3] & 255;
    return t;
  }
  function _r(i) {
    if (d2(i, Uint8Array)) {
      let r = new Uint8Array(i);
      return O2(r.buffer, r.byteOffset, r.byteLength);
    }
    return P2(i);
  }
  function O2(i, r, t) {
    if (r < 0 || i.byteLength < r) throw new RangeError('"offset" is outside of buffer bounds');
    if (i.byteLength < r + (t || 0)) throw new RangeError('"length" is outside of buffer bounds');
    let e3;
    return r === void 0 && t === void 0 ? e3 = new Uint8Array(i) : t === void 0 ? e3 = new Uint8Array(i, r) : e3 = new Uint8Array(i, r, t), Object.setPrototypeOf(e3, c.prototype), e3;
  }
  function kr(i) {
    if (c.isBuffer(i)) {
      let r = H2(i.length) | 0, t = m(r);
      return t.length === 0 || i.copy(t, 0, 0, r), t;
    }
    if (i.length !== void 0) return typeof i.length != "number" || W2(i.length) ? m(0) : P2(i);
    if (i.type === "Buffer" && Array.isArray(i.data)) return P2(i.data);
  }
  function H2(i) {
    if (i >= _2) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + _2.toString(16) + " bytes");
    return i | 0;
  }
  function br(i) {
    return +i != i && (i = 0), c.alloc(+i);
  }
  c.isBuffer = function(r) {
    return r != null && r._isBuffer === true && r !== c.prototype;
  };
  c.compare = function(r, t) {
    if (d2(r, Uint8Array) && (r = c.from(r, r.offset, r.byteLength)), d2(t, Uint8Array) && (t = c.from(t, t.offset, t.byteLength)), !c.isBuffer(r) || !c.isBuffer(t)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (r === t) return 0;
    let e3 = r.length, n = t.length;
    for (let o = 0, u = Math.min(e3, n); o < u; ++o) if (r[o] !== t[o]) {
      e3 = r[o], n = t[o];
      break;
    }
    return e3 < n ? -1 : n < e3 ? 1 : 0;
  };
  c.isEncoding = function(r) {
    switch (String(r).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  c.concat = function(r, t) {
    if (!Array.isArray(r)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (r.length === 0) return c.alloc(0);
    let e3;
    if (t === void 0) for (t = 0, e3 = 0; e3 < r.length; ++e3) t += r[e3].length;
    let n = c.allocUnsafe(t), o = 0;
    for (e3 = 0; e3 < r.length; ++e3) {
      let u = r[e3];
      if (d2(u, Uint8Array)) o + u.length > n.length ? (c.isBuffer(u) || (u = c.from(u)), u.copy(n, o)) : Uint8Array.prototype.set.call(n, u, o);
      else if (c.isBuffer(u)) u.copy(n, o);
      else throw new TypeError('"list" argument must be an Array of Buffers');
      o += u.length;
    }
    return n;
  };
  function er(i, r) {
    if (c.isBuffer(i)) return i.length;
    if (ArrayBuffer.isView(i) || d2(i, ArrayBuffer)) return i.byteLength;
    if (typeof i != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof i);
    let t = i.length, e3 = arguments.length > 2 && arguments[2] === true;
    if (!e3 && t === 0) return 0;
    let n = false;
    for (; ; ) switch (r) {
      case "ascii":
      case "latin1":
      case "binary":
        return t;
      case "utf8":
      case "utf-8":
        return q(i).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return t * 2;
      case "hex":
        return t >>> 1;
      case "base64":
        return lr(i).length;
      default:
        if (n) return e3 ? -1 : q(i).length;
        r = ("" + r).toLowerCase(), n = true;
    }
  }
  c.byteLength = er;
  function Lr(i, r, t) {
    let e3 = false;
    if ((r === void 0 || r < 0) && (r = 0), r > this.length || ((t === void 0 || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, r >>>= 0, t <= r)) return "";
    for (i || (i = "utf8"); ; ) switch (i) {
      case "hex":
        return Yr(this, r, t);
      case "utf8":
      case "utf-8":
        return or(this, r, t);
      case "ascii":
        return Gr(this, r, t);
      case "latin1":
      case "binary":
        return Hr(this, r, t);
      case "base64":
        return Or(this, r, t);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return Wr(this, r, t);
      default:
        if (e3) throw new TypeError("Unknown encoding: " + i);
        i = (i + "").toLowerCase(), e3 = true;
    }
  }
  c.prototype._isBuffer = true;
  function I(i, r, t) {
    let e3 = i[r];
    i[r] = i[t], i[t] = e3;
  }
  c.prototype.swap16 = function() {
    let r = this.length;
    if (r % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let t = 0; t < r; t += 2) I(this, t, t + 1);
    return this;
  };
  c.prototype.swap32 = function() {
    let r = this.length;
    if (r % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let t = 0; t < r; t += 4) I(this, t, t + 3), I(this, t + 1, t + 2);
    return this;
  };
  c.prototype.swap64 = function() {
    let r = this.length;
    if (r % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let t = 0; t < r; t += 8) I(this, t, t + 7), I(this, t + 1, t + 6), I(this, t + 2, t + 5), I(this, t + 3, t + 4);
    return this;
  };
  c.prototype.toString = function() {
    let r = this.length;
    return r === 0 ? "" : arguments.length === 0 ? or(this, 0, r) : Lr.apply(this, arguments);
  };
  c.prototype.toLocaleString = c.prototype.toString;
  c.prototype.equals = function(r) {
    if (!c.isBuffer(r)) throw new TypeError("Argument must be a Buffer");
    return this === r ? true : c.compare(this, r) === 0;
  };
  c.prototype.inspect = function() {
    let r = "", t = R.INSPECT_MAX_BYTES;
    return r = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (r += " ... "), "<Buffer " + r + ">";
  };
  Z && (c.prototype[Z] = c.prototype.inspect);
  c.prototype.compare = function(r, t, e3, n, o) {
    if (d2(r, Uint8Array) && (r = c.from(r, r.offset, r.byteLength)), !c.isBuffer(r)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof r);
    if (t === void 0 && (t = 0), e3 === void 0 && (e3 = r ? r.length : 0), n === void 0 && (n = 0), o === void 0 && (o = this.length), t < 0 || e3 > r.length || n < 0 || o > this.length) throw new RangeError("out of range index");
    if (n >= o && t >= e3) return 0;
    if (n >= o) return -1;
    if (t >= e3) return 1;
    if (t >>>= 0, e3 >>>= 0, n >>>= 0, o >>>= 0, this === r) return 0;
    let u = o - n, f2 = e3 - t, h2 = Math.min(u, f2), l = this.slice(n, o), s = r.slice(t, e3);
    for (let p = 0; p < h2; ++p) if (l[p] !== s[p]) {
      u = l[p], f2 = s[p];
      break;
    }
    return u < f2 ? -1 : f2 < u ? 1 : 0;
  };
  function nr(i, r, t, e3, n) {
    if (i.length === 0) return -1;
    if (typeof t == "string" ? (e3 = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, W2(t) && (t = n ? 0 : i.length - 1), t < 0 && (t = i.length + t), t >= i.length) {
      if (n) return -1;
      t = i.length - 1;
    } else if (t < 0) if (n) t = 0;
    else return -1;
    if (typeof r == "string" && (r = c.from(r, e3)), c.isBuffer(r)) return r.length === 0 ? -1 : Q(i, r, t, e3, n);
    if (typeof r == "number") return r = r & 255, typeof Uint8Array.prototype.indexOf == "function" ? n ? Uint8Array.prototype.indexOf.call(i, r, t) : Uint8Array.prototype.lastIndexOf.call(i, r, t) : Q(i, [r], t, e3, n);
    throw new TypeError("val must be string, number or Buffer");
  }
  function Q(i, r, t, e3, n) {
    let o = 1, u = i.length, f2 = r.length;
    if (e3 !== void 0 && (e3 = String(e3).toLowerCase(), e3 === "ucs2" || e3 === "ucs-2" || e3 === "utf16le" || e3 === "utf-16le")) {
      if (i.length < 2 || r.length < 2) return -1;
      o = 2, u /= 2, f2 /= 2, t /= 2;
    }
    function h2(s, p) {
      return o === 1 ? s[p] : s.readUInt16BE(p * o);
    }
    let l;
    if (n) {
      let s = -1;
      for (l = t; l < u; l++) if (h2(i, l) === h2(r, s === -1 ? 0 : l - s)) {
        if (s === -1 && (s = l), l - s + 1 === f2) return s * o;
      } else s !== -1 && (l -= l - s), s = -1;
    } else for (t + f2 > u && (t = u - f2), l = t; l >= 0; l--) {
      let s = true;
      for (let p = 0; p < f2; p++) if (h2(i, l + p) !== h2(r, p)) {
        s = false;
        break;
      }
      if (s) return l;
    }
    return -1;
  }
  c.prototype.includes = function(r, t, e3) {
    return this.indexOf(r, t, e3) !== -1;
  };
  c.prototype.indexOf = function(r, t, e3) {
    return nr(this, r, t, e3, true);
  };
  c.prototype.lastIndexOf = function(r, t, e3) {
    return nr(this, r, t, e3, false);
  };
  function Nr(i, r, t, e3) {
    t = Number(t) || 0;
    let n = i.length - t;
    e3 ? (e3 = Number(e3), e3 > n && (e3 = n)) : e3 = n;
    let o = r.length;
    e3 > o / 2 && (e3 = o / 2);
    let u;
    for (u = 0; u < e3; ++u) {
      let f2 = parseInt(r.substr(u * 2, 2), 16);
      if (W2(f2)) return u;
      i[t + u] = f2;
    }
    return u;
  }
  function Mr(i, r, t, e3) {
    return k2(q(r, i.length - t), i, t, e3);
  }
  function $r(i, r, t, e3) {
    return k2(zr(r), i, t, e3);
  }
  function Dr(i, r, t, e3) {
    return k2(lr(r), i, t, e3);
  }
  function Pr(i, r, t, e3) {
    return k2(Jr(r, i.length - t), i, t, e3);
  }
  c.prototype.write = function(r, t, e3, n) {
    if (t === void 0) n = "utf8", e3 = this.length, t = 0;
    else if (e3 === void 0 && typeof t == "string") n = t, e3 = this.length, t = 0;
    else if (isFinite(t)) t = t >>> 0, isFinite(e3) ? (e3 = e3 >>> 0, n === void 0 && (n = "utf8")) : (n = e3, e3 = void 0);
    else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    let o = this.length - t;
    if ((e3 === void 0 || e3 > o) && (e3 = o), r.length > 0 && (e3 < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    n || (n = "utf8");
    let u = false;
    for (; ; ) switch (n) {
      case "hex":
        return Nr(this, r, t, e3);
      case "utf8":
      case "utf-8":
        return Mr(this, r, t, e3);
      case "ascii":
      case "latin1":
      case "binary":
        return $r(this, r, t, e3);
      case "base64":
        return Dr(this, r, t, e3);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return Pr(this, r, t, e3);
      default:
        if (u) throw new TypeError("Unknown encoding: " + n);
        n = ("" + n).toLowerCase(), u = true;
    }
  };
  c.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  function Or(i, r, t) {
    return r === 0 && t === i.length ? D2.fromByteArray(i) : D2.fromByteArray(i.slice(r, t));
  }
  function or(i, r, t) {
    t = Math.min(i.length, t);
    let e3 = [], n = r;
    for (; n < t; ) {
      let o = i[n], u = null, f2 = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;
      if (n + f2 <= t) {
        let h2, l, s, p;
        switch (f2) {
          case 1:
            o < 128 && (u = o);
            break;
          case 2:
            h2 = i[n + 1], (h2 & 192) === 128 && (p = (o & 31) << 6 | h2 & 63, p > 127 && (u = p));
            break;
          case 3:
            h2 = i[n + 1], l = i[n + 2], (h2 & 192) === 128 && (l & 192) === 128 && (p = (o & 15) << 12 | (h2 & 63) << 6 | l & 63, p > 2047 && (p < 55296 || p > 57343) && (u = p));
            break;
          case 4:
            h2 = i[n + 1], l = i[n + 2], s = i[n + 3], (h2 & 192) === 128 && (l & 192) === 128 && (s & 192) === 128 && (p = (o & 15) << 18 | (h2 & 63) << 12 | (l & 63) << 6 | s & 63, p > 65535 && p < 1114112 && (u = p));
        }
      }
      u === null ? (u = 65533, f2 = 1) : u > 65535 && (u -= 65536, e3.push(u >>> 10 & 1023 | 55296), u = 56320 | u & 1023), e3.push(u), n += f2;
    }
    return qr(e3);
  }
  var v2 = 4096;
  function qr(i) {
    let r = i.length;
    if (r <= v2) return String.fromCharCode.apply(String, i);
    let t = "", e3 = 0;
    for (; e3 < r; ) t += String.fromCharCode.apply(String, i.slice(e3, e3 += v2));
    return t;
  }
  function Gr(i, r, t) {
    let e3 = "";
    t = Math.min(i.length, t);
    for (let n = r; n < t; ++n) e3 += String.fromCharCode(i[n] & 127);
    return e3;
  }
  function Hr(i, r, t) {
    let e3 = "";
    t = Math.min(i.length, t);
    for (let n = r; n < t; ++n) e3 += String.fromCharCode(i[n]);
    return e3;
  }
  function Yr(i, r, t) {
    let e3 = i.length;
    (!r || r < 0) && (r = 0), (!t || t < 0 || t > e3) && (t = e3);
    let n = "";
    for (let o = r; o < t; ++o) n += Kr[i[o]];
    return n;
  }
  function Wr(i, r, t) {
    let e3 = i.slice(r, t), n = "";
    for (let o = 0; o < e3.length - 1; o += 2) n += String.fromCharCode(e3[o] + e3[o + 1] * 256);
    return n;
  }
  c.prototype.slice = function(r, t) {
    let e3 = this.length;
    r = ~~r, t = t === void 0 ? e3 : ~~t, r < 0 ? (r += e3, r < 0 && (r = 0)) : r > e3 && (r = e3), t < 0 ? (t += e3, t < 0 && (t = 0)) : t > e3 && (t = e3), t < r && (t = r);
    let n = this.subarray(r, t);
    return Object.setPrototypeOf(n, c.prototype), n;
  };
  function a(i, r, t) {
    if (i % 1 !== 0 || i < 0) throw new RangeError("offset is not uint");
    if (i + r > t) throw new RangeError("Trying to access beyond buffer length");
  }
  c.prototype.readUintLE = c.prototype.readUIntLE = function(r, t, e3) {
    r = r >>> 0, t = t >>> 0, e3 || a(r, t, this.length);
    let n = this[r], o = 1, u = 0;
    for (; ++u < t && (o *= 256); ) n += this[r + u] * o;
    return n;
  };
  c.prototype.readUintBE = c.prototype.readUIntBE = function(r, t, e3) {
    r = r >>> 0, t = t >>> 0, e3 || a(r, t, this.length);
    let n = this[r + --t], o = 1;
    for (; t > 0 && (o *= 256); ) n += this[r + --t] * o;
    return n;
  };
  c.prototype.readUint8 = c.prototype.readUInt8 = function(r, t) {
    return r = r >>> 0, t || a(r, 1, this.length), this[r];
  };
  c.prototype.readUint16LE = c.prototype.readUInt16LE = function(r, t) {
    return r = r >>> 0, t || a(r, 2, this.length), this[r] | this[r + 1] << 8;
  };
  c.prototype.readUint16BE = c.prototype.readUInt16BE = function(r, t) {
    return r = r >>> 0, t || a(r, 2, this.length), this[r] << 8 | this[r + 1];
  };
  c.prototype.readUint32LE = c.prototype.readUInt32LE = function(r, t) {
    return r = r >>> 0, t || a(r, 4, this.length), (this[r] | this[r + 1] << 8 | this[r + 2] << 16) + this[r + 3] * 16777216;
  };
  c.prototype.readUint32BE = c.prototype.readUInt32BE = function(r, t) {
    return r = r >>> 0, t || a(r, 4, this.length), this[r] * 16777216 + (this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3]);
  };
  c.prototype.readBigUInt64LE = E2(function(r) {
    r = r >>> 0, T2(r, "offset");
    let t = this[r], e3 = this[r + 7];
    (t === void 0 || e3 === void 0) && C2(r, this.length - 8);
    let n = t + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24, o = this[++r] + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + e3 * 2 ** 24;
    return BigInt(n) + (BigInt(o) << BigInt(32));
  });
  c.prototype.readBigUInt64BE = E2(function(r) {
    r = r >>> 0, T2(r, "offset");
    let t = this[r], e3 = this[r + 7];
    (t === void 0 || e3 === void 0) && C2(r, this.length - 8);
    let n = t * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + this[++r], o = this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + e3;
    return (BigInt(n) << BigInt(32)) + BigInt(o);
  });
  c.prototype.readIntLE = function(r, t, e3) {
    r = r >>> 0, t = t >>> 0, e3 || a(r, t, this.length);
    let n = this[r], o = 1, u = 0;
    for (; ++u < t && (o *= 256); ) n += this[r + u] * o;
    return o *= 128, n >= o && (n -= Math.pow(2, 8 * t)), n;
  };
  c.prototype.readIntBE = function(r, t, e3) {
    r = r >>> 0, t = t >>> 0, e3 || a(r, t, this.length);
    let n = t, o = 1, u = this[r + --n];
    for (; n > 0 && (o *= 256); ) u += this[r + --n] * o;
    return o *= 128, u >= o && (u -= Math.pow(2, 8 * t)), u;
  };
  c.prototype.readInt8 = function(r, t) {
    return r = r >>> 0, t || a(r, 1, this.length), this[r] & 128 ? (255 - this[r] + 1) * -1 : this[r];
  };
  c.prototype.readInt16LE = function(r, t) {
    r = r >>> 0, t || a(r, 2, this.length);
    let e3 = this[r] | this[r + 1] << 8;
    return e3 & 32768 ? e3 | 4294901760 : e3;
  };
  c.prototype.readInt16BE = function(r, t) {
    r = r >>> 0, t || a(r, 2, this.length);
    let e3 = this[r + 1] | this[r] << 8;
    return e3 & 32768 ? e3 | 4294901760 : e3;
  };
  c.prototype.readInt32LE = function(r, t) {
    return r = r >>> 0, t || a(r, 4, this.length), this[r] | this[r + 1] << 8 | this[r + 2] << 16 | this[r + 3] << 24;
  };
  c.prototype.readInt32BE = function(r, t) {
    return r = r >>> 0, t || a(r, 4, this.length), this[r] << 24 | this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3];
  };
  c.prototype.readBigInt64LE = E2(function(r) {
    r = r >>> 0, T2(r, "offset");
    let t = this[r], e3 = this[r + 7];
    (t === void 0 || e3 === void 0) && C2(r, this.length - 8);
    let n = this[r + 4] + this[r + 5] * 2 ** 8 + this[r + 6] * 2 ** 16 + (e3 << 24);
    return (BigInt(n) << BigInt(32)) + BigInt(t + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24);
  });
  c.prototype.readBigInt64BE = E2(function(r) {
    r = r >>> 0, T2(r, "offset");
    let t = this[r], e3 = this[r + 7];
    (t === void 0 || e3 === void 0) && C2(r, this.length - 8);
    let n = (t << 24) + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + this[++r];
    return (BigInt(n) << BigInt(32)) + BigInt(this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + e3);
  });
  c.prototype.readFloatLE = function(r, t) {
    return r = r >>> 0, t || a(r, 4, this.length), U2.read(this, r, true, 23, 4);
  };
  c.prototype.readFloatBE = function(r, t) {
    return r = r >>> 0, t || a(r, 4, this.length), U2.read(this, r, false, 23, 4);
  };
  c.prototype.readDoubleLE = function(r, t) {
    return r = r >>> 0, t || a(r, 8, this.length), U2.read(this, r, true, 52, 8);
  };
  c.prototype.readDoubleBE = function(r, t) {
    return r = r >>> 0, t || a(r, 8, this.length), U2.read(this, r, false, 52, 8);
  };
  function y(i, r, t, e3, n, o) {
    if (!c.isBuffer(i)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (r > n || r < o) throw new RangeError('"value" argument is out of bounds');
    if (t + e3 > i.length) throw new RangeError("Index out of range");
  }
  c.prototype.writeUintLE = c.prototype.writeUIntLE = function(r, t, e3, n) {
    if (r = +r, t = t >>> 0, e3 = e3 >>> 0, !n) {
      let f2 = Math.pow(2, 8 * e3) - 1;
      y(this, r, t, e3, f2, 0);
    }
    let o = 1, u = 0;
    for (this[t] = r & 255; ++u < e3 && (o *= 256); ) this[t + u] = r / o & 255;
    return t + e3;
  };
  c.prototype.writeUintBE = c.prototype.writeUIntBE = function(r, t, e3, n) {
    if (r = +r, t = t >>> 0, e3 = e3 >>> 0, !n) {
      let f2 = Math.pow(2, 8 * e3) - 1;
      y(this, r, t, e3, f2, 0);
    }
    let o = e3 - 1, u = 1;
    for (this[t + o] = r & 255; --o >= 0 && (u *= 256); ) this[t + o] = r / u & 255;
    return t + e3;
  };
  c.prototype.writeUint8 = c.prototype.writeUInt8 = function(r, t, e3) {
    return r = +r, t = t >>> 0, e3 || y(this, r, t, 1, 255, 0), this[t] = r & 255, t + 1;
  };
  c.prototype.writeUint16LE = c.prototype.writeUInt16LE = function(r, t, e3) {
    return r = +r, t = t >>> 0, e3 || y(this, r, t, 2, 65535, 0), this[t] = r & 255, this[t + 1] = r >>> 8, t + 2;
  };
  c.prototype.writeUint16BE = c.prototype.writeUInt16BE = function(r, t, e3) {
    return r = +r, t = t >>> 0, e3 || y(this, r, t, 2, 65535, 0), this[t] = r >>> 8, this[t + 1] = r & 255, t + 2;
  };
  c.prototype.writeUint32LE = c.prototype.writeUInt32LE = function(r, t, e3) {
    return r = +r, t = t >>> 0, e3 || y(this, r, t, 4, 4294967295, 0), this[t + 3] = r >>> 24, this[t + 2] = r >>> 16, this[t + 1] = r >>> 8, this[t] = r & 255, t + 4;
  };
  c.prototype.writeUint32BE = c.prototype.writeUInt32BE = function(r, t, e3) {
    return r = +r, t = t >>> 0, e3 || y(this, r, t, 4, 4294967295, 0), this[t] = r >>> 24, this[t + 1] = r >>> 16, this[t + 2] = r >>> 8, this[t + 3] = r & 255, t + 4;
  };
  function ur(i, r, t, e3, n) {
    sr(r, e3, n, i, t, 7);
    let o = Number(r & BigInt(4294967295));
    i[t++] = o, o = o >> 8, i[t++] = o, o = o >> 8, i[t++] = o, o = o >> 8, i[t++] = o;
    let u = Number(r >> BigInt(32) & BigInt(4294967295));
    return i[t++] = u, u = u >> 8, i[t++] = u, u = u >> 8, i[t++] = u, u = u >> 8, i[t++] = u, t;
  }
  function cr(i, r, t, e3, n) {
    sr(r, e3, n, i, t, 7);
    let o = Number(r & BigInt(4294967295));
    i[t + 7] = o, o = o >> 8, i[t + 6] = o, o = o >> 8, i[t + 5] = o, o = o >> 8, i[t + 4] = o;
    let u = Number(r >> BigInt(32) & BigInt(4294967295));
    return i[t + 3] = u, u = u >> 8, i[t + 2] = u, u = u >> 8, i[t + 1] = u, u = u >> 8, i[t] = u, t + 8;
  }
  c.prototype.writeBigUInt64LE = E2(function(r, t = 0) {
    return ur(this, r, t, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  c.prototype.writeBigUInt64BE = E2(function(r, t = 0) {
    return cr(this, r, t, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  c.prototype.writeIntLE = function(r, t, e3, n) {
    if (r = +r, t = t >>> 0, !n) {
      let h2 = Math.pow(2, 8 * e3 - 1);
      y(this, r, t, e3, h2 - 1, -h2);
    }
    let o = 0, u = 1, f2 = 0;
    for (this[t] = r & 255; ++o < e3 && (u *= 256); ) r < 0 && f2 === 0 && this[t + o - 1] !== 0 && (f2 = 1), this[t + o] = (r / u >> 0) - f2 & 255;
    return t + e3;
  };
  c.prototype.writeIntBE = function(r, t, e3, n) {
    if (r = +r, t = t >>> 0, !n) {
      let h2 = Math.pow(2, 8 * e3 - 1);
      y(this, r, t, e3, h2 - 1, -h2);
    }
    let o = e3 - 1, u = 1, f2 = 0;
    for (this[t + o] = r & 255; --o >= 0 && (u *= 256); ) r < 0 && f2 === 0 && this[t + o + 1] !== 0 && (f2 = 1), this[t + o] = (r / u >> 0) - f2 & 255;
    return t + e3;
  };
  c.prototype.writeInt8 = function(r, t, e3) {
    return r = +r, t = t >>> 0, e3 || y(this, r, t, 1, 127, -128), r < 0 && (r = 255 + r + 1), this[t] = r & 255, t + 1;
  };
  c.prototype.writeInt16LE = function(r, t, e3) {
    return r = +r, t = t >>> 0, e3 || y(this, r, t, 2, 32767, -32768), this[t] = r & 255, this[t + 1] = r >>> 8, t + 2;
  };
  c.prototype.writeInt16BE = function(r, t, e3) {
    return r = +r, t = t >>> 0, e3 || y(this, r, t, 2, 32767, -32768), this[t] = r >>> 8, this[t + 1] = r & 255, t + 2;
  };
  c.prototype.writeInt32LE = function(r, t, e3) {
    return r = +r, t = t >>> 0, e3 || y(this, r, t, 4, 2147483647, -2147483648), this[t] = r & 255, this[t + 1] = r >>> 8, this[t + 2] = r >>> 16, this[t + 3] = r >>> 24, t + 4;
  };
  c.prototype.writeInt32BE = function(r, t, e3) {
    return r = +r, t = t >>> 0, e3 || y(this, r, t, 4, 2147483647, -2147483648), r < 0 && (r = 4294967295 + r + 1), this[t] = r >>> 24, this[t + 1] = r >>> 16, this[t + 2] = r >>> 8, this[t + 3] = r & 255, t + 4;
  };
  c.prototype.writeBigInt64LE = E2(function(r, t = 0) {
    return ur(this, r, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  c.prototype.writeBigInt64BE = E2(function(r, t = 0) {
    return cr(this, r, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function fr(i, r, t, e3, n, o) {
    if (t + e3 > i.length) throw new RangeError("Index out of range");
    if (t < 0) throw new RangeError("Index out of range");
  }
  function hr(i, r, t, e3, n) {
    return r = +r, t = t >>> 0, n || fr(i, r, t, 4), U2.write(i, r, t, e3, 23, 4), t + 4;
  }
  c.prototype.writeFloatLE = function(r, t, e3) {
    return hr(this, r, t, true, e3);
  };
  c.prototype.writeFloatBE = function(r, t, e3) {
    return hr(this, r, t, false, e3);
  };
  function pr(i, r, t, e3, n) {
    return r = +r, t = t >>> 0, n || fr(i, r, t, 8), U2.write(i, r, t, e3, 52, 8), t + 8;
  }
  c.prototype.writeDoubleLE = function(r, t, e3) {
    return pr(this, r, t, true, e3);
  };
  c.prototype.writeDoubleBE = function(r, t, e3) {
    return pr(this, r, t, false, e3);
  };
  c.prototype.copy = function(r, t, e3, n) {
    if (!c.isBuffer(r)) throw new TypeError("argument should be a Buffer");
    if (e3 || (e3 = 0), !n && n !== 0 && (n = this.length), t >= r.length && (t = r.length), t || (t = 0), n > 0 && n < e3 && (n = e3), n === e3 || r.length === 0 || this.length === 0) return 0;
    if (t < 0) throw new RangeError("targetStart out of bounds");
    if (e3 < 0 || e3 >= this.length) throw new RangeError("Index out of range");
    if (n < 0) throw new RangeError("sourceEnd out of bounds");
    n > this.length && (n = this.length), r.length - t < n - e3 && (n = r.length - t + e3);
    let o = n - e3;
    return this === r && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t, e3, n) : Uint8Array.prototype.set.call(r, this.subarray(e3, n), t), o;
  };
  c.prototype.fill = function(r, t, e3, n) {
    if (typeof r == "string") {
      if (typeof t == "string" ? (n = t, t = 0, e3 = this.length) : typeof e3 == "string" && (n = e3, e3 = this.length), n !== void 0 && typeof n != "string") throw new TypeError("encoding must be a string");
      if (typeof n == "string" && !c.isEncoding(n)) throw new TypeError("Unknown encoding: " + n);
      if (r.length === 1) {
        let u = r.charCodeAt(0);
        (n === "utf8" && u < 128 || n === "latin1") && (r = u);
      }
    } else typeof r == "number" ? r = r & 255 : typeof r == "boolean" && (r = Number(r));
    if (t < 0 || this.length < t || this.length < e3) throw new RangeError("Out of range index");
    if (e3 <= t) return this;
    t = t >>> 0, e3 = e3 === void 0 ? this.length : e3 >>> 0, r || (r = 0);
    let o;
    if (typeof r == "number") for (o = t; o < e3; ++o) this[o] = r;
    else {
      let u = c.isBuffer(r) ? r : c.from(r, n), f2 = u.length;
      if (f2 === 0) throw new TypeError('The value "' + r + '" is invalid for argument "value"');
      for (o = 0; o < e3 - t; ++o) this[o + t] = u[o % f2];
    }
    return this;
  };
  var F2 = {};
  function Y(i, r, t) {
    F2[i] = class extends t {
      constructor() {
        super(), Object.defineProperty(this, "message", { value: r.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${i}]`, this.stack, delete this.name;
      }
      get code() {
        return i;
      }
      set code(n) {
        Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: n, writable: true });
      }
      toString() {
        return `${this.name} [${i}]: ${this.message}`;
      }
    };
  }
  Y("ERR_BUFFER_OUT_OF_BOUNDS", function(i) {
    return i ? `${i} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
  }, RangeError);
  Y("ERR_INVALID_ARG_TYPE", function(i, r) {
    return `The "${i}" argument must be of type number. Received type ${typeof r}`;
  }, TypeError);
  Y("ERR_OUT_OF_RANGE", function(i, r, t) {
    let e3 = `The value of "${i}" is out of range.`, n = t;
    return Number.isInteger(t) && Math.abs(t) > 2 ** 32 ? n = rr(String(t)) : typeof t == "bigint" && (n = String(t), (t > BigInt(2) ** BigInt(32) || t < -(BigInt(2) ** BigInt(32))) && (n = rr(n)), n += "n"), e3 += ` It must be ${r}. Received ${n}`, e3;
  }, RangeError);
  function rr(i) {
    let r = "", t = i.length, e3 = i[0] === "-" ? 1 : 0;
    for (; t >= e3 + 4; t -= 3) r = `_${i.slice(t - 3, t)}${r}`;
    return `${i.slice(0, t)}${r}`;
  }
  function jr(i, r, t) {
    T2(r, "offset"), (i[r] === void 0 || i[r + t] === void 0) && C2(r, i.length - (t + 1));
  }
  function sr(i, r, t, e3, n, o) {
    if (i > t || i < r) {
      let u = typeof r == "bigint" ? "n" : "", f2;
      throw r === 0 || r === BigInt(0) ? f2 = `>= 0${u} and < 2${u} ** ${(o + 1) * 8}${u}` : f2 = `>= -(2${u} ** ${(o + 1) * 8 - 1}${u}) and < 2 ** ${(o + 1) * 8 - 1}${u}`, new F2.ERR_OUT_OF_RANGE("value", f2, i);
    }
    jr(e3, n, o);
  }
  function T2(i, r) {
    if (typeof i != "number") throw new F2.ERR_INVALID_ARG_TYPE(r, "number", i);
  }
  function C2(i, r, t) {
    throw Math.floor(i) !== i ? (T2(i, t), new F2.ERR_OUT_OF_RANGE("offset", "an integer", i)) : r < 0 ? new F2.ERR_BUFFER_OUT_OF_BOUNDS() : new F2.ERR_OUT_OF_RANGE("offset", `>= ${0} and <= ${r}`, i);
  }
  var Vr = /[^+/0-9A-Za-z-_]/g;
  function Xr(i) {
    if (i = i.split("=")[0], i = i.trim().replace(Vr, ""), i.length < 2) return "";
    for (; i.length % 4 !== 0; ) i = i + "=";
    return i;
  }
  function q(i, r) {
    r = r || 1 / 0;
    let t, e3 = i.length, n = null, o = [];
    for (let u = 0; u < e3; ++u) {
      if (t = i.charCodeAt(u), t > 55295 && t < 57344) {
        if (!n) {
          if (t > 56319) {
            (r -= 3) > -1 && o.push(239, 191, 189);
            continue;
          } else if (u + 1 === e3) {
            (r -= 3) > -1 && o.push(239, 191, 189);
            continue;
          }
          n = t;
          continue;
        }
        if (t < 56320) {
          (r -= 3) > -1 && o.push(239, 191, 189), n = t;
          continue;
        }
        t = (n - 55296 << 10 | t - 56320) + 65536;
      } else n && (r -= 3) > -1 && o.push(239, 191, 189);
      if (n = null, t < 128) {
        if ((r -= 1) < 0) break;
        o.push(t);
      } else if (t < 2048) {
        if ((r -= 2) < 0) break;
        o.push(t >> 6 | 192, t & 63 | 128);
      } else if (t < 65536) {
        if ((r -= 3) < 0) break;
        o.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);
      } else if (t < 1114112) {
        if ((r -= 4) < 0) break;
        o.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);
      } else throw new Error("Invalid code point");
    }
    return o;
  }
  function zr(i) {
    let r = [];
    for (let t = 0; t < i.length; ++t) r.push(i.charCodeAt(t) & 255);
    return r;
  }
  function Jr(i, r) {
    let t, e3, n, o = [];
    for (let u = 0; u < i.length && !((r -= 2) < 0); ++u) t = i.charCodeAt(u), e3 = t >> 8, n = t % 256, o.push(n), o.push(e3);
    return o;
  }
  function lr(i) {
    return D2.toByteArray(Xr(i));
  }
  function k2(i, r, t, e3) {
    let n;
    for (n = 0; n < e3 && !(n + t >= r.length || n >= i.length); ++n) r[n + t] = i[n];
    return n;
  }
  function d2(i, r) {
    return i instanceof r || i != null && i.constructor != null && i.constructor.name != null && i.constructor.name === r.name;
  }
  function W2(i) {
    return i !== i;
  }
  var Kr = function() {
    let i = "0123456789abcdef", r = new Array(256);
    for (let t = 0; t < 16; ++t) {
      let e3 = t * 16;
      for (let n = 0; n < 16; ++n) r[e3 + n] = i[t] + i[n];
    }
    return r;
  }();
  function E2(i) {
    return typeof BigInt > "u" ? Zr : i;
  }
  function Zr() {
    throw new Error("BigInt not supported");
  }
});
J$1(ar());
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/
function deriveAccountId(principal) {
  try {
    const principalObj = typeof principal === "string" ? Principal.fromText(principal) : principal;
    const accountId = D.fromPrincipal({
      principal: principalObj,
      subAccount: void 0
      // Default subaccount
    }).toHex();
    return accountId;
  } catch (err) {
    console.error("[IcUtils] Error deriving account ID:", err);
    throw err;
  }
}
function isPrincipalAnonymous(principal) {
  try {
    const principalObj = typeof principal === "string" ? Principal.fromText(principal) : principal;
    return principalObj.isAnonymous();
  } catch (err) {
    console.error("[IcUtils] Error checking anonymous principal:", err);
    return true;
  }
}
async function createAccountFromPrincipal(principal) {
  const principalText = typeof principal === "string" ? principal : principal.toText();
  return {
    owner: principalText,
    subaccount: deriveAccountId(principal)
  };
}
async function fetchRootKeyIfNeeded(agent, fetchRootKey) {
  if (fetchRootKey) {
    try {
      await agent.fetchRootKey();
    } catch (e3) {
      console.warn(`Adapter unable to fetch root key. Check replica status.`, e3);
    }
  }
}
function createActorCacheKey(walletName, canisterId, requiresSigning = false) {
  return `${walletName}-${canisterId}-${requiresSigning}`;
}
function isValidPrincipal(principalText) {
  if (!principalText) return false;
  try {
    const principal = Principal.fromText(principalText);
    return !principal.isAnonymous();
  } catch (e3) {
    return false;
  }
}
async function withRetry(operation, maxRetries = 3, delayMs = 1e3) {
  let lastError;
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));
      if (attempt < maxRetries - 1) {
        console.warn(`[IC] Operation failed, retrying (${attempt + 1}/${maxRetries})`, error);
        await new Promise((resolve) => setTimeout(resolve, delayMs * (attempt + 1)));
      }
    }
  }
  throw lastError;
}
var PnpEventType = /* @__PURE__ */ ((PnpEventType2) => {
  PnpEventType2["CONNECTED"] = "connected";
  PnpEventType2["DISCONNECTED"] = "disconnected";
  PnpEventType2["ERROR"] = "error";
  PnpEventType2["LOG"] = "log";
  PnpEventType2["STATE_CHANGE"] = "stateChange";
  PnpEventType2["STATUS_CHANGE"] = "statusChange";
  PnpEventType2["ACCOUNT_CHANGE"] = "accountChange";
  PnpEventType2["ADAPTER_CHANGE"] = "adapterChange";
  PnpEventType2["CONFIG_CHANGE"] = "configChange";
  PnpEventType2["CONFIG_VALIDATION"] = "configValidation";
  PnpEventType2["CACHE_CLEARED"] = "cacheCleared";
  PnpEventType2["PROVIDER_CHANGED"] = "providerChanged";
  PnpEventType2["ACTOR_CREATED"] = "actorCreated";
  return PnpEventType2;
})(PnpEventType || {});
class EventEmitter {
  constructor() {
    this.listeners = /* @__PURE__ */ new Map();
  }
  on(event, listener) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, /* @__PURE__ */ new Set());
    }
    this.listeners.get(event).add(listener);
  }
  off(event, listener) {
    const eventListeners = this.listeners.get(event);
    if (eventListeners) {
      eventListeners.delete(listener);
      if (eventListeners.size === 0) {
        this.listeners.delete(event);
      }
    }
  }
  emit(event, data) {
    const eventListeners = this.listeners.get(event);
    if (eventListeners) {
      const pnpEvent = {
        type: event,
        data,
        timestamp: Date.now()
      };
      eventListeners.forEach((listener) => listener(pnpEvent));
    }
  }
  removeAllListeners(event) {
    if (event) {
      this.listeners.delete(event);
    } else {
      this.listeners.clear();
    }
  }
}
var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
  LogLevel2["DEBUG"] = "debug";
  LogLevel2["INFO"] = "info";
  LogLevel2["WARN"] = "warn";
  LogLevel2["ERROR"] = "error";
  return LogLevel2;
})(LogLevel || {});
class PnpError extends Error {
  constructor(message, code, context) {
    super(message);
    this.code = code;
    this.context = context;
    this.name = "PnpError";
  }
}
class ErrorManager {
  constructor(eventEmitter, logLevel = "info", maxLogs = 1e3) {
    this.logs = [];
    this.maxLogs = 1e3;
    this.eventEmitter = eventEmitter;
    this.logLevel = logLevel;
    this.maxLogs = maxLogs;
  }
  setLogLevel(level) {
    this.logLevel = level;
  }
  shouldLog(level) {
    const levels = Object.values(LogLevel);
    return levels.indexOf(level) >= levels.indexOf(this.logLevel);
  }
  addLog(entry) {
    this.logs.push(entry);
    if (this.logs.length > this.maxLogs) {
      this.logs.shift();
    }
    this.eventEmitter.emit(PnpEventType.LOG, entry);
  }
  debug(message, context) {
    if (this.shouldLog(
      "debug"
      /* DEBUG */
    )) {
      this.addLog({
        level: "debug",
        message,
        timestamp: /* @__PURE__ */ new Date(),
        context
      });
    }
  }
  info(message, context) {
    if (this.shouldLog(
      "info"
      /* INFO */
    )) {
      this.addLog({
        level: "info",
        message,
        timestamp: /* @__PURE__ */ new Date(),
        context
      });
    }
  }
  warn(message, context) {
    if (this.shouldLog(
      "warn"
      /* WARN */
    )) {
      this.addLog({
        level: "warn",
        message,
        timestamp: /* @__PURE__ */ new Date(),
        context
      });
    }
  }
  error(message, error, context) {
    if (this.shouldLog(
      "error"
      /* ERROR */
    )) {
      this.addLog({
        level: "error",
        message,
        timestamp: /* @__PURE__ */ new Date(),
        context,
        error
      });
    }
  }
  getLogs(level) {
    return level ? this.logs.filter((entry) => entry.level === level) : [...this.logs];
  }
  clearLogs() {
    this.logs = [];
  }
  handleError(error, context) {
    if (error instanceof PnpError) {
      this.error(error.message, error, { ...context, ...error.context });
    } else {
      this.error(error.message, error, context);
    }
  }
}
const _BaseAdapter = class _BaseAdapter {
  constructor(args) {
    this.state = Adapter.Status.INIT;
    this.actorCache = /* @__PURE__ */ new Map();
    this.config = args.config;
    this.adapter = args.adapter;
    this.logger = args.logger || new ErrorManager(null, LogLevel.INFO);
  }
  // Common state management
  setState(newState) {
    this.state = newState;
  }
  openChannel() {
    return Promise.resolve();
  }
  getState() {
    return this.state;
  }
  // Standard implementation for getAccountId, can be overridden by subclasses if needed
  async getAccountId() {
    const principal = await this.getPrincipal();
    if (!principal)
      throw new Error("Principal not available to derive account ID");
    return deriveAccountId(principal);
  }
  // Subclasses must implement how to get the principal
  async getAddresses() {
    const principal = await this.getPrincipal();
    const account = await createAccountFromPrincipal(principal);
    return {
      icp: {
        owner: account.owner,
        subaccount: account.subaccount
      }
    };
  }
  // Base implementation of createActor with caching
  createActor(canisterId, idl, options) {
    const { requiresSigning = false } = options || {};
    const cacheKey = createActorCacheKey(
      this.adapter.walletName,
      canisterId,
      requiresSigning
    );
    const cachedActor = this.actorCache.get(cacheKey);
    if (cachedActor) {
      return cachedActor;
    }
    const actor = this.createActorInternal(canisterId, idl, options);
    this.actorCache.set(cacheKey, actor);
    return actor;
  }
  // Base disconnect logic
  async disconnect() {
    if (this.state === Adapter.Status.DISCONNECTING || this.state === Adapter.Status.CONNECTING || this.state === Adapter.Status.DISCONNECTED) {
      return;
    }
    this.setState(Adapter.Status.DISCONNECTING);
    try {
      await this.disconnectInternal();
    } catch (error) {
      this.logger.error(`Error during disconnect for ${this.adapter.walletName}`, error);
    } finally {
      this.cleanupInternal();
      this.setState(Adapter.Status.DISCONNECTED);
    }
  }
  // Abstract methods for subclass-specific disconnect logic and resource cleanup
  // Default implementations do nothing, subclasses can override if needed.
  async disconnectInternal() {
    this.actorCache.clear();
  }
  cleanupInternal() {
  }
};
_BaseAdapter.supportedChains = [Adapter.Chain.ICP];
let BaseAdapter = _BaseAdapter;
const TOKEN_PROGRAM_ID = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
new PublicKey("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");
new PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
new PublicKey("So11111111111111111111111111111111111111112");
new PublicKey("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
function clone(configObject) {
  var div, convertBase, parseNumeric, P2 = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null }, ONE = new BigNumber(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "",
    // non-breaking space
    suffix: ""
  }, ALPHABET2 = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
  function BigNumber(v2, b2) {
    var alphabet, c, caseChanged, e3, i, isNum, len, str, x2 = this;
    if (!(x2 instanceof BigNumber)) return new BigNumber(v2, b2);
    if (b2 == null) {
      if (v2 && v2._isBigNumber === true) {
        x2.s = v2.s;
        if (!v2.c || v2.e > MAX_EXP) {
          x2.c = x2.e = null;
        } else if (v2.e < MIN_EXP) {
          x2.c = [x2.e = 0];
        } else {
          x2.e = v2.e;
          x2.c = v2.c.slice();
        }
        return;
      }
      if ((isNum = typeof v2 == "number") && v2 * 0 == 0) {
        x2.s = 1 / v2 < 0 ? (v2 = -v2, -1) : 1;
        if (v2 === ~~v2) {
          for (e3 = 0, i = v2; i >= 10; i /= 10, e3++) ;
          if (e3 > MAX_EXP) {
            x2.c = x2.e = null;
          } else {
            x2.e = e3;
            x2.c = [v2];
          }
          return;
        }
        str = String(v2);
      } else {
        if (!isNumeric.test(str = String(v2))) return parseNumeric(x2, str, isNum);
        x2.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
      }
      if ((e3 = str.indexOf(".")) > -1) str = str.replace(".", "");
      if ((i = str.search(/e/i)) > 0) {
        if (e3 < 0) e3 = i;
        e3 += +str.slice(i + 1);
        str = str.substring(0, i);
      } else if (e3 < 0) {
        e3 = str.length;
      }
    } else {
      intCheck(b2, 2, ALPHABET2.length, "Base");
      if (b2 == 10 && alphabetHasNormalDecimalDigits) {
        x2 = new BigNumber(v2);
        return round(x2, DECIMAL_PLACES + x2.e + 1, ROUNDING_MODE);
      }
      str = String(v2);
      if (isNum = typeof v2 == "number") {
        if (v2 * 0 != 0) return parseNumeric(x2, str, isNum, b2);
        x2.s = 1 / v2 < 0 ? (str = str.slice(1), -1) : 1;
        if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
          throw Error(tooManyDigits + v2);
        }
      } else {
        x2.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
      }
      alphabet = ALPHABET2.slice(0, b2);
      e3 = i = 0;
      for (len = str.length; i < len; i++) {
        if (alphabet.indexOf(c = str.charAt(i)) < 0) {
          if (c == ".") {
            if (i > e3) {
              e3 = len;
              continue;
            }
          } else if (!caseChanged) {
            if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
              caseChanged = true;
              i = -1;
              e3 = 0;
              continue;
            }
          }
          return parseNumeric(x2, String(v2), isNum, b2);
        }
      }
      isNum = false;
      str = convertBase(str, b2, 10, x2.s);
      if ((e3 = str.indexOf(".")) > -1) str = str.replace(".", "");
      else e3 = str.length;
    }
    for (i = 0; str.charCodeAt(i) === 48; i++) ;
    for (len = str.length; str.charCodeAt(--len) === 48; ) ;
    if (str = str.slice(i, ++len)) {
      len -= i;
      if (isNum && BigNumber.DEBUG && len > 15 && (v2 > MAX_SAFE_INTEGER || v2 !== mathfloor(v2))) {
        throw Error(tooManyDigits + x2.s * v2);
      }
      if ((e3 = e3 - i - 1) > MAX_EXP) {
        x2.c = x2.e = null;
      } else if (e3 < MIN_EXP) {
        x2.c = [x2.e = 0];
      } else {
        x2.e = e3;
        x2.c = [];
        i = (e3 + 1) % LOG_BASE;
        if (e3 < 0) i += LOG_BASE;
        if (i < len) {
          if (i) x2.c.push(+str.slice(0, i));
          for (len -= LOG_BASE; i < len; ) {
            x2.c.push(+str.slice(i, i += LOG_BASE));
          }
          i = LOG_BASE - (str = str.slice(i)).length;
        } else {
          i -= len;
        }
        for (; i--; str += "0") ;
        x2.c.push(+str);
      }
    } else {
      x2.c = [x2.e = 0];
    }
  }
  BigNumber.clone = clone;
  BigNumber.ROUND_UP = 0;
  BigNumber.ROUND_DOWN = 1;
  BigNumber.ROUND_CEIL = 2;
  BigNumber.ROUND_FLOOR = 3;
  BigNumber.ROUND_HALF_UP = 4;
  BigNumber.ROUND_HALF_DOWN = 5;
  BigNumber.ROUND_HALF_EVEN = 6;
  BigNumber.ROUND_HALF_CEIL = 7;
  BigNumber.ROUND_HALF_FLOOR = 8;
  BigNumber.EUCLID = 9;
  BigNumber.config = BigNumber.set = function(obj) {
    var p, v2;
    if (obj != null) {
      if (typeof obj == "object") {
        if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
          v2 = obj[p];
          intCheck(v2, 0, MAX, p);
          DECIMAL_PLACES = v2;
        }
        if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
          v2 = obj[p];
          intCheck(v2, 0, 8, p);
          ROUNDING_MODE = v2;
        }
        if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
          v2 = obj[p];
          if (v2 && v2.pop) {
            intCheck(v2[0], -1e9, 0, p);
            intCheck(v2[1], 0, MAX, p);
            TO_EXP_NEG = v2[0];
            TO_EXP_POS = v2[1];
          } else {
            intCheck(v2, -1e9, MAX, p);
            TO_EXP_NEG = -(TO_EXP_POS = v2 < 0 ? -v2 : v2);
          }
        }
        if (obj.hasOwnProperty(p = "RANGE")) {
          v2 = obj[p];
          if (v2 && v2.pop) {
            intCheck(v2[0], -1e9, -1, p);
            intCheck(v2[1], 1, MAX, p);
            MIN_EXP = v2[0];
            MAX_EXP = v2[1];
          } else {
            intCheck(v2, -1e9, MAX, p);
            if (v2) {
              MIN_EXP = -(MAX_EXP = v2 < 0 ? -v2 : v2);
            } else {
              throw Error(bignumberError + p + " cannot be zero: " + v2);
            }
          }
        }
        if (obj.hasOwnProperty(p = "CRYPTO")) {
          v2 = obj[p];
          if (v2 === !!v2) {
            if (v2) {
              if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                CRYPTO = v2;
              } else {
                CRYPTO = !v2;
                throw Error(bignumberError + "crypto unavailable");
              }
            } else {
              CRYPTO = v2;
            }
          } else {
            throw Error(bignumberError + p + " not true or false: " + v2);
          }
        }
        if (obj.hasOwnProperty(p = "MODULO_MODE")) {
          v2 = obj[p];
          intCheck(v2, 0, 9, p);
          MODULO_MODE = v2;
        }
        if (obj.hasOwnProperty(p = "POW_PRECISION")) {
          v2 = obj[p];
          intCheck(v2, 0, MAX, p);
          POW_PRECISION = v2;
        }
        if (obj.hasOwnProperty(p = "FORMAT")) {
          v2 = obj[p];
          if (typeof v2 == "object") FORMAT = v2;
          else throw Error(bignumberError + p + " not an object: " + v2);
        }
        if (obj.hasOwnProperty(p = "ALPHABET")) {
          v2 = obj[p];
          if (typeof v2 == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v2)) {
            alphabetHasNormalDecimalDigits = v2.slice(0, 10) == "0123456789";
            ALPHABET2 = v2;
          } else {
            throw Error(bignumberError + p + " invalid: " + v2);
          }
        }
      } else {
        throw Error(bignumberError + "Object expected: " + obj);
      }
    }
    return {
      DECIMAL_PLACES,
      ROUNDING_MODE,
      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
      RANGE: [MIN_EXP, MAX_EXP],
      CRYPTO,
      MODULO_MODE,
      POW_PRECISION,
      FORMAT,
      ALPHABET: ALPHABET2
    };
  };
  BigNumber.isBigNumber = function(v2) {
    if (!v2 || v2._isBigNumber !== true) return false;
    if (!BigNumber.DEBUG) return true;
    var i, n, c = v2.c, e3 = v2.e, s = v2.s;
    out: if ({}.toString.call(c) == "[object Array]") {
      if ((s === 1 || s === -1) && e3 >= -1e9 && e3 <= MAX && e3 === mathfloor(e3)) {
        if (c[0] === 0) {
          if (e3 === 0 && c.length === 1) return true;
          break out;
        }
        i = (e3 + 1) % LOG_BASE;
        if (i < 1) i += LOG_BASE;
        if (String(c[0]).length == i) {
          for (i = 0; i < c.length; i++) {
            n = c[i];
            if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
          }
          if (n !== 0) return true;
        }
      }
    } else if (c === null && e3 === null && (s === null || s === 1 || s === -1)) {
      return true;
    }
    throw Error(bignumberError + "Invalid BigNumber: " + v2);
  };
  BigNumber.maximum = BigNumber.max = function() {
    return maxOrMin(arguments, -1);
  };
  BigNumber.minimum = BigNumber.min = function() {
    return maxOrMin(arguments, 1);
  };
  BigNumber.random = function() {
    var pow2_53 = 9007199254740992;
    var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
      return mathfloor(Math.random() * pow2_53);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(dp) {
      var a, b2, e3, k2, v2, i = 0, c = [], rand = new BigNumber(ONE);
      if (dp == null) dp = DECIMAL_PLACES;
      else intCheck(dp, 0, MAX);
      k2 = mathceil(dp / LOG_BASE);
      if (CRYPTO) {
        if (crypto.getRandomValues) {
          a = crypto.getRandomValues(new Uint32Array(k2 *= 2));
          for (; i < k2; ) {
            v2 = a[i] * 131072 + (a[i + 1] >>> 11);
            if (v2 >= 9e15) {
              b2 = crypto.getRandomValues(new Uint32Array(2));
              a[i] = b2[0];
              a[i + 1] = b2[1];
            } else {
              c.push(v2 % 1e14);
              i += 2;
            }
          }
          i = k2 / 2;
        } else if (crypto.randomBytes) {
          a = crypto.randomBytes(k2 *= 7);
          for (; i < k2; ) {
            v2 = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
            if (v2 >= 9e15) {
              crypto.randomBytes(7).copy(a, i);
            } else {
              c.push(v2 % 1e14);
              i += 7;
            }
          }
          i = k2 / 7;
        } else {
          CRYPTO = false;
          throw Error(bignumberError + "crypto unavailable");
        }
      }
      if (!CRYPTO) {
        for (; i < k2; ) {
          v2 = random53bitInt();
          if (v2 < 9e15) c[i++] = v2 % 1e14;
        }
      }
      k2 = c[--i];
      dp %= LOG_BASE;
      if (k2 && dp) {
        v2 = POWS_TEN[LOG_BASE - dp];
        c[i] = mathfloor(k2 / v2) * v2;
      }
      for (; c[i] === 0; c.pop(), i--) ;
      if (i < 0) {
        c = [e3 = 0];
      } else {
        for (e3 = -1; c[0] === 0; c.splice(0, 1), e3 -= LOG_BASE) ;
        for (i = 1, v2 = c[0]; v2 >= 10; v2 /= 10, i++) ;
        if (i < LOG_BASE) e3 -= LOG_BASE - i;
      }
      rand.e = e3;
      rand.c = c;
      return rand;
    };
  }();
  BigNumber.sum = function() {
    var i = 1, args = arguments, sum = new BigNumber(args[0]);
    for (; i < args.length; ) sum = sum.plus(args[i++]);
    return sum;
  };
  convertBase = /* @__PURE__ */ function() {
    var decimal = "0123456789";
    function toBaseOut(str, baseIn, baseOut, alphabet) {
      var j2, arr = [0], arrL, i = 0, len = str.length;
      for (; i < len; ) {
        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn) ;
        arr[0] += alphabet.indexOf(str.charAt(i++));
        for (j2 = 0; j2 < arr.length; j2++) {
          if (arr[j2] > baseOut - 1) {
            if (arr[j2 + 1] == null) arr[j2 + 1] = 0;
            arr[j2 + 1] += arr[j2] / baseOut | 0;
            arr[j2] %= baseOut;
          }
        }
      }
      return arr.reverse();
    }
    return function(str, baseIn, baseOut, sign2, callerIsToString) {
      var alphabet, d2, e3, k2, r, x2, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
      if (i >= 0) {
        k2 = POW_PRECISION;
        POW_PRECISION = 0;
        str = str.replace(".", "");
        y = new BigNumber(baseIn);
        x2 = y.pow(str.length - i);
        POW_PRECISION = k2;
        y.c = toBaseOut(
          toFixedPoint(coeffToString(x2.c), x2.e, "0"),
          10,
          baseOut,
          decimal
        );
        y.e = y.c.length;
      }
      xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET2, decimal) : (alphabet = decimal, ALPHABET2));
      e3 = k2 = xc.length;
      for (; xc[--k2] == 0; xc.pop()) ;
      if (!xc[0]) return alphabet.charAt(0);
      if (i < 0) {
        --e3;
      } else {
        x2.c = xc;
        x2.e = e3;
        x2.s = sign2;
        x2 = div(x2, y, dp, rm, baseOut);
        xc = x2.c;
        r = x2.r;
        e3 = x2.e;
      }
      d2 = e3 + dp + 1;
      i = xc[d2];
      k2 = baseOut / 2;
      r = r || d2 < 0 || xc[d2 + 1] != null;
      r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : i > k2 || i == k2 && (rm == 4 || r || rm == 6 && xc[d2 - 1] & 1 || rm == (x2.s < 0 ? 8 : 7));
      if (d2 < 1 || !xc[0]) {
        str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
      } else {
        xc.length = d2;
        if (r) {
          for (--baseOut; ++xc[--d2] > baseOut; ) {
            xc[d2] = 0;
            if (!d2) {
              ++e3;
              xc = [1].concat(xc);
            }
          }
        }
        for (k2 = xc.length; !xc[--k2]; ) ;
        for (i = 0, str = ""; i <= k2; str += alphabet.charAt(xc[i++])) ;
        str = toFixedPoint(str, e3, alphabet.charAt(0));
      }
      return str;
    };
  }();
  div = /* @__PURE__ */ function() {
    function multiply(x2, k2, base2) {
      var m, temp, xlo, xhi, carry = 0, i = x2.length, klo = k2 % SQRT_BASE, khi = k2 / SQRT_BASE | 0;
      for (x2 = x2.slice(); i--; ) {
        xlo = x2[i] % SQRT_BASE;
        xhi = x2[i] / SQRT_BASE | 0;
        m = khi * xlo + xhi * klo;
        temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
        carry = (temp / base2 | 0) + (m / SQRT_BASE | 0) + khi * xhi;
        x2[i] = temp % base2;
      }
      if (carry) x2 = [carry].concat(x2);
      return x2;
    }
    function compare2(a, b2, aL, bL) {
      var i, cmp;
      if (aL != bL) {
        cmp = aL > bL ? 1 : -1;
      } else {
        for (i = cmp = 0; i < aL; i++) {
          if (a[i] != b2[i]) {
            cmp = a[i] > b2[i] ? 1 : -1;
            break;
          }
        }
      }
      return cmp;
    }
    function subtract(a, b2, aL, base2) {
      var i = 0;
      for (; aL--; ) {
        a[aL] -= i;
        i = a[aL] < b2[aL] ? 1 : 0;
        a[aL] = i * base2 + a[aL] - b2[aL];
      }
      for (; !a[0] && a.length > 1; a.splice(0, 1)) ;
    }
    return function(x2, y, dp, rm, base2) {
      var cmp, e3, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x2.s == y.s ? 1 : -1, xc = x2.c, yc = y.c;
      if (!xc || !xc[0] || !yc || !yc[0]) {
        return new BigNumber(
          // Return NaN if either NaN, or both Infinity or 0.
          !x2.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
          )
        );
      }
      q = new BigNumber(s);
      qc = q.c = [];
      e3 = x2.e - y.e;
      s = dp + e3 + 1;
      if (!base2) {
        base2 = BASE;
        e3 = bitFloor(x2.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
        s = s / LOG_BASE | 0;
      }
      for (i = 0; yc[i] == (xc[i] || 0); i++) ;
      if (yc[i] > (xc[i] || 0)) e3--;
      if (s < 0) {
        qc.push(1);
        more = true;
      } else {
        xL = xc.length;
        yL = yc.length;
        i = 0;
        s += 2;
        n = mathfloor(base2 / (yc[0] + 1));
        if (n > 1) {
          yc = multiply(yc, n, base2);
          xc = multiply(xc, n, base2);
          yL = yc.length;
          xL = xc.length;
        }
        xi = yL;
        rem = xc.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; rem[remL++] = 0) ;
        yz = yc.slice();
        yz = [0].concat(yz);
        yc0 = yc[0];
        if (yc[1] >= base2 / 2) yc0++;
        do {
          n = 0;
          cmp = compare2(yc, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL) rem0 = rem0 * base2 + (rem[1] || 0);
            n = mathfloor(rem0 / yc0);
            if (n > 1) {
              if (n >= base2) n = base2 - 1;
              prod = multiply(yc, n, base2);
              prodL = prod.length;
              remL = rem.length;
              while (compare2(prod, rem, prodL, remL) == 1) {
                n--;
                subtract(prod, yL < prodL ? yz : yc, prodL, base2);
                prodL = prod.length;
                cmp = 1;
              }
            } else {
              if (n == 0) {
                cmp = n = 1;
              }
              prod = yc.slice();
              prodL = prod.length;
            }
            if (prodL < remL) prod = [0].concat(prod);
            subtract(rem, prod, remL, base2);
            remL = rem.length;
            if (cmp == -1) {
              while (compare2(yc, rem, yL, remL) < 1) {
                n++;
                subtract(rem, yL < remL ? yz : yc, remL, base2);
                remL = rem.length;
              }
            }
          } else if (cmp === 0) {
            n++;
            rem = [0];
          }
          qc[i++] = n;
          if (rem[0]) {
            rem[remL++] = xc[xi] || 0;
          } else {
            rem = [xc[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] != null) && s--);
        more = rem[0] != null;
        if (!qc[0]) qc.splice(0, 1);
      }
      if (base2 == BASE) {
        for (i = 1, s = qc[0]; s >= 10; s /= 10, i++) ;
        round(q, dp + (q.e = i + e3 * LOG_BASE - 1) + 1, rm, more);
      } else {
        q.e = e3;
        q.r = +more;
      }
      return q;
    };
  }();
  function format(n, i, rm, id) {
    var c0, e3, ne, len, str;
    if (rm == null) rm = ROUNDING_MODE;
    else intCheck(rm, 0, 8);
    if (!n.c) return n.toString();
    c0 = n.c[0];
    ne = n.e;
    if (i == null) {
      str = coeffToString(n.c);
      str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
    } else {
      n = round(new BigNumber(n), i, rm);
      e3 = n.e;
      str = coeffToString(n.c);
      len = str.length;
      if (id == 1 || id == 2 && (i <= e3 || e3 <= TO_EXP_NEG)) {
        for (; len < i; str += "0", len++) ;
        str = toExponential(str, e3);
      } else {
        i -= ne;
        str = toFixedPoint(str, e3, "0");
        if (e3 + 1 > len) {
          if (--i > 0) for (str += "."; i--; str += "0") ;
        } else {
          i += e3 - len;
          if (i > 0) {
            if (e3 + 1 == len) str += ".";
            for (; i--; str += "0") ;
          }
        }
      }
    }
    return n.s < 0 && c0 ? "-" + str : str;
  }
  function maxOrMin(args, n) {
    var k2, y, i = 1, x2 = new BigNumber(args[0]);
    for (; i < args.length; i++) {
      y = new BigNumber(args[i]);
      if (!y.s || (k2 = compare(x2, y)) === n || k2 === 0 && x2.s === n) {
        x2 = y;
      }
    }
    return x2;
  }
  function normalise(n, c, e3) {
    var i = 1, j2 = c.length;
    for (; !c[--j2]; c.pop()) ;
    for (j2 = c[0]; j2 >= 10; j2 /= 10, i++) ;
    if ((e3 = i + e3 * LOG_BASE - 1) > MAX_EXP) {
      n.c = n.e = null;
    } else if (e3 < MIN_EXP) {
      n.c = [n.e = 0];
    } else {
      n.e = e3;
      n.c = c;
    }
    return n;
  }
  parseNumeric = /* @__PURE__ */ function() {
    var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(x2, str, isNum, b2) {
      var base2, s = isNum ? str : str.replace(whitespaceOrPlus, "");
      if (isInfinityOrNaN.test(s)) {
        x2.s = isNaN(s) ? null : s < 0 ? -1 : 1;
      } else {
        if (!isNum) {
          s = s.replace(basePrefix, function(m, p1, p2) {
            base2 = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
            return !b2 || b2 == base2 ? p1 : m;
          });
          if (b2) {
            base2 = b2;
            s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
          }
          if (str != s) return new BigNumber(s, base2);
        }
        if (BigNumber.DEBUG) {
          throw Error(bignumberError + "Not a" + (b2 ? " base " + b2 : "") + " number: " + str);
        }
        x2.s = null;
      }
      x2.c = x2.e = null;
    };
  }();
  function round(x2, sd, rm, r) {
    var d2, i, j2, k2, n, ni, rd, xc = x2.c, pows10 = POWS_TEN;
    if (xc) {
      out: {
        for (d2 = 1, k2 = xc[0]; k2 >= 10; k2 /= 10, d2++) ;
        i = sd - d2;
        if (i < 0) {
          i += LOG_BASE;
          j2 = sd;
          n = xc[ni = 0];
          rd = mathfloor(n / pows10[d2 - j2 - 1] % 10);
        } else {
          ni = mathceil((i + 1) / LOG_BASE);
          if (ni >= xc.length) {
            if (r) {
              for (; xc.length <= ni; xc.push(0)) ;
              n = rd = 0;
              d2 = 1;
              i %= LOG_BASE;
              j2 = i - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            n = k2 = xc[ni];
            for (d2 = 1; k2 >= 10; k2 /= 10, d2++) ;
            i %= LOG_BASE;
            j2 = i - LOG_BASE + d2;
            rd = j2 < 0 ? 0 : mathfloor(n / pows10[d2 - j2 - 1] % 10);
          }
        }
        r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        xc[ni + 1] != null || (j2 < 0 ? n : n % pows10[d2 - j2 - 1]);
        r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (i > 0 ? j2 > 0 ? n / pows10[d2 - j2] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x2.s < 0 ? 8 : 7));
        if (sd < 1 || !xc[0]) {
          xc.length = 0;
          if (r) {
            sd -= x2.e + 1;
            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
            x2.e = -sd || 0;
          } else {
            xc[0] = x2.e = 0;
          }
          return x2;
        }
        if (i == 0) {
          xc.length = ni;
          k2 = 1;
          ni--;
        } else {
          xc.length = ni + 1;
          k2 = pows10[LOG_BASE - i];
          xc[ni] = j2 > 0 ? mathfloor(n / pows10[d2 - j2] % pows10[j2]) * k2 : 0;
        }
        if (r) {
          for (; ; ) {
            if (ni == 0) {
              for (i = 1, j2 = xc[0]; j2 >= 10; j2 /= 10, i++) ;
              j2 = xc[0] += k2;
              for (k2 = 1; j2 >= 10; j2 /= 10, k2++) ;
              if (i != k2) {
                x2.e++;
                if (xc[0] == BASE) xc[0] = 1;
              }
              break;
            } else {
              xc[ni] += k2;
              if (xc[ni] != BASE) break;
              xc[ni--] = 0;
              k2 = 1;
            }
          }
        }
        for (i = xc.length; xc[--i] === 0; xc.pop()) ;
      }
      if (x2.e > MAX_EXP) {
        x2.c = x2.e = null;
      } else if (x2.e < MIN_EXP) {
        x2.c = [x2.e = 0];
      }
    }
    return x2;
  }
  function valueOf(n) {
    var str, e3 = n.e;
    if (e3 === null) return n.toString();
    str = coeffToString(n.c);
    str = e3 <= TO_EXP_NEG || e3 >= TO_EXP_POS ? toExponential(str, e3) : toFixedPoint(str, e3, "0");
    return n.s < 0 ? "-" + str : str;
  }
  P2.absoluteValue = P2.abs = function() {
    var x2 = new BigNumber(this);
    if (x2.s < 0) x2.s = 1;
    return x2;
  };
  P2.comparedTo = function(y, b2) {
    return compare(this, new BigNumber(y, b2));
  };
  P2.decimalPlaces = P2.dp = function(dp, rm) {
    var c, n, v2, x2 = this;
    if (dp != null) {
      intCheck(dp, 0, MAX);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(new BigNumber(x2), dp + x2.e + 1, rm);
    }
    if (!(c = x2.c)) return null;
    n = ((v2 = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
    if (v2 = c[v2]) for (; v2 % 10 == 0; v2 /= 10, n--) ;
    if (n < 0) n = 0;
    return n;
  };
  P2.dividedBy = P2.div = function(y, b2) {
    return div(this, new BigNumber(y, b2), DECIMAL_PLACES, ROUNDING_MODE);
  };
  P2.dividedToIntegerBy = P2.idiv = function(y, b2) {
    return div(this, new BigNumber(y, b2), 0, 1);
  };
  P2.exponentiatedBy = P2.pow = function(n, m) {
    var half, isModExp, i, k2, more, nIsBig, nIsNeg, nIsOdd, y, x2 = this;
    n = new BigNumber(n);
    if (n.c && !n.isInteger()) {
      throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
    }
    if (m != null) m = new BigNumber(m);
    nIsBig = n.e > 14;
    if (!x2.c || !x2.c[0] || x2.c[0] == 1 && !x2.e && x2.c.length == 1 || !n.c || !n.c[0]) {
      y = new BigNumber(Math.pow(+valueOf(x2), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
      return m ? y.mod(m) : y;
    }
    nIsNeg = n.s < 0;
    if (m) {
      if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);
      isModExp = !nIsNeg && x2.isInteger() && m.isInteger();
      if (isModExp) x2 = x2.mod(m);
    } else if (n.e > 9 && (x2.e > 0 || x2.e < -1 || (x2.e == 0 ? x2.c[0] > 1 || nIsBig && x2.c[1] >= 24e7 : x2.c[0] < 8e13 || nIsBig && x2.c[0] <= 9999975e7))) {
      k2 = x2.s < 0 && isOdd(n) ? -0 : 0;
      if (x2.e > -1) k2 = 1 / k2;
      return new BigNumber(nIsNeg ? 1 / k2 : k2);
    } else if (POW_PRECISION) {
      k2 = mathceil(POW_PRECISION / LOG_BASE + 2);
    }
    if (nIsBig) {
      half = new BigNumber(0.5);
      if (nIsNeg) n.s = 1;
      nIsOdd = isOdd(n);
    } else {
      i = Math.abs(+valueOf(n));
      nIsOdd = i % 2;
    }
    y = new BigNumber(ONE);
    for (; ; ) {
      if (nIsOdd) {
        y = y.times(x2);
        if (!y.c) break;
        if (k2) {
          if (y.c.length > k2) y.c.length = k2;
        } else if (isModExp) {
          y = y.mod(m);
        }
      }
      if (i) {
        i = mathfloor(i / 2);
        if (i === 0) break;
        nIsOdd = i % 2;
      } else {
        n = n.times(half);
        round(n, n.e + 1, 1);
        if (n.e > 14) {
          nIsOdd = isOdd(n);
        } else {
          i = +valueOf(n);
          if (i === 0) break;
          nIsOdd = i % 2;
        }
      }
      x2 = x2.times(x2);
      if (k2) {
        if (x2.c && x2.c.length > k2) x2.c.length = k2;
      } else if (isModExp) {
        x2 = x2.mod(m);
      }
    }
    if (isModExp) return y;
    if (nIsNeg) y = ONE.div(y);
    return m ? y.mod(m) : k2 ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
  };
  P2.integerValue = function(rm) {
    var n = new BigNumber(this);
    if (rm == null) rm = ROUNDING_MODE;
    else intCheck(rm, 0, 8);
    return round(n, n.e + 1, rm);
  };
  P2.isEqualTo = P2.eq = function(y, b2) {
    return compare(this, new BigNumber(y, b2)) === 0;
  };
  P2.isFinite = function() {
    return !!this.c;
  };
  P2.isGreaterThan = P2.gt = function(y, b2) {
    return compare(this, new BigNumber(y, b2)) > 0;
  };
  P2.isGreaterThanOrEqualTo = P2.gte = function(y, b2) {
    return (b2 = compare(this, new BigNumber(y, b2))) === 1 || b2 === 0;
  };
  P2.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  };
  P2.isLessThan = P2.lt = function(y, b2) {
    return compare(this, new BigNumber(y, b2)) < 0;
  };
  P2.isLessThanOrEqualTo = P2.lte = function(y, b2) {
    return (b2 = compare(this, new BigNumber(y, b2))) === -1 || b2 === 0;
  };
  P2.isNaN = function() {
    return !this.s;
  };
  P2.isNegative = function() {
    return this.s < 0;
  };
  P2.isPositive = function() {
    return this.s > 0;
  };
  P2.isZero = function() {
    return !!this.c && this.c[0] == 0;
  };
  P2.minus = function(y, b2) {
    var i, j2, t, xLTy, x2 = this, a = x2.s;
    y = new BigNumber(y, b2);
    b2 = y.s;
    if (!a || !b2) return new BigNumber(NaN);
    if (a != b2) {
      y.s = -b2;
      return x2.plus(y);
    }
    var xe = x2.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x2.c, yc = y.c;
    if (!xe || !ye) {
      if (!xc || !yc) return xc ? (y.s = -b2, y) : new BigNumber(yc ? x2 : NaN);
      if (!xc[0] || !yc[0]) {
        return yc[0] ? (y.s = -b2, y) : new BigNumber(xc[0] ? x2 : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          ROUNDING_MODE == 3 ? -0 : 0
        ));
      }
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a = xe - ye) {
      if (xLTy = a < 0) {
        a = -a;
        t = xc;
      } else {
        ye = xe;
        t = yc;
      }
      t.reverse();
      for (b2 = a; b2--; t.push(0)) ;
      t.reverse();
    } else {
      j2 = (xLTy = (a = xc.length) < (b2 = yc.length)) ? a : b2;
      for (a = b2 = 0; b2 < j2; b2++) {
        if (xc[b2] != yc[b2]) {
          xLTy = xc[b2] < yc[b2];
          break;
        }
      }
    }
    if (xLTy) {
      t = xc;
      xc = yc;
      yc = t;
      y.s = -y.s;
    }
    b2 = (j2 = yc.length) - (i = xc.length);
    if (b2 > 0) for (; b2--; xc[i++] = 0) ;
    b2 = BASE - 1;
    for (; j2 > a; ) {
      if (xc[--j2] < yc[j2]) {
        for (i = j2; i && !xc[--i]; xc[i] = b2) ;
        --xc[i];
        xc[j2] += BASE;
      }
      xc[j2] -= yc[j2];
    }
    for (; xc[0] == 0; xc.splice(0, 1), --ye) ;
    if (!xc[0]) {
      y.s = ROUNDING_MODE == 3 ? -1 : 1;
      y.c = [y.e = 0];
      return y;
    }
    return normalise(y, xc, ye);
  };
  P2.modulo = P2.mod = function(y, b2) {
    var q, s, x2 = this;
    y = new BigNumber(y, b2);
    if (!x2.c || !y.s || y.c && !y.c[0]) {
      return new BigNumber(NaN);
    } else if (!y.c || x2.c && !x2.c[0]) {
      return new BigNumber(x2);
    }
    if (MODULO_MODE == 9) {
      s = y.s;
      y.s = 1;
      q = div(x2, y, 0, 3);
      y.s = s;
      q.s *= s;
    } else {
      q = div(x2, y, 0, MODULO_MODE);
    }
    y = x2.minus(q.times(y));
    if (!y.c[0] && MODULO_MODE == 1) y.s = x2.s;
    return y;
  };
  P2.multipliedBy = P2.times = function(y, b2) {
    var c, e3, i, j2, k2, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base2, sqrtBase, x2 = this, xc = x2.c, yc = (y = new BigNumber(y, b2)).c;
    if (!xc || !yc || !xc[0] || !yc[0]) {
      if (!x2.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
        y.c = y.e = y.s = null;
      } else {
        y.s *= x2.s;
        if (!xc || !yc) {
          y.c = y.e = null;
        } else {
          y.c = [0];
          y.e = 0;
        }
      }
      return y;
    }
    e3 = bitFloor(x2.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
    y.s *= x2.s;
    xcL = xc.length;
    ycL = yc.length;
    if (xcL < ycL) {
      zc = xc;
      xc = yc;
      yc = zc;
      i = xcL;
      xcL = ycL;
      ycL = i;
    }
    for (i = xcL + ycL, zc = []; i--; zc.push(0)) ;
    base2 = BASE;
    sqrtBase = SQRT_BASE;
    for (i = ycL; --i >= 0; ) {
      c = 0;
      ylo = yc[i] % sqrtBase;
      yhi = yc[i] / sqrtBase | 0;
      for (k2 = xcL, j2 = i + k2; j2 > i; ) {
        xlo = xc[--k2] % sqrtBase;
        xhi = xc[k2] / sqrtBase | 0;
        m = yhi * xlo + xhi * ylo;
        xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j2] + c;
        c = (xlo / base2 | 0) + (m / sqrtBase | 0) + yhi * xhi;
        zc[j2--] = xlo % base2;
      }
      zc[j2] = c;
    }
    if (c) {
      ++e3;
    } else {
      zc.splice(0, 1);
    }
    return normalise(y, zc, e3);
  };
  P2.negated = function() {
    var x2 = new BigNumber(this);
    x2.s = -x2.s || null;
    return x2;
  };
  P2.plus = function(y, b2) {
    var t, x2 = this, a = x2.s;
    y = new BigNumber(y, b2);
    b2 = y.s;
    if (!a || !b2) return new BigNumber(NaN);
    if (a != b2) {
      y.s = -b2;
      return x2.minus(y);
    }
    var xe = x2.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x2.c, yc = y.c;
    if (!xe || !ye) {
      if (!xc || !yc) return new BigNumber(a / 0);
      if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x2 : a * 0);
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a = xe - ye) {
      if (a > 0) {
        ye = xe;
        t = yc;
      } else {
        a = -a;
        t = xc;
      }
      t.reverse();
      for (; a--; t.push(0)) ;
      t.reverse();
    }
    a = xc.length;
    b2 = yc.length;
    if (a - b2 < 0) {
      t = yc;
      yc = xc;
      xc = t;
      b2 = a;
    }
    for (a = 0; b2; ) {
      a = (xc[--b2] = xc[b2] + yc[b2] + a) / BASE | 0;
      xc[b2] = BASE === xc[b2] ? 0 : xc[b2] % BASE;
    }
    if (a) {
      xc = [a].concat(xc);
      ++ye;
    }
    return normalise(y, xc, ye);
  };
  P2.precision = P2.sd = function(sd, rm) {
    var c, n, v2, x2 = this;
    if (sd != null && sd !== !!sd) {
      intCheck(sd, 1, MAX);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(new BigNumber(x2), sd, rm);
    }
    if (!(c = x2.c)) return null;
    v2 = c.length - 1;
    n = v2 * LOG_BASE + 1;
    if (v2 = c[v2]) {
      for (; v2 % 10 == 0; v2 /= 10, n--) ;
      for (v2 = c[0]; v2 >= 10; v2 /= 10, n++) ;
    }
    if (sd && x2.e + 1 > n) n = x2.e + 1;
    return n;
  };
  P2.shiftedBy = function(k2) {
    intCheck(k2, -9007199254740991, MAX_SAFE_INTEGER);
    return this.times("1e" + k2);
  };
  P2.squareRoot = P2.sqrt = function() {
    var m, n, r, rep, t, x2 = this, c = x2.c, s = x2.s, e3 = x2.e, dp = DECIMAL_PLACES + 4, half = new BigNumber("0.5");
    if (s !== 1 || !c || !c[0]) {
      return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x2 : 1 / 0);
    }
    s = Math.sqrt(+valueOf(x2));
    if (s == 0 || s == 1 / 0) {
      n = coeffToString(c);
      if ((n.length + e3) % 2 == 0) n += "0";
      s = Math.sqrt(+n);
      e3 = bitFloor((e3 + 1) / 2) - (e3 < 0 || e3 % 2);
      if (s == 1 / 0) {
        n = "5e" + e3;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf("e") + 1) + e3;
      }
      r = new BigNumber(n);
    } else {
      r = new BigNumber(s + "");
    }
    if (r.c[0]) {
      e3 = r.e;
      s = e3 + dp;
      if (s < 3) s = 0;
      for (; ; ) {
        t = r;
        r = half.times(t.plus(div(x2, t, dp, 1)));
        if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
          if (r.e < e3) --s;
          n = n.slice(s - 3, s + 1);
          if (n == "9999" || !rep && n == "4999") {
            if (!rep) {
              round(t, t.e + DECIMAL_PLACES + 2, 0);
              if (t.times(t).eq(x2)) {
                r = t;
                break;
              }
            }
            dp += 4;
            s += 4;
            rep = 1;
          } else {
            if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
              round(r, r.e + DECIMAL_PLACES + 2, 1);
              m = !r.times(r).eq(x2);
            }
            break;
          }
        }
      }
    }
    return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
  };
  P2.toExponential = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp++;
    }
    return format(this, dp, rm, 1);
  };
  P2.toFixed = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp = dp + this.e + 1;
    }
    return format(this, dp, rm);
  };
  P2.toFormat = function(dp, rm, format2) {
    var str, x2 = this;
    if (format2 == null) {
      if (dp != null && rm && typeof rm == "object") {
        format2 = rm;
        rm = null;
      } else if (dp && typeof dp == "object") {
        format2 = dp;
        dp = rm = null;
      } else {
        format2 = FORMAT;
      }
    } else if (typeof format2 != "object") {
      throw Error(bignumberError + "Argument not an object: " + format2);
    }
    str = x2.toFixed(dp, rm);
    if (x2.c) {
      var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x2.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
      if (g2) {
        i = g1;
        g1 = g2;
        g2 = i;
        len -= i;
      }
      if (g1 > 0 && len > 0) {
        i = len % g1 || g1;
        intPart = intDigits.substr(0, i);
        for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
        if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
        if (isNeg) intPart = "-" + intPart;
      }
      str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
        new RegExp("\\d{" + g2 + "}\\B", "g"),
        "$&" + (format2.fractionGroupSeparator || "")
      ) : fractionPart) : intPart;
    }
    return (format2.prefix || "") + str + (format2.suffix || "");
  };
  P2.toFraction = function(md) {
    var d2, d0, d1, d22, e3, exp, n, n0, n1, q, r, s, x2 = this, xc = x2.c;
    if (md != null) {
      n = new BigNumber(md);
      if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
        throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
      }
    }
    if (!xc) return new BigNumber(x2);
    d2 = new BigNumber(ONE);
    n1 = d0 = new BigNumber(ONE);
    d1 = n0 = new BigNumber(ONE);
    s = coeffToString(xc);
    e3 = d2.e = s.length - x2.e - 1;
    d2.c[0] = POWS_TEN[(exp = e3 % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
    md = !md || n.comparedTo(d2) > 0 ? e3 > 0 ? d2 : n1 : n;
    exp = MAX_EXP;
    MAX_EXP = 1 / 0;
    n = new BigNumber(s);
    n0.c[0] = 0;
    for (; ; ) {
      q = div(n, d2, 0, 1);
      d22 = d0.plus(q.times(d1));
      if (d22.comparedTo(md) == 1) break;
      d0 = d1;
      d1 = d22;
      n1 = n0.plus(q.times(d22 = n1));
      n0 = d22;
      d2 = n.minus(q.times(d22 = d2));
      n = d22;
    }
    d22 = div(md.minus(d0), d1, 0, 1);
    n0 = n0.plus(d22.times(n1));
    d0 = d0.plus(d22.times(d1));
    n0.s = n1.s = x2.s;
    e3 = e3 * 2;
    r = div(n1, d1, e3, ROUNDING_MODE).minus(x2).abs().comparedTo(
      div(n0, d0, e3, ROUNDING_MODE).minus(x2).abs()
    ) < 1 ? [n1, d1] : [n0, d0];
    MAX_EXP = exp;
    return r;
  };
  P2.toNumber = function() {
    return +valueOf(this);
  };
  P2.toPrecision = function(sd, rm) {
    if (sd != null) intCheck(sd, 1, MAX);
    return format(this, sd, rm, 2);
  };
  P2.toString = function(b2) {
    var str, n = this, s = n.s, e3 = n.e;
    if (e3 === null) {
      if (s) {
        str = "Infinity";
        if (s < 0) str = "-" + str;
      } else {
        str = "NaN";
      }
    } else {
      if (b2 == null) {
        str = e3 <= TO_EXP_NEG || e3 >= TO_EXP_POS ? toExponential(coeffToString(n.c), e3) : toFixedPoint(coeffToString(n.c), e3, "0");
      } else if (b2 === 10 && alphabetHasNormalDecimalDigits) {
        n = round(new BigNumber(n), DECIMAL_PLACES + e3 + 1, ROUNDING_MODE);
        str = toFixedPoint(coeffToString(n.c), n.e, "0");
      } else {
        intCheck(b2, 2, ALPHABET2.length, "Base");
        str = convertBase(toFixedPoint(coeffToString(n.c), e3, "0"), 10, b2, s, true);
      }
      if (s < 0 && n.c[0]) str = "-" + str;
    }
    return str;
  };
  P2.valueOf = P2.toJSON = function() {
    return valueOf(this);
  };
  P2._isBigNumber = true;
  P2[Symbol.toStringTag] = "BigNumber";
  P2[Symbol.for("nodejs.util.inspect.custom")] = P2.valueOf;
  if (configObject != null) BigNumber.set(configObject);
  return BigNumber;
}
function bitFloor(n) {
  var i = n | 0;
  return n > 0 || n === i ? i : i - 1;
}
function coeffToString(a) {
  var s, z2, i = 1, j2 = a.length, r = a[0] + "";
  for (; i < j2; ) {
    s = a[i++] + "";
    z2 = LOG_BASE - s.length;
    for (; z2--; s = "0" + s) ;
    r += s;
  }
  for (j2 = r.length; r.charCodeAt(--j2) === 48; ) ;
  return r.slice(0, j2 + 1 || 1);
}
function compare(x2, y) {
  var a, b2, xc = x2.c, yc = y.c, i = x2.s, j2 = y.s, k2 = x2.e, l = y.e;
  if (!i || !j2) return null;
  a = xc && !xc[0];
  b2 = yc && !yc[0];
  if (a || b2) return a ? b2 ? 0 : -j2 : i;
  if (i != j2) return i;
  a = i < 0;
  b2 = k2 == l;
  if (!xc || !yc) return b2 ? 0 : !xc ^ a ? 1 : -1;
  if (!b2) return k2 > l ^ a ? 1 : -1;
  j2 = (k2 = xc.length) < (l = yc.length) ? k2 : l;
  for (i = 0; i < j2; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;
  return k2 == l ? 0 : k2 > l ^ a ? 1 : -1;
}
function intCheck(n, min, max, name) {
  if (n < min || n > max || n !== mathfloor(n)) {
    throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
  }
}
function isOdd(n) {
  var k2 = n.c.length - 1;
  return bitFloor(n.e / LOG_BASE) == k2 && n.c[k2] % 2 != 0;
}
function toExponential(str, e3) {
  return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e3 < 0 ? "e" : "e+") + e3;
}
function toFixedPoint(str, e3, z2) {
  var len, zs;
  if (e3 < 0) {
    for (zs = z2 + "."; ++e3; zs += z2) ;
    str = zs + str;
  } else {
    len = str.length;
    if (++e3 > len) {
      for (zs = z2, e3 -= len; --e3; zs += z2) ;
      str += zs;
    } else if (e3 < len) {
      str = str.slice(0, e3) + "." + str.slice(e3);
    }
  }
  return str;
}
clone();
class TokenManager {
  constructor(connection) {
    this.tokenListCache = null;
    this.tokenPricesTimestamp = 0;
    this.connection = connection;
  }
  async getTokenPrices() {
    try {
      const now = Date.now();
      if (this.tokenListCache && this.tokenPricesTimestamp > 0 && now - this.tokenPricesTimestamp < 2 * 60 * 1e3) {
        const priceMap2 = {};
        for (const [address, tokenInfo] of Object.entries(this.tokenListCache)) {
          if (tokenInfo.price) {
            priceMap2[address] = tokenInfo.price;
          }
        }
        return priceMap2;
      }
      const tokenMap = await this.getTokenList();
      const tokenAddresses = Object.keys(tokenMap);
      const tokenChunks = [];
      for (let i = 0; i < tokenAddresses.length; i += 50) {
        tokenChunks.push(tokenAddresses.slice(i, i + 50));
      }
      const priceMap = {};
      for (const chunk of tokenChunks) {
        try {
          const requestIds = ["SOL", ...chunk].join(",");
          const response = await fetch(`https://price.jup.ag/v4/price?ids=${requestIds}`);
          if (!response.ok) {
            console.warn(`Failed to fetch Jupiter prices for chunk, status: ${response.status}`);
            continue;
          }
          const priceData = await response.json();
          if (priceData.data) {
            for (const [address, data] of Object.entries(priceData.data)) {
              if (data && typeof data === "object" && "price" in data && data.price !== null) {
                const price = Number(data.price);
                if (!isNaN(price) && price > 0) {
                  priceMap[address] = price;
                  if (this.tokenListCache && this.tokenListCache[address]) {
                    this.tokenListCache[address].price = price;
                  }
                }
              }
            }
          }
        } catch (chunkError) {
          console.warn(`Error fetching prices for token chunk:`, chunkError);
        }
      }
      this.tokenPricesTimestamp = now;
      return priceMap;
    } catch (error) {
      console.warn(`Failed to fetch token prices:`, error);
      return {};
    }
  }
  async getTokenList() {
    if (this.tokenListCache) {
      return this.tokenListCache;
    }
    try {
      const response = await fetch("https://token.jup.ag/all");
      if (!response.ok) {
        throw new Error(`Failed to fetch Jupiter token list: ${response.status}`);
      }
      const tokenList = await response.json();
      const tokenMap = {};
      for (const token of tokenList) {
        if (token.address && token.symbol) {
          tokenMap[token.address] = {
            symbol: token.symbol,
            name: token.name || token.symbol,
            logoURI: token.logoURI,
            decimals: token.decimals || 0,
            address: token.address
          };
        }
      }
      this.tokenListCache = tokenMap;
      return tokenMap;
    } catch (error) {
      console.warn(`Failed to fetch token list:`, error);
      return {};
    }
  }
  async getSolBalance(publicKey2) {
    const lamports = await this.connection.getBalance(publicKey2);
    const solAmount = lamports / LAMPORTS_PER_SOL;
    try {
      const response = await fetch("https://price.jup.ag/v4/price?ids=SOL");
      if (!response.ok) {
        throw new Error(`Failed to fetch SOL price, status: ${response.status}`);
      }
      const priceData = await response.json();
      if (priceData?.data?.SOL?.price) {
        const solPrice = Number(priceData.data.SOL.price);
        if (!isNaN(solPrice) && solPrice > 0) {
          return {
            amount: solAmount,
            usdValue: solAmount * solPrice
          };
        }
      }
    } catch (error) {
      console.warn(`Failed to fetch SOL price:`, error);
    }
    return { amount: solAmount };
  }
  async getSplTokenBalances(publicKey2) {
    try {
      const lamports = await this.connection.getBalance(publicKey2);
      const solAmount = lamports / LAMPORTS_PER_SOL;
      let solUsdValue = void 0;
      try {
        const solPriceResponse = await fetch("https://price.jup.ag/v4/price?ids=SOL");
        if (solPriceResponse.ok) {
          const solPriceData = await solPriceResponse.json();
          if (solPriceData?.data?.SOL?.price) {
            const solPrice = Number(solPriceData.data.SOL.price);
            if (!isNaN(solPrice) && solPrice > 0) {
              solUsdValue = solAmount * solPrice;
            }
          }
        }
      } catch (solPriceError) {
        console.error("Error fetching SOL price:", solPriceError);
      }
      const tokenAccounts = await this.connection.getTokenAccountsByOwner(
        publicKey2,
        { programId: TOKEN_PROGRAM_ID }
      );
      const mintAddresses = [];
      const accountsToProcess = [];
      for (const item of tokenAccounts.value) {
        try {
          const accountInfo = await this.connection.getParsedAccountInfo(item.pubkey);
          if (!accountInfo.value) continue;
          const parsedData = "parsed" in accountInfo.value.data ? accountInfo.value.data.parsed : null;
          if (!parsedData || parsedData.type !== "account") continue;
          const info = parsedData.info;
          if (!info || !info.mint) continue;
          mintAddresses.push(info.mint);
          accountsToProcess.push(item);
        } catch (error) {
          console.error(`Failed to pre-process token account ${item.pubkey.toBase58()}:`, error);
        }
      }
      const tokenMap = await this.getTokenList();
      const priceMap = await this.getTokenPrices();
      const balances = [];
      balances.push({
        mint: "SOL",
        amount: lamports.toString(),
        decimals: 9,
        uiAmount: solAmount,
        symbol: "SOL",
        name: "Solana",
        logo: "https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/So11111111111111111111111111111111111111112/logo.png",
        usdValue: solUsdValue
      });
      for (const { pubkey } of accountsToProcess) {
        try {
          const accountInfo = await this.connection.getParsedAccountInfo(pubkey);
          if (!accountInfo.value) continue;
          const parsedData = "parsed" in accountInfo.value.data ? accountInfo.value.data.parsed : null;
          if (!parsedData || parsedData.type !== "account") continue;
          const info = parsedData.info;
          if (!info || !info.mint || !info.tokenAmount) continue;
          const mintAddress = info.mint;
          const amount = info.tokenAmount.amount;
          const decimals = info.tokenAmount.decimals || 0;
          const uiAmount = info.tokenAmount.uiAmount || Number(amount) / Math.pow(10, decimals);
          const metadata = tokenMap[mintAddress];
          let usdValue = void 0;
          const price = priceMap[mintAddress];
          if (price && !isNaN(price) && price > 0) {
            usdValue = uiAmount * price;
          }
          if (mintAddress === "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v" && usdValue === void 0) {
            usdValue = uiAmount;
          }
          balances.push({
            mint: mintAddress,
            amount: amount.toString(),
            decimals,
            uiAmount,
            symbol: metadata?.symbol,
            name: metadata?.name,
            logo: metadata?.logoURI,
            usdValue
          });
        } catch (error) {
          console.error(`Failed to process token account ${pubkey.toBase58()}:`, error);
        }
      }
      return balances;
    } catch (error) {
      console.error(`Error fetching SPL token balances:`, error);
      return [];
    }
  }
}
function promisifyRequest(request) {
  return new Promise((resolve, reject) => {
    request.oncomplete = request.onsuccess = () => resolve(request.result);
    request.onabort = request.onerror = () => reject(request.error);
  });
}
function createStore(dbName, storeName) {
  let dbp;
  const getDB = () => {
    if (dbp)
      return dbp;
    const request = indexedDB.open(dbName);
    request.onupgradeneeded = () => request.result.createObjectStore(storeName);
    dbp = promisifyRequest(request);
    dbp.then((db) => {
      db.onclose = () => dbp = void 0;
    }, () => {
    });
    return dbp;
  };
  return (txMode, callback) => getDB().then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));
}
let defaultGetStoreFunc;
function defaultGetStore() {
  if (!defaultGetStoreFunc) {
    defaultGetStoreFunc = createStore("keyval-store", "keyval");
  }
  return defaultGetStoreFunc;
}
function get(key, customStore = defaultGetStore()) {
  return customStore("readonly", (store) => promisifyRequest(store.get(key)));
}
function set(key, value, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.put(value, key);
    return promisifyRequest(store.transaction);
  });
}
function del(key, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.delete(key);
    return promisifyRequest(store.transaction);
  });
}
function clear(customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.clear();
    return promisifyRequest(store.transaction);
  });
}
function eachCursor(store, callback) {
  store.openCursor().onsuccess = function() {
    if (!this.result)
      return;
    callback(this.result);
    this.result.continue();
  };
  return promisifyRequest(store.transaction);
}
function keys(customStore = defaultGetStore()) {
  return customStore("readonly", (store) => {
    if (store.getAllKeys) {
      return promisifyRequest(store.getAllKeys());
    }
    const items = [];
    return eachCursor(store, (cursor) => items.push(cursor.key)).then(() => items);
  });
}
class IdbStorage {
  get store() {
    if (!this._store) {
      this._store = createStore("signer-db", "signer-store");
    }
    return this._store;
  }
  async get(key) {
    return get(key, this.store);
  }
  async set(key, value) {
    return set(key, value, this.store);
  }
  async remove(key) {
    return del(key, this.store);
  }
}
const getIdentity = async (key, storage) => {
  const value = await storage.get(`identity-${key}`);
  if (!value) {
    return;
  }
  return typeof value === "string" ? Ed25519KeyIdentity.fromJSON(value) : ECDSAKeyIdentity.fromKeyPair(value);
};
const setIdentity = async (key, identity, storage) => {
  const value = identity instanceof Ed25519KeyIdentity ? JSON.stringify(identity.toJSON()) : identity.getKeyPair();
  return storage.set(`identity-${key}`, value);
};
const removeIdentity = async (key, storage) => {
  return storage.remove(`identity-${key}`);
};
const getDelegationChain = async (key, storage) => {
  const json = await storage.get(`delegation-${key}`);
  if (!json || typeof json !== "string") {
    return;
  }
  return DelegationChain.fromJSON(json);
};
const setDelegationChain = async (key, delegationChain, storage) => {
  return storage.set(`delegation-${key}`, JSON.stringify(delegationChain.toJSON()));
};
const removeDelegationChain = async (key, storage) => {
  return storage.remove(`delegation-${key}`);
};
const isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
const _SiwsAdapter = class _SiwsAdapter extends BaseAdapter {
  constructor(args) {
    super(args);
    this.state = Adapter.Status.INIT;
    this.solanaAdapter = null;
    this.identity = null;
    this.principal = null;
    this.solanaAddress = null;
    this.sessionKey = null;
    this.handleSolanaConnect = (publicKey2) => {
      this.solanaAddress = publicKey2.toBase58();
    };
    this.handleSolanaDisconnect = () => {
      if (this.state !== Adapter.Status.DISCONNECTING && this.state !== Adapter.Status.DISCONNECTED) {
        this.disconnect();
      }
    };
    this.handleSolanaError = (error) => {
      this.logger.error(`Solana wallet error`, error, {
        wallet: this.walletName
      });
      this.state = Adapter.Status.ERROR;
      this.disconnect();
    };
    this.id = args.adapter.id;
    this.walletName = args.adapter.walletName;
    this.logo = args.adapter.logo;
    this.config = args.config;
    this.storage = new IdbStorage();
    const network = this.config.solanaNetwork || WalletAdapterNetwork.Mainnet;
    const endpoint = network === WalletAdapterNetwork.Mainnet ? "https://wiser-omniscient-thunder.solana-mainnet.quiknode.pro/c3a27d9cb72eb335a30e3407d576ef64e61b4e8d" : "https://api.devnet.solana.com";
    this.solanaConnection = new Connection(endpoint);
    this.tokenManager = new TokenManager(this.solanaConnection);
    if (isBrowser && this.id !== "walletconnectSiws") {
      this.solanaAdapter = this.createSolanaAdapter(network);
      this.setupWalletListeners();
    }
    this.state = Adapter.Status.READY;
    this.restoreFromStorage().catch((error) => {
      this.logger.debug("Failed to restore from storage:", error);
    });
  }
  async restoreFromStorage() {
    try {
      this.logger.debug(`[${this.id}] Attempting to restore from storage...`);
      const storedSessionKey = await getIdentity(this.id, this.storage);
      const delegationChain = await getDelegationChain(this.id, this.storage);
      const storedSolanaAddress = await this.storage.get(`${this.id}-solana-address`);
      if (!storedSessionKey || !delegationChain) {
        this.logger.debug(`[${this.id}] No session key or delegation chain found in storage.`);
        await this.clearStoredSession();
        return;
      }
      const expiration = delegationChain.delegations[0].delegation.expiration;
      if (expiration < BigInt(Date.now() * 1e6)) {
        this.logger.debug(`[${this.id}] Stored delegation chain has expired.`);
        await this.clearStoredSession();
        return;
      }
      this.logger.debug(`[${this.id}] Found valid session key and delegation chain, restoring...`);
      this.sessionKey = storedSessionKey;
      this.identity = DelegationIdentity.fromDelegation(
        this.sessionKey,
        delegationChain
      );
      this.principal = this.identity.getPrincipal();
      if (storedSolanaAddress && typeof storedSolanaAddress === "string") {
        this.solanaAddress = storedSolanaAddress;
      } else {
        this.logger.warn(`[${this.id}] Solana address missing from storage during restore. Clearing session.`);
        await this.clearStoredSession();
        return;
      }
      this.logger.debug(`[${this.id}] Successfully restored connection.`);
      this.state = Adapter.Status.CONNECTED;
    } catch (error) {
      this.logger.error(`[${this.id}] Error restoring from storage:`, error);
      await this.clearStoredSession();
    }
  }
  async clearStoredSession() {
    this.identity = null;
    this.principal = null;
    this.solanaAddress = null;
    this.sessionKey = null;
    await removeIdentity(this.id, this.storage);
    await removeDelegationChain(this.id, this.storage);
    await this.storage.remove(`${this.id}-solana-address`);
    this.state = Adapter.Status.READY;
    this.logger.debug(`[${this.id}] Cleared stored session data.`);
  }
  async createSolanaAdapter(network) {
    if (!isBrowser) {
      throw new Error(
        "Cannot create Solana adapter in non-browser environment"
      );
    }
    switch (this.id) {
      case "phantomSiws":
        return new PhantomWalletAdapter();
      case "solflareSiws":
        return new SolflareWalletAdapter({ network });
      case "backpackSiws":
        return new BackpackWalletAdapter();
      case "walletconnectSiws": {
        const { WalletConnectWalletAdapter } = await import("./index-Cw4ENCH_.js").then((n) => n.V);
        const wcAdapter = new WalletConnectWalletAdapter({
          network,
          options: {
            relayUrl: "wss://relay.walletconnect.com",
            projectId: this.config.projectId || "",
            metadata: {
              name: this.config.appName || "W98 dApp",
              description: this.config.appDescription || "A dApp using WalletConnect for Solana",
              url: this.config.appUrl || "https://w98.io",
              icons: this.config.appIcons || ["https://w98.io/logo.png"]
            }
          }
        });
        this.logger.debug(
          `WalletConnect adapter created with config:`,
          wcAdapter
        );
        return wcAdapter;
      }
      default:
        throw new Error(`Unsupported SIWS adapter ID: ${this.id}`);
    }
  }
  setupWalletListeners() {
    if (!this.solanaAdapter) return;
    this.solanaAdapter.then((adapter) => {
      adapter.on("connect", this.handleSolanaConnect);
      adapter.on("disconnect", this.handleSolanaDisconnect);
      adapter.on("error", this.handleSolanaError);
    });
  }
  removeWalletListeners() {
    if (!this.solanaAdapter) return;
    this.solanaAdapter.then((adapter) => {
      adapter.off("connect", this.handleSolanaConnect);
      adapter.off("disconnect", this.handleSolanaDisconnect);
      adapter.off("error", this.handleSolanaError);
    });
  }
  async isConnected() {
    if (!this.solanaAdapter) return false;
    const adapter = await this.solanaAdapter;
    return adapter.connected && this.identity !== null && !this.identity.getPrincipal().isAnonymous();
  }
  async connect() {
    if (!isBrowser) {
      throw new Error("Cannot connect to wallet in non-browser environment");
    }
    if (this.identity && this.principal && this.state === Adapter.Status.CONNECTED) {
      return {
        owner: this.principal.toText(),
        subaccount: deriveAccountId(this.principal)
      };
    }
    if (!this.identity) {
      try {
        await this.restoreFromStorage();
        if (this.identity && this.principal && this.state === Adapter.Status.CONNECTED) {
          return {
            owner: this.principal.toText(),
            subaccount: deriveAccountId(this.principal)
          };
        }
      } catch (error) {
        this.logger.debug(`[${this.id}] Failed to restore from storage during connect attempt:`, error);
        await this.clearStoredSession();
      }
    }
    if (this.identity && this.principal && this.state === Adapter.Status.CONNECTED) {
      return {
        owner: this.principal.toText(),
        subaccount: deriveAccountId(this.principal)
      };
    }
    if (!this.solanaAdapter) {
      const network = this.config.solanaNetwork || WalletAdapterNetwork.Mainnet;
      this.logger.debug(`Creating Solana adapter for network: ${network}`, {
        wallet: this.walletName
      });
      this.solanaAdapter = this.createSolanaAdapter(network);
      this.setupWalletListeners();
    }
    if (this.state === Adapter.Status.CONNECTING) {
      this.logger.warn(`[${this.id}] Connect called while already connecting. Waiting for existing attempt.`);
    }
    if (this.state !== Adapter.Status.READY && this.state !== Adapter.Status.INIT && this.state !== Adapter.Status.DISCONNECTED) {
      this.logger.warn(`[${this.id}] Connect called from unexpected state ${this.state}. Resetting to READY.`);
      this.state = Adapter.Status.READY;
    }
    if (this.state !== Adapter.Status.READY && this.state !== Adapter.Status.DISCONNECTED && this.state !== Adapter.Status.INIT) {
      throw new Error(`Cannot connect while in state: ${this.state}`);
    }
    this.state = Adapter.Status.CONNECTING;
    try {
      const adapter = await this.solanaAdapter;
      if (!adapter) {
        throw new Error("Solana adapter not initialized");
      }
      if (!adapter.connected) {
        try {
          if (this.id === "walletconnectSiws" && adapter.readyState !== WalletReadyState.Loadable) {
            await new Promise((resolve) => setTimeout(resolve, 200));
          }
          await adapter.connect();
        } catch (error) {
          this.logger.error(`Wallet connection error`, error, {
            wallet: this.walletName
          });
          if (error.name === "WalletWindowClosedError" || error.message?.includes("User rejected the request") || error.message?.includes("Wallet closed")) {
            this.logger.warn(
              `Connection cancelled by user (modal closed or rejected).`,
              { wallet: this.walletName }
            );
            this.state = Adapter.Status.DISCONNECTED;
            const cancelError = new Error("Connection cancelled by user");
            cancelError.name = "UserCancelledError";
            throw cancelError;
          }
          this.state = Adapter.Status.ERROR;
          if (adapter.connected) {
            try {
              await adapter.disconnect();
            } catch (disconnectError) {
              this.logger.error(
                `Error during cleanup disconnect`,
                disconnectError,
                { wallet: this.walletName }
              );
            }
          }
          throw error;
        }
      } else {
        this.logger.debug(`Adapter already connected.`, {
          wallet: this.walletName
        });
      }
      if (!adapter.publicKey) {
        throw new Error(
          "Solana wallet connected, but public key is unavailable."
        );
      }
      this.solanaAddress = adapter.publicKey.toBase58();
      await this.storage.set(`${this.id}-solana-address`, this.solanaAddress);
      const siwsResult = await this.performSiwsLogin(this.solanaAddress);
      this.identity = siwsResult.identity;
      this.principal = siwsResult.principal;
      this.sessionKey = siwsResult.sessionKey;
      if (this.sessionKey) {
        await setIdentity(this.id, this.sessionKey, this.storage);
      }
      if (this.identity instanceof DelegationIdentity) {
        await setDelegationChain(this.id, this.identity.getDelegation(), this.storage);
      } else {
        this.logger.warn(`[${this.id}] SIWS login did not result in a DelegationIdentity. Cannot store delegation chain.`);
      }
      if (!this.principal || this.principal.isAnonymous()) {
        await this.clearStoredSession();
        throw new Error("SIWS login failed: Resulted in anonymous principal.");
      }
      this.logger.debug(`[${this.id}] Successfully connected and session stored.`);
      this.state = Adapter.Status.CONNECTED;
      return {
        owner: this.principal.toText(),
        subaccount: deriveAccountId(this.principal)
      };
    } catch (error) {
      this.logger.error(`Overall connect process failed`, error, {
        wallet: this.walletName
      });
      await this.clearStoredSession();
      if (error.name === "UserCancelledError") {
        this.state = Adapter.Status.DISCONNECTED;
      } else {
        this.state = Adapter.Status.ERROR;
      }
      if (this.solanaAdapter) {
        try {
          const adapter = await this.solanaAdapter;
          if (adapter && adapter.connected) {
            if (error.name !== "UserCancelledError") {
              await adapter.disconnect();
            }
          }
        } catch (cleanupError) {
          this.logger.error(
            `Error during final cleanup disconnect`,
            cleanupError,
            { wallet: this.walletName }
          );
        }
      }
      throw error;
    }
  }
  async disconnect() {
    if (!isBrowser) return;
    if (this.state === Adapter.Status.DISCONNECTING || this.state === Adapter.Status.DISCONNECTED) {
      return;
    }
    this.logger.debug(`[${this.id}] Disconnecting...`);
    this.state = Adapter.Status.DISCONNECTING;
    try {
      if (this.solanaAdapter) {
        const adapter = await this.solanaAdapter;
        if (adapter.connected) {
          this.removeWalletListeners();
          await adapter.disconnect();
          this.setupWalletListeners();
        }
      }
    } catch (error) {
      this.logger.warn(`Error during Solana disconnect`, {
        error,
        wallet: this.walletName
      });
    } finally {
      await this.clearStoredSession();
      this.state = Adapter.Status.DISCONNECTED;
      this.logger.debug(`[${this.id}] Disconnected and session cleared.`);
    }
  }
  async getPrincipal() {
    if (!this.principal) {
      throw new Error("Not connected or SIWS flow not completed.");
    }
    return this.principal.toText();
  }
  async getAccountId() {
    const principal = await this.getPrincipal();
    if (!principal)
      throw new Error("Principal not available to derive account ID");
    return deriveAccountId(principal);
  }
  async getSolanaAddress() {
    if (!this.solanaAddress) {
      throw new Error("Not connected or Solana address not available.");
    }
    return this.solanaAddress;
  }
  async getAddresses() {
    return {
      sol: {
        address: this.solanaAddress,
        network: this.config.solanaNetwork
      },
      icp: {
        address: this.principal?.toText(),
        subaccount: deriveAccountId(this.principal)
      }
    };
  }
  createActorInternal(canisterId, idl, options) {
    const requiresSigning = options?.requiresSigning ?? true;
    if (requiresSigning && !this.identity) {
      throw new Error(
        "Cannot create signed actor: Not connected or SIWS flow not completed."
      );
    }
    const agent = HttpAgent.createSync({
      host: this.config.hostUrl,
      identity: this.identity,
      verifyQuerySignatures: this.config.verifyQuerySignatures
    });
    if (this.config.fetchRootKey) {
      agent.fetchRootKey();
    }
    return Actor.createActor(idl, { agent, canisterId });
  }
  async getSolBalance() {
    if (!this.solanaAdapter) return { amount: 0, usdValue: 0 };
    const adapter = await this.solanaAdapter;
    if (!adapter.connected || !adapter.publicKey) {
      throw new Error("Solana wallet not connected or public key unavailable.");
    }
    return this.tokenManager.getSolBalance(adapter.publicKey);
  }
  async getSplTokenBalances() {
    if (!this.solanaAdapter) return [];
    const adapter = await this.solanaAdapter;
    if (!adapter.connected || !adapter.publicKey) {
      throw new Error("Solana wallet not connected or public key unavailable.");
    }
    return this.tokenManager.getSplTokenBalances(adapter.publicKey);
  }
  createSiwsProviderActor(identity) {
    if (!this.config.siwsProviderCanisterId) {
      throw new Error("SIWS provider canister ID not configured.");
    }
    const agent = HttpAgent.createSync({
      host: this.config.hostUrl,
      identity: identity ?? new AnonymousIdentity(),
      verifyQuerySignatures: this.config.verifyQuerySignatures
    });
    if (this.config.fetchRootKey) {
      agent.fetchRootKey();
    }
    return Actor.createActor(idlFactory, {
      agent,
      canisterId: this.config.siwsProviderCanisterId
    });
  }
  async _prepareLogin(actor, address) {
    const prepareResult = await actor.siws_prepare_login(address);
    if ("Err" in prepareResult) {
      const errorMsg = `Prepare login error: ${JSON.stringify(prepareResult.Err)}`;
      this.logger.error(errorMsg, new Error(errorMsg));
      throw new Error(
        `SIWS Prepare Login failed: ${JSON.stringify(prepareResult.Err)}`
      );
    }
    return prepareResult.Ok;
  }
  async _signSiwsMessage(siwsMessage) {
    const messageText = formatSiwsMessage(siwsMessage);
    const messageBytes = new TextEncoder().encode(messageText);
    if (!this.solanaAdapter) {
      throw new Error("Solana adapter not connected.");
    }
    const adapter = await this.solanaAdapter;
    if (!("signMessage" in adapter)) {
      throw new Error(
        `Connected Solana adapter '${this.walletName}' does not support signMessage.`
      );
    }
    const signerAdapter = adapter;
    const signatureBytes = await signerAdapter.signMessage(messageBytes);
    try {
      if (typeof signatureBytes === "object" && "signature" in signatureBytes && signatureBytes.signature instanceof Uint8Array) {
        return base58.encode(signatureBytes.signature);
      }
      if (signatureBytes instanceof Uint8Array) {
        return base58.encode(signatureBytes);
      }
      if (signatureBytes instanceof ArrayBuffer) {
        return base58.encode(new Uint8Array(signatureBytes));
      }
      if (Array.isArray(signatureBytes) || typeof signatureBytes === "object" && "length" in signatureBytes) {
        return base58.encode(new Uint8Array(signatureBytes));
      }
      this.logger.warn(
        `Unexpected signature bytes type: ${typeof signatureBytes}`,
        { signatureBytes, wallet: this.walletName }
      );
      const fallbackArray = Object.values(signatureBytes).map(
        (val) => Number(val)
      );
      return base58.encode(Uint8Array.from(fallbackArray));
    } catch (e3) {
      this.logger.error(`Error encoding signature`, e3, {
        wallet: this.walletName
      });
      throw new Error(
        `Failed to encode signature from ${this.walletName}: ${e3.message}`
      );
    }
  }
  _generateSessionIdentity() {
    const sessionIdentity = Ed25519KeyIdentity.generate();
    const sessionPublicKeyDer = sessionIdentity.getPublicKey().toDer();
    return { sessionIdentity, sessionPublicKeyDer };
  }
  async _loginWithSiws(actor, signature2, address, sessionPublicKeyDer, siwsMessage) {
    const loginResult = await actor.siws_login(
      signature2,
      address,
      new Uint8Array(sessionPublicKeyDer),
      siwsMessage.nonce
    );
    if ("Err" in loginResult) {
      const errorMsg = `SIWS Login failed: ${JSON.stringify(loginResult.Err)}`;
      this.logger.error(errorMsg, new Error(errorMsg));
      throw new Error(errorMsg);
    }
    return loginResult.Ok;
  }
  async _getSiwsDelegation(actor, address, sessionPublicKeyDer, expiration) {
    const delegationResult = await actor.siws_get_delegation(
      address,
      new Uint8Array(sessionPublicKeyDer),
      expiration
    );
    if ("Err" in delegationResult) {
      const errorMsg = `SIWS Get Delegation failed: ${JSON.stringify(delegationResult.Err)}`;
      this.logger.error(errorMsg, new Error(errorMsg));
      throw new Error(errorMsg);
    }
    return delegationResult.Ok;
  }
  _createDelegationIdentity(signedDelegation, sessionIdentity, userCanisterPublicKeyDer) {
    const delegation = new Delegation(
      signedDelegation.delegation.pubkey.slice().buffer,
      signedDelegation.delegation.expiration,
      signedDelegation.delegation.targets.length > 0 ? signedDelegation.delegation.targets[0] : void 0
    );
    const delegations = [
      {
        delegation,
        signature: signedDelegation.signature.slice().buffer
      }
    ];
    const delegationChain = DelegationChain.fromDelegations(
      delegations,
      userCanisterPublicKeyDer
    );
    const identity = DelegationIdentity.fromDelegation(
      sessionIdentity,
      delegationChain
    );
    return identity;
  }
  async performSiwsLogin(address) {
    const anonSiwsActor = this.createSiwsProviderActor();
    const siwsMessage = await this._prepareLogin(anonSiwsActor, address);
    const signature2 = await this._signSiwsMessage(siwsMessage);
    const { sessionIdentity, sessionPublicKeyDer } = this._generateSessionIdentity();
    const loginDetails = await this._loginWithSiws(
      anonSiwsActor,
      signature2,
      address,
      sessionPublicKeyDer,
      siwsMessage
    );
    const signedDelegation = await this._getSiwsDelegation(
      anonSiwsActor,
      address,
      sessionPublicKeyDer,
      loginDetails.expiration
    );
    const delegationIdentity = this._createDelegationIdentity(
      signedDelegation,
      sessionIdentity,
      // Pass the Ed25519KeyIdentity here
      loginDetails.user_canister_pubkey.slice().buffer
    );
    const principal = delegationIdentity.getPrincipal();
    return { identity: delegationIdentity, principal, sessionKey: sessionIdentity };
  }
};
_SiwsAdapter.supportedChains = [
  Adapter.Chain.ICP,
  Adapter.Chain.SOL
];
let SiwsAdapter = _SiwsAdapter;
class IIAdapter extends BaseAdapter {
  constructor(args) {
    super(args);
    this.authClient = null;
    this.agent = null;
    this.initializeAuthClient();
  }
  async initializeAuthClient() {
    try {
      const client = await AuthClient.create({
        idleOptions: {
          idleTimeout: Number(this.config.timeout ?? 1e3 * 60 * 60 * 24),
          // Default 24 hours
          disableDefaultIdleCallback: true
        }
      });
      this.authClient = client;
      this.authClient.idleManager?.registerCallback?.(() => this.refreshLogin());
    } catch (err) {
      console.error("[II] Failed to create AuthClient:", err);
      this.setState(Adapter.Status.ERROR);
      throw err;
    }
  }
  // Use the resolved config for agent initialization
  async initAgent(identity) {
    this.agent = HttpAgent.createSync({
      identity,
      host: this.config.hostUrl,
      // verifyQuerySignatures comes from the nested adapter config, falling back to global
      verifyQuerySignatures: this.config.verifyQuerySignatures
    });
    console.log("fetchRootKey", this.config.fetchRootKey);
    await fetchRootKeyIfNeeded(
      this.agent,
      this.config.fetchRootKey
    );
  }
  getIdentityProvider() {
    if (this.config.dfxNetwork === "local") {
      return `${this.config.hostUrl}/?canisterId=${this.config.localIdentityCanisterId}`;
    }
    return "https://identity.ic0.app";
  }
  async connect() {
    try {
      this.setState(Adapter.Status.CONNECTING);
      if (!this.authClient) {
        await this.initializeAuthClient();
      }
      const isAuthenticated = await this.authClient.isAuthenticated();
      if (!isAuthenticated) {
        console.log("idprovider", this.getIdentityProvider());
        return new Promise((resolve, reject) => {
          this.authClient.login({
            derivationOrigin: this.config.derivationOrigin,
            identityProvider: this.getIdentityProvider(),
            maxTimeToLive: BigInt((this.config.timeout ?? 1 * 24 * 60 * 60) * 1e3 * 1e3 * 1e3),
            // Default 1 day
            onSuccess: async () => {
              try {
                const account2 = await this._continueLogin();
                this.setState(Adapter.Status.CONNECTED);
                resolve(account2);
              } catch (error) {
                this.setState(Adapter.Status.ERROR);
                reject(error);
              }
            },
            onError: (error) => {
              console.error("[II] Login error:", error);
              this.setState(Adapter.Status.ERROR);
              reject(new Error(`II Authentication failed: ${error}`));
            }
          });
        });
      }
      const account = await this._continueLogin();
      this.setState(Adapter.Status.CONNECTED);
      return account;
    } catch (error) {
      this.setState(Adapter.Status.ERROR);
      throw error;
    }
  }
  async _continueLogin() {
    if (!this.authClient) {
      throw new Error("AuthClient not available in _continueLogin");
    }
    try {
      const identity = this.authClient.getIdentity();
      if (!identity) {
        throw new Error("No identity available after login");
      }
      const principal = identity.getPrincipal();
      if (principal.isAnonymous()) {
        throw new Error("Login resulted in anonymous principal");
      }
      await this.initAgent(identity);
      const account = await createAccountFromPrincipal(principal);
      if (!account || !account.owner) {
        throw new Error("Failed to create valid account from principal");
      }
      return account;
    } catch (error) {
      console.error("[II] Error in _continueLogin:", error);
      this.setState(Adapter.Status.ERROR);
      throw error;
    }
  }
  async isConnected() {
    return this.authClient ? await this.authClient.isAuthenticated() : false;
  }
  // Implementation for BaseIcAdapter actor caching
  createActorInternal(canisterId, idl, options) {
    if (!this.agent) {
      throw new Error("Agent not initialized. Connect first.");
    }
    return Actor.createActor(idl, {
      agent: this.agent,
      canisterId
    });
  }
  async getPrincipal() {
    if (!this.authClient) throw new Error("Not connected");
    const identity = this.authClient.getIdentity();
    if (!identity) throw new Error("Identity not available");
    const principal = identity.getPrincipal();
    return principal.toText();
  }
  async refreshLogin() {
    try {
      await this.connect();
    } catch (error) {
      console.error("[II] Failed to refresh login:", error);
      await this.disconnect().catch(() => {
      });
    }
  }
  // Disconnect logic specific to II
  async disconnectInternal() {
    if (this.authClient) {
      await this.authClient.logout();
    }
  }
  // Cleanup logic specific to II
  cleanupInternal() {
    this.authClient = null;
    this.agent = null;
  }
}
class PlugAdapter extends BaseAdapter {
  // Update every 2 seconds
  // state and config are inherited
  // Constructor calls super and does Plug specific initialization
  constructor(args) {
    super(args);
    this.readyState = "NotDetected";
    this._connectionState = false;
    this._connectionStateTimestamp = 0;
    this._connectionStateUpdateInterval = 2e3;
    this.initPlug();
    this.updateConnectionState();
  }
  // Initialize Plug and set readyState accordingly
  initPlug() {
    if (typeof window !== "undefined" && window.ic?.plug) {
      window.ic.plug.isConnected().then((connected) => {
        this.readyState = connected ? "Connected" : "Installed";
        if (connected) {
          this.setState(Adapter.Status.CONNECTED);
        } else {
          this.setState(Adapter.Status.READY);
        }
      });
    } else {
      this.readyState = "NotDetected";
      this.setState(Adapter.Status.INIT);
    }
  }
  async connect() {
    this.setState(Adapter.Status.CONNECTING);
    const isConnected = await this.isConnected();
    if (!isConnected) {
      if (!window.ic?.plug) {
        this.setState(Adapter.Status.ERROR);
        throw new Error("Plug Wallet extension not detected.");
      }
      try {
        const connected = await window.ic.plug.requestConnect({
          whitelist: this.adapter.config.delegationTargets?.filter((p) => p != null) || [],
          host: this.adapter.config.hostUrl,
          timeout: this.adapter.config.timeout || 1e3 * 60 * 60 * 24 * 7,
          onConnectionUpdate: () => this.handleConnectionUpdate()
        });
        if (!connected) {
          this.setState(Adapter.Status.READY);
          throw new Error("User declined the connection request");
        }
        this.readyState = "Connected";
      } catch (e3) {
        this.setState(Adapter.Status.READY);
        console.error("Failed to connect to Plug wallet:", e3);
        throw e3;
      }
    } else {
      this.readyState = "Connected";
    }
    this._connectionState = true;
    this._connectionStateTimestamp = Date.now();
    this.setState(Adapter.Status.CONNECTED);
    const principal = await this.getPrincipal();
    return createAccountFromPrincipal(principal);
  }
  // disconnect method is inherited, uses disconnectInternal and cleanupInternal
  async getPrincipal() {
    if (this.readyState === "Connected" && window.ic?.plug?.principalId) {
      return Principal.fromText(window.ic.plug.principalId).toText();
    } else if (this.readyState === "Installed") {
      throw new Error("Plug wallet is installed but not connected.");
    } else {
      throw new Error("Plug wallet is not available or principal ID is unavailable");
    }
  }
  // getAccountId is inherited
  // Implementation of the required abstract method from BaseIcAdapter
  createActorInternal(canisterId, idl, options) {
    if (!window.ic?.plug?.createActor) {
      throw new Error("Plug wallet is not available or not connected to create actor.");
    }
    if (!canisterId || !idl) {
      throw new Error("Canister ID and IDL factory are required");
    }
    try {
      const actorPromise = window.ic.plug.createActor({
        canisterId,
        interfaceFactory: idl
      });
      const proxy = new Proxy({}, {
        get: (_2, prop) => {
          if (prop === "then") {
            return void 0;
          }
          return (...args) => {
            return actorPromise.then((actor) => {
              const value = actor[prop];
              if (typeof value === "function") {
                return value.apply(actor, args);
              }
              return value;
            });
          };
        }
      });
      return proxy;
    } catch (e3) {
      console.error("Failed to create actor through Plug:", e3);
      throw e3;
    }
  }
  // Plug specific connection state update
  async updateConnectionState() {
    if (window.ic?.plug?.isConnected) {
      this._connectionState = await window.ic.plug.isConnected();
      this._connectionStateTimestamp = Date.now();
      this.readyState = this._connectionState ? "Connected" : "Installed";
      if (this._connectionState && this.state !== Adapter.Status.CONNECTED) {
        this.setState(Adapter.Status.CONNECTED);
      } else if (!this._connectionState && this.state === Adapter.Status.CONNECTED) {
        this.setState(Adapter.Status.READY);
      }
    } else {
      this._connectionState = false;
      this.readyState = "NotDetected";
      this.setState(Adapter.Status.INIT);
    }
  }
  // Use polling check for synchronous isConnected
  async isConnected() {
    if (Date.now() - this._connectionStateTimestamp > this._connectionStateUpdateInterval) {
      this.updateConnectionState().catch((err) => console.error("[Plug] Failed background connection state update:", err));
    }
    return this._connectionState;
  }
  // Handle Plug's connection updates
  handleConnectionUpdate() {
    this.updateConnectionState().then(() => {
      window.dispatchEvent(new CustomEvent("pnp:connectionUpdate", { detail: { adapterId: "plug", state: this.state } }));
    }).catch((err) => console.error("[Plug] Error handling connection update:", err));
  }
  // Plug specific disconnect logic
  async disconnectInternal() {
    if (window.ic?.plug?.disconnect) {
      await window.ic.plug.disconnect();
    } else {
      console.warn("Plug wallet is not available for disconnect");
    }
  }
  // Plug specific cleanup (resetting internal state)
  cleanupInternal() {
    this.readyState = this._connectionState ? "Installed" : "NotDetected";
    this._connectionState = false;
    this._connectionStateTimestamp = 0;
  }
}
const NETWORK_ERROR = 4e3;
const ENCODE_CHUNK_SIZE = 1e5;
const fromBase64 = (base64) => {
  if (typeof globalThis.Buffer !== "undefined") {
    return globalThis.Buffer.from(base64, "base64").buffer;
  }
  if (typeof globalThis.atob !== "undefined") {
    return Uint8Array.from(globalThis.atob(base64), (m) => m.charCodeAt(0)).buffer;
  }
  throw Error("Could not decode base64 string");
};
const toBase64 = (bytes) => {
  if (typeof globalThis.Buffer !== "undefined") {
    return globalThis.Buffer.from(bytes).toString("base64");
  }
  if (typeof globalThis.btoa !== "undefined") {
    return btoa(Array.from({ length: Math.ceil(bytes.byteLength / ENCODE_CHUNK_SIZE) }).map((_2, index) => String.fromCharCode(...new Uint8Array(bytes.slice(index * ENCODE_CHUNK_SIZE, (index + 1) * ENCODE_CHUNK_SIZE)))).join(""));
  }
  throw Error("Could not encode base64 string");
};
var __classPrivateFieldSet$5 = function(receiver, state, value, kind, f2) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return state.set(receiver, value), value;
};
var __classPrivateFieldGet$5 = function(receiver, state, kind, f2) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _Signer_options, _Signer_channel, _Signer_establishingChannel, _Signer_scheduledChannelClosure;
class SignerError extends Error {
  constructor(error) {
    super(error.message);
    Object.setPrototypeOf(this, SignerError.prototype);
    this.code = error.code;
    this.data = error.data;
  }
}
const wrapTransportError = (error) => new SignerError({
  code: NETWORK_ERROR,
  message: error instanceof Error ? error.message : "Network error"
});
const unwrapResponse = (response) => {
  if ("error" in response) {
    throw new SignerError(response.error);
  }
  if ("result" in response) {
    return response.result;
  }
  throw new SignerError({
    code: NETWORK_ERROR,
    message: "Invalid response"
  });
};
class Signer {
  constructor(options) {
    _Signer_options.set(this, void 0);
    _Signer_channel.set(this, void 0);
    _Signer_establishingChannel.set(this, void 0);
    _Signer_scheduledChannelClosure.set(this, void 0);
    __classPrivateFieldSet$5(this, _Signer_options, Object.assign({ autoCloseTransportChannel: true, closeTransportChannelAfter: 200, crypto: globalThis.crypto }, options));
  }
  get transport() {
    return __classPrivateFieldGet$5(this, _Signer_options, "f").transport;
  }
  async openChannel() {
    clearTimeout(__classPrivateFieldGet$5(this, _Signer_scheduledChannelClosure, "f"));
    if (__classPrivateFieldGet$5(this, _Signer_establishingChannel, "f")) {
      await __classPrivateFieldGet$5(this, _Signer_establishingChannel, "f");
    }
    if (__classPrivateFieldGet$5(this, _Signer_channel, "f") && !__classPrivateFieldGet$5(this, _Signer_channel, "f").closed) {
      return __classPrivateFieldGet$5(this, _Signer_channel, "f");
    }
    const channel = __classPrivateFieldGet$5(this, _Signer_options, "f").transport.establishChannel();
    __classPrivateFieldSet$5(this, _Signer_establishingChannel, channel.then(() => {
    }).catch(() => {
    }));
    __classPrivateFieldSet$5(this, _Signer_channel, void 0);
    __classPrivateFieldSet$5(this, _Signer_channel, await channel.catch((error) => {
      throw wrapTransportError(error);
    }));
    __classPrivateFieldSet$5(this, _Signer_establishingChannel, void 0);
    return __classPrivateFieldGet$5(this, _Signer_channel, "f");
  }
  async closeChannel() {
    var _a2;
    await ((_a2 = __classPrivateFieldGet$5(this, _Signer_channel, "f")) === null || _a2 === void 0 ? void 0 : _a2.close());
  }
  async transformRequest(request) {
    if (__classPrivateFieldGet$5(this, _Signer_options, "f").derivationOrigin) {
      return Object.assign(Object.assign({}, request), { params: Object.assign(Object.assign({}, request.params), { icrc95DerivationOrigin: __classPrivateFieldGet$5(this, _Signer_options, "f").derivationOrigin }) });
    }
    return request;
  }
  async sendRequest(request) {
    const channel = await this.openChannel();
    return new Promise(async (resolve, reject) => {
      const responseListener = channel.addEventListener("response", async (response) => {
        if (response.id !== request.id) {
          return;
        }
        responseListener();
        closeListener();
        resolve(response);
        if (__classPrivateFieldGet$5(this, _Signer_options, "f").autoCloseTransportChannel) {
          __classPrivateFieldSet$5(this, _Signer_scheduledChannelClosure, setTimeout(() => {
            if (!channel.closed) {
              channel.close();
            }
          }, __classPrivateFieldGet$5(this, _Signer_options, "f").closeTransportChannelAfter));
        }
      });
      const closeListener = channel.addEventListener("close", () => {
        responseListener();
        closeListener();
        reject(new SignerError({
          code: NETWORK_ERROR,
          message: "Channel was closed before a response was received"
        }));
      });
      try {
        await channel.send(await this.transformRequest(request));
      } catch (error) {
        responseListener();
        closeListener();
        reject(wrapTransportError(error));
      }
    });
  }
  async supportedStandards() {
    const response = await this.sendRequest({
      id: __classPrivateFieldGet$5(this, _Signer_options, "f").crypto.randomUUID(),
      jsonrpc: "2.0",
      method: "icrc25_supported_standards"
    });
    const result = unwrapResponse(response);
    return result.supportedStandards;
  }
  async requestPermissions(scopes) {
    const response = await this.sendRequest({
      id: __classPrivateFieldGet$5(this, _Signer_options, "f").crypto.randomUUID(),
      jsonrpc: "2.0",
      method: "icrc25_request_permissions",
      params: { scopes }
    });
    const result = unwrapResponse(response);
    return result.scopes;
  }
  async permissions() {
    const response = await this.sendRequest({
      id: __classPrivateFieldGet$5(this, _Signer_options, "f").crypto.randomUUID(),
      jsonrpc: "2.0",
      method: "icrc25_permissions"
    });
    const result = unwrapResponse(response);
    return result.scopes;
  }
  async accounts() {
    const response = await this.sendRequest({
      id: __classPrivateFieldGet$5(this, _Signer_options, "f").crypto.randomUUID(),
      jsonrpc: "2.0",
      method: "icrc27_accounts"
    });
    const result = unwrapResponse(response);
    return result.accounts.map(({ owner, subaccount }) => ({
      owner: Principal.fromText(owner),
      subaccount: subaccount === void 0 ? void 0 : fromBase64(subaccount)
    }));
  }
  async delegation(params) {
    var _a2;
    const response = await this.sendRequest({
      id: __classPrivateFieldGet$5(this, _Signer_options, "f").crypto.randomUUID(),
      jsonrpc: "2.0",
      method: "icrc34_delegation",
      params: {
        publicKey: toBase64(params.publicKey),
        targets: (_a2 = params.targets) === null || _a2 === void 0 ? void 0 : _a2.map((p) => p.toText()),
        maxTimeToLive: params.maxTimeToLive === void 0 ? void 0 : String(params.maxTimeToLive)
      }
    });
    const result = unwrapResponse(response);
    return DelegationChain.fromDelegations(result.signerDelegation.map((delegation) => {
      var _a22;
      return {
        delegation: new Delegation(fromBase64(delegation.delegation.pubkey), BigInt(delegation.delegation.expiration), (_a22 = delegation.delegation.targets) === null || _a22 === void 0 ? void 0 : _a22.map((principal) => Principal.fromText(principal))),
        signature: fromBase64(delegation.signature)
      };
    }), fromBase64(result.publicKey));
  }
  async callCanister(params) {
    const response = await this.sendRequest({
      id: __classPrivateFieldGet$5(this, _Signer_options, "f").crypto.randomUUID(),
      jsonrpc: "2.0",
      method: "icrc49_call_canister",
      params: {
        canisterId: params.canisterId.toText(),
        sender: params.sender.toText(),
        method: params.method,
        arg: toBase64(params.arg)
      }
    });
    const result = unwrapResponse(response);
    const contentMap = fromBase64(result.contentMap);
    const certificate = fromBase64(result.certificate);
    return { contentMap, certificate };
  }
  async batchCallCanister(params) {
    const response = await this.sendRequest({
      id: __classPrivateFieldGet$5(this, _Signer_options, "f").crypto.randomUUID(),
      jsonrpc: "2.0",
      method: "icrc112_batch_call_canister",
      params: {
        sender: params.sender.toText(),
        requests: params.requests.map((requests) => requests.map((request) => ({
          canisterId: request.canisterId.toText(),
          method: request.method,
          arg: toBase64(request.arg)
        }))),
        validation: params.validation ? {
          canisterId: params.validation.canisterId.toText(),
          method: params.validation.method
        } : void 0
      }
    });
    const result = unwrapResponse(response);
    if (params.requests.length !== result.responses.length || params.requests.some((entries, index) => entries.length !== result.responses[index].length)) {
      throw new SignerError({
        code: NETWORK_ERROR,
        message: "Invalid batch call canister response, responses structure does not match request structure"
      });
    }
    return result.responses.map((responses) => responses.map((response2) => {
      if ("result" in response2) {
        const contentMap = fromBase64(response2.result.contentMap);
        const certificate = fromBase64(response2.result.certificate);
        return { result: { contentMap, certificate } };
      }
      return response2;
    }));
  }
}
_Signer_options = /* @__PURE__ */ new WeakMap(), _Signer_channel = /* @__PURE__ */ new WeakMap(), _Signer_establishingChannel = /* @__PURE__ */ new WeakMap(), _Signer_scheduledChannelClosure = /* @__PURE__ */ new WeakMap();
const isJsonRpcMessage = (message) => typeof message === "object" && !!message && "jsonrpc" in message && message.jsonrpc === "2.0";
const isJsonRpcResponse = (message) => isJsonRpcMessage(message) && "id" in message && (typeof message.id === "string" || typeof message.id === "number");
var __classPrivateFieldSet$4 = function(receiver, state, value, kind, f2) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return state.set(receiver, value), value;
};
var __classPrivateFieldGet$4 = function(receiver, state, kind, f2) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _PostMessageChannel_closeListeners, _PostMessageChannel_options, _PostMessageChannel_closed;
class PostMessageChannel {
  constructor(options) {
    _PostMessageChannel_closeListeners.set(this, /* @__PURE__ */ new Set());
    _PostMessageChannel_options.set(this, void 0);
    _PostMessageChannel_closed.set(this, false);
    __classPrivateFieldSet$4(this, _PostMessageChannel_options, Object.assign({ window: globalThis.window, manageFocus: true }, options));
  }
  get closed() {
    return __classPrivateFieldGet$4(this, _PostMessageChannel_closed, "f");
  }
  addEventListener(...[event, listener]) {
    switch (event) {
      case "close":
        __classPrivateFieldGet$4(this, _PostMessageChannel_closeListeners, "f").add(listener);
        return () => {
          __classPrivateFieldGet$4(this, _PostMessageChannel_closeListeners, "f").delete(listener);
        };
      case "response":
        const messageListener = async (event2) => {
          if (event2.source !== __classPrivateFieldGet$4(this, _PostMessageChannel_options, "f").signerWindow || event2.origin !== __classPrivateFieldGet$4(this, _PostMessageChannel_options, "f").signerOrigin || !isJsonRpcResponse(event2.data)) {
            return;
          }
          listener(event2.data);
        };
        __classPrivateFieldGet$4(this, _PostMessageChannel_options, "f").window.addEventListener("message", messageListener);
        return () => {
          __classPrivateFieldGet$4(this, _PostMessageChannel_options, "f").window.removeEventListener("message", messageListener);
        };
    }
  }
  async send(request) {
    if (__classPrivateFieldGet$4(this, _PostMessageChannel_closed, "f")) {
      throw new PostMessageTransportError("Communication channel is closed");
    }
    __classPrivateFieldGet$4(this, _PostMessageChannel_options, "f").signerWindow.postMessage(request, __classPrivateFieldGet$4(this, _PostMessageChannel_options, "f").signerOrigin);
    if (__classPrivateFieldGet$4(this, _PostMessageChannel_options, "f").manageFocus) {
      __classPrivateFieldGet$4(this, _PostMessageChannel_options, "f").signerWindow.focus();
    }
  }
  async close() {
    if (__classPrivateFieldGet$4(this, _PostMessageChannel_closed, "f")) {
      return;
    }
    __classPrivateFieldSet$4(this, _PostMessageChannel_closed, true);
    __classPrivateFieldGet$4(this, _PostMessageChannel_options, "f").signerWindow.close();
    if (__classPrivateFieldGet$4(this, _PostMessageChannel_options, "f").manageFocus) {
      __classPrivateFieldGet$4(this, _PostMessageChannel_options, "f").window.focus();
    }
    __classPrivateFieldGet$4(this, _PostMessageChannel_closeListeners, "f").forEach((listener) => listener());
  }
}
_PostMessageChannel_closeListeners = /* @__PURE__ */ new WeakMap(), _PostMessageChannel_options = /* @__PURE__ */ new WeakMap(), _PostMessageChannel_closed = /* @__PURE__ */ new WeakMap();
const urlIsSecureContext = (value) => {
  try {
    const url = new URL(value);
    return url.protocol === "https:" || url.hostname === "127.0.0.1" || url.hostname.split(".").slice(-1)[0] === "localhost";
  } catch (_a2) {
    return false;
  }
};
var __classPrivateFieldSet$3 = function(receiver, state, value, kind, f2) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return state.set(receiver, value), value;
};
var __classPrivateFieldGet$3 = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _HeartbeatClient_instances, _HeartbeatClient_options, _HeartbeatClient_establish, _HeartbeatClient_maintain, _HeartbeatClient_receiveReadyResponse, _HeartbeatClient_sendStatusRequest;
class HeartbeatClient {
  constructor(options) {
    _HeartbeatClient_instances.add(this);
    _HeartbeatClient_options.set(this, void 0);
    __classPrivateFieldSet$3(this, _HeartbeatClient_options, Object.assign({ establishTimeout: 1e4, disconnectTimeout: 2e3, statusPollingRate: 300, window: globalThis.window, crypto: globalThis.crypto }, options));
    __classPrivateFieldGet$3(this, _HeartbeatClient_instances, "m", _HeartbeatClient_establish).call(this);
  }
}
_HeartbeatClient_options = /* @__PURE__ */ new WeakMap(), _HeartbeatClient_instances = /* @__PURE__ */ new WeakSet(), _HeartbeatClient_establish = function _HeartbeatClient_establish2() {
  const pending = [];
  const create2 = () => {
    const id = __classPrivateFieldGet$3(this, _HeartbeatClient_options, "f").crypto.randomUUID();
    pending.push(id);
    return id;
  };
  const listener = __classPrivateFieldGet$3(this, _HeartbeatClient_instances, "m", _HeartbeatClient_receiveReadyResponse).call(this, (response) => {
    if (pending.includes(response.data.id)) {
      listener();
      clearInterval(interval);
      clearTimeout(timeout);
      __classPrivateFieldGet$3(this, _HeartbeatClient_options, "f").onEstablish(response.origin);
      __classPrivateFieldGet$3(this, _HeartbeatClient_instances, "m", _HeartbeatClient_maintain).call(this, response.origin);
    }
  });
  const timeout = setTimeout(() => {
    listener();
    clearInterval(interval);
    __classPrivateFieldGet$3(this, _HeartbeatClient_options, "f").onEstablishTimeout();
  }, __classPrivateFieldGet$3(this, _HeartbeatClient_options, "f").establishTimeout);
  const interval = setInterval(() => __classPrivateFieldGet$3(this, _HeartbeatClient_instances, "m", _HeartbeatClient_sendStatusRequest).call(this, create2()), __classPrivateFieldGet$3(this, _HeartbeatClient_options, "f").statusPollingRate);
}, _HeartbeatClient_maintain = function _HeartbeatClient_maintain2(origin) {
  let interval;
  let timeout;
  let pending = [];
  const consume = (id) => {
    const index = pending.findIndex((entry) => entry.id === id);
    if (index > -1) {
      pending.splice(index, 1);
    }
    return index > -1;
  };
  const create2 = () => {
    const id = __classPrivateFieldGet$3(this, _HeartbeatClient_options, "f").crypto.randomUUID();
    const time = (/* @__PURE__ */ new Date()).getTime();
    pending = pending.filter((entry) => time - __classPrivateFieldGet$3(this, _HeartbeatClient_options, "f").disconnectTimeout > entry.time);
    pending.push({ id, time });
    return id;
  };
  const resetTimeout = () => {
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      listener();
      clearInterval(interval);
      __classPrivateFieldGet$3(this, _HeartbeatClient_options, "f").onDisconnect();
    }, __classPrivateFieldGet$3(this, _HeartbeatClient_options, "f").disconnectTimeout);
  };
  const listener = __classPrivateFieldGet$3(this, _HeartbeatClient_instances, "m", _HeartbeatClient_receiveReadyResponse).call(this, (response) => {
    if (response.origin === origin && consume(response.data.id)) {
      resetTimeout();
    }
  });
  resetTimeout();
  interval = setInterval(() => __classPrivateFieldGet$3(this, _HeartbeatClient_instances, "m", _HeartbeatClient_sendStatusRequest).call(this, create2()), __classPrivateFieldGet$3(this, _HeartbeatClient_options, "f").statusPollingRate);
}, _HeartbeatClient_receiveReadyResponse = function _HeartbeatClient_receiveReadyResponse2(handler) {
  const listener = (event) => {
    if (event.source === __classPrivateFieldGet$3(this, _HeartbeatClient_options, "f").signerWindow && isJsonRpcResponse(event.data) && "result" in event.data && event.data.result === "ready") {
      handler(event);
    }
  };
  __classPrivateFieldGet$3(this, _HeartbeatClient_options, "f").window.addEventListener("message", listener);
  return () => __classPrivateFieldGet$3(this, _HeartbeatClient_options, "f").window.removeEventListener("message", listener);
}, _HeartbeatClient_sendStatusRequest = function _HeartbeatClient_sendStatusRequest2(id) {
  __classPrivateFieldGet$3(this, _HeartbeatClient_options, "f").signerWindow.postMessage({ jsonrpc: "2.0", id, method: "icrc29_status" }, "*");
};
var __classPrivateFieldSet$2 = function(receiver, state, value, kind, f2) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return state.set(receiver, value), value;
};
var __classPrivateFieldGet$2 = function(receiver, state, kind, f2) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _PostMessageTransport_options;
const NON_CLICK_ESTABLISHMENT_LINK = "https://github.com/slide-computer/signer-js/blob/main/packages/signer-web/README.md#channels-must-be-established-in-a-click-handler";
class PostMessageTransportError extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, PostMessageTransportError.prototype);
  }
}
let withinClick = false;
if (globalThis.window) {
  globalThis.window.addEventListener("click", () => withinClick = true, true);
  globalThis.window.addEventListener("click", () => withinClick = false);
}
class PostMessageTransport {
  constructor(options) {
    _PostMessageTransport_options.set(this, void 0);
    if (!urlIsSecureContext(options.url)) {
      throw new PostMessageTransportError("Invalid signer RPC url");
    }
    __classPrivateFieldSet$2(this, _PostMessageTransport_options, Object.assign({ windowOpenerFeatures: "", window: globalThis.window, establishTimeout: 12e4, disconnectTimeout: 2e3, statusPollingRate: 300, crypto: globalThis.crypto, manageFocus: true, closeOnEstablishTimeout: true, detectNonClickEstablishment: true }, options));
  }
  async establishChannel() {
    if (__classPrivateFieldGet$2(this, _PostMessageTransport_options, "f").detectNonClickEstablishment && !withinClick) {
      throw new PostMessageTransportError(`Signer window should not be opened outside of click handler, see: ${NON_CLICK_ESTABLISHMENT_LINK}`);
    }
    const signerWindow = __classPrivateFieldGet$2(this, _PostMessageTransport_options, "f").window.open(__classPrivateFieldGet$2(this, _PostMessageTransport_options, "f").url, "signerWindow", __classPrivateFieldGet$2(this, _PostMessageTransport_options, "f").windowOpenerFeatures);
    if (!signerWindow) {
      throw new PostMessageTransportError("Signer window could not be opened");
    }
    return new Promise((resolve, reject) => {
      let channel;
      new HeartbeatClient(Object.assign(Object.assign({}, __classPrivateFieldGet$2(this, _PostMessageTransport_options, "f")), { signerWindow, onEstablish: (origin) => {
        channel = new PostMessageChannel(Object.assign(Object.assign({}, __classPrivateFieldGet$2(this, _PostMessageTransport_options, "f")), { signerOrigin: origin, signerWindow }));
        resolve(channel);
      }, onEstablishTimeout: () => {
        if (__classPrivateFieldGet$2(this, _PostMessageTransport_options, "f").closeOnEstablishTimeout) {
          signerWindow.close();
        }
        reject(new PostMessageTransportError("Communication channel could not be established within a reasonable time"));
      }, onDisconnect: () => channel.close() }));
    });
  }
}
_PostMessageTransport_options = /* @__PURE__ */ new WeakMap();
const decodeCallRequest = (contentMap) => {
  const decoded = Cbor.decode(contentMap);
  const expiry = new Expiry(0);
  expiry._value = BigInt(decoded.ingress_expiry.toString(10));
  return Object.assign(Object.assign({}, decoded), { canister_id: Principal.from(decoded.canister_id), ingress_expiry: expiry });
};
var __classPrivateFieldGet$1 = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var __classPrivateFieldSet$1 = function(receiver, state, value, kind, f2) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var _Queue_ongoing;
class Queue {
  constructor() {
    _Queue_ongoing.set(this, Promise.resolve());
  }
  async schedule(job) {
    return new Promise((resolve, reject) => {
      __classPrivateFieldSet$1(this, _Queue_ongoing, __classPrivateFieldGet$1(this, _Queue_ongoing, "f").finally(async () => {
        try {
          resolve(await job());
        } catch (error) {
          reject(error);
        }
      }), "f");
    });
  }
}
_Queue_ongoing = /* @__PURE__ */ new WeakMap();
var __classPrivateFieldGet = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var __classPrivateFieldSet = function(receiver, state, value, kind, f2) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var _SignerAgent_instances, _a, _SignerAgent_isInternalConstructing, _SignerAgent_options, _SignerAgent_certificates, _SignerAgent_queue, _SignerAgent_executeTimeout, _SignerAgent_scheduled, _SignerAgent_autoBatch, _SignerAgent_validation, _SignerAgent_executeQueue, _SignerAgent_executeBatch;
const ROOT_KEY = new Uint8Array(IC_ROOT_KEY.match(/[\da-f]{2}/gi).map((h2) => parseInt(h2, 16))).buffer;
const MAX_AGE_IN_MINUTES = 5;
const INVALID_RESPONSE_MESSAGE = "Received invalid response from signer";
class SignerAgentError extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, SignerAgentError.prototype);
  }
}
class SignerAgent {
  constructor(options) {
    _SignerAgent_instances.add(this);
    _SignerAgent_options.set(this, void 0);
    _SignerAgent_certificates.set(this, /* @__PURE__ */ new Map());
    _SignerAgent_queue.set(this, new Queue());
    _SignerAgent_executeTimeout.set(this, void 0);
    _SignerAgent_scheduled.set(this, [[]]);
    _SignerAgent_autoBatch.set(this, true);
    _SignerAgent_validation.set(this, void 0);
    const throwError = !__classPrivateFieldGet(_a, _a, "f", _SignerAgent_isInternalConstructing);
    __classPrivateFieldSet(_a, _a, false, "f", _SignerAgent_isInternalConstructing);
    if (throwError) {
      throw new SignerAgentError("SignerAgent is not constructable");
    }
    __classPrivateFieldSet(this, _SignerAgent_options, options, "f");
  }
  get rootKey() {
    var _b;
    return (_b = __classPrivateFieldGet(this, _SignerAgent_options, "f").agent.rootKey) !== null && _b !== void 0 ? _b : ROOT_KEY;
  }
  get signer() {
    return __classPrivateFieldGet(this, _SignerAgent_options, "f").signer;
  }
  static async create(options) {
    var _b, _c, _d;
    __classPrivateFieldSet(_a, _a, true, "f", _SignerAgent_isInternalConstructing);
    return new _a(Object.assign(Object.assign({}, options), { agent: (_b = options.agent) !== null && _b !== void 0 ? _b : await HttpAgent.create(), scheduleDelay: (_c = options.scheduleDelay) !== null && _c !== void 0 ? _c : 20, validation: (_d = options.validation) !== null && _d !== void 0 ? _d : null }));
  }
  static createSync(options) {
    var _b, _c, _d;
    __classPrivateFieldSet(_a, _a, true, "f", _SignerAgent_isInternalConstructing);
    return new _a(Object.assign(Object.assign({}, options), { agent: (_b = options.agent) !== null && _b !== void 0 ? _b : HttpAgent.createSync(), scheduleDelay: (_c = options.scheduleDelay) !== null && _c !== void 0 ? _c : 20, validation: (_d = options.validation) !== null && _d !== void 0 ? _d : null }));
  }
  async execute() {
    const scheduled = [...__classPrivateFieldGet(this, _SignerAgent_scheduled, "f")];
    const validation = __classPrivateFieldGet(this, _SignerAgent_validation, "f");
    this.clear();
    const pending = scheduled.flat().length;
    if (pending === 0) {
      __classPrivateFieldSet(this, _SignerAgent_validation, void 0, "f");
      return;
    }
    const needsBatch = pending > 1;
    if (!needsBatch) {
      await __classPrivateFieldGet(this, _SignerAgent_instances, "m", _SignerAgent_executeQueue).call(this, scheduled);
      return;
    }
    const supportedStandards = await __classPrivateFieldGet(this, _SignerAgent_queue, "f").schedule(() => this.signer.supportedStandards());
    const supportsBatch = supportedStandards.some((supportedStandard) => supportedStandard.name === "ICRC-112");
    if (supportsBatch) {
      await __classPrivateFieldGet(this, _SignerAgent_instances, "m", _SignerAgent_executeBatch).call(this, scheduled, validation);
    } else {
      await __classPrivateFieldGet(this, _SignerAgent_instances, "m", _SignerAgent_executeQueue).call(this, scheduled);
    }
  }
  async call(canisterId, options) {
    canisterId = Principal.from(canisterId);
    await __classPrivateFieldGet(this, _SignerAgent_options, "f").signer.openChannel();
    const response = await new Promise((resolve, reject) => {
      clearTimeout(__classPrivateFieldGet(this, _SignerAgent_executeTimeout, "f"));
      __classPrivateFieldGet(this, _SignerAgent_scheduled, "f").slice(-1)[0].push({
        options: {
          canisterId,
          method: options.methodName,
          arg: options.arg
        },
        resolve,
        reject
      });
      if (__classPrivateFieldGet(this, _SignerAgent_autoBatch, "f")) {
        __classPrivateFieldSet(this, _SignerAgent_executeTimeout, setTimeout(() => this.execute(), __classPrivateFieldGet(this, _SignerAgent_options, "f").scheduleDelay), "f");
      }
    });
    const requestBody = decodeCallRequest(response.contentMap);
    const contentMapMatchesRequest = SubmitRequestType.Call === requestBody.request_type && canisterId.compareTo(requestBody.canister_id) === "eq" && options.methodName === requestBody.method_name && compare$1(options.arg, requestBody.arg) === 0 && __classPrivateFieldGet(this, _SignerAgent_options, "f").account.compareTo(Principal.from(requestBody.sender)) === "eq";
    if (!contentMapMatchesRequest) {
      throw new SignerAgentError(INVALID_RESPONSE_MESSAGE);
    }
    const requestId = requestIdOf(requestBody);
    const certificate = await Certificate.create({
      certificate: response.certificate,
      rootKey: this.rootKey,
      canisterId,
      maxAgeInMinutes: MAX_AGE_IN_MINUTES
    }).catch(() => {
      throw new SignerAgentError(INVALID_RESPONSE_MESSAGE);
    });
    const certificateIsResponseToContentMap = certificate.lookup(["request_status", requestId, "status"]).status === LookupStatus.Found;
    if (!certificateIsResponseToContentMap) {
      throw new SignerAgentError(INVALID_RESPONSE_MESSAGE);
    }
    const requestKey = toBase64(requestId);
    if (__classPrivateFieldGet(this, _SignerAgent_certificates, "f").has(requestKey)) {
      throw new SignerAgentError(INVALID_RESPONSE_MESSAGE);
    }
    __classPrivateFieldGet(this, _SignerAgent_certificates, "f").set(requestKey, response.certificate);
    const now = Date.now();
    const lookupTime = lookupResultToBuffer(certificate.lookup(["time"]));
    if (!lookupTime) {
      throw new SignerAgentError(INVALID_RESPONSE_MESSAGE);
    }
    const certificateTime = Number(lebDecode(new PipeArrayBuffer(lookupTime))) / 1e6;
    const expiry = certificateTime - now + MAX_AGE_IN_MINUTES * 60 * 1e3;
    setTimeout(() => __classPrivateFieldGet(this, _SignerAgent_certificates, "f").delete(requestKey), expiry);
    return {
      requestId,
      response: {
        ok: true,
        status: 202,
        statusText: "Call has been sent over ICRC-25 JSON-RPC",
        body: null,
        headers: []
      }
    };
  }
  async fetchRootKey() {
    return __classPrivateFieldGet(this, _SignerAgent_options, "f").agent.fetchRootKey();
  }
  async getPrincipal() {
    return __classPrivateFieldGet(this, _SignerAgent_options, "f").account;
  }
  async query(canisterId, options) {
    canisterId = Principal.from(canisterId);
    const submitResponse = await this.call(canisterId, options);
    const readStateResponse = await this.readState(canisterId, {
      paths: [
        [new TextEncoder().encode("request_status"), submitResponse.requestId]
      ]
    });
    const certificate = await Certificate.create({
      certificate: readStateResponse.certificate,
      rootKey: this.rootKey,
      canisterId
    });
    const status = certificate.lookup([
      "request_status",
      submitResponse.requestId,
      "status"
    ]);
    const reply = certificate.lookup([
      "request_status",
      submitResponse.requestId,
      "reply"
    ]);
    if (status.status !== LookupStatus.Found || new TextDecoder().decode(status.value) !== "replied" || reply.status !== LookupStatus.Found) {
      throw new SignerAgentError("Certificate is missing reply");
    }
    return {
      requestId: submitResponse.requestId,
      status: "replied",
      reply: {
        arg: reply.value
      },
      httpDetails: {
        ok: true,
        status: 202,
        statusText: "Certificate with reply has been received over ICRC-25 JSON-RPC",
        headers: []
      }
    };
  }
  async createReadStateRequest(_options) {
    return {
      body: {
        content: {}
      }
    };
  }
  async readState(_canisterId, options, _identity, _request) {
    if (options.paths.length !== 1 || options.paths[0].length !== 2 || new TextDecoder().decode(options.paths[0][0]) !== "request_status") {
      throw new SignerAgentError("Given paths are not supported");
    }
    const requestId = options.paths[0][1];
    const key = toBase64(requestId);
    const certificate = __classPrivateFieldGet(this, _SignerAgent_certificates, "f").get(key);
    if (!certificate) {
      throw new SignerAgentError("Certificate could not be found");
    }
    return { certificate };
  }
  async status() {
    return __classPrivateFieldGet(this, _SignerAgent_options, "f").agent.status();
  }
  replaceAccount(account) {
    __classPrivateFieldGet(this, _SignerAgent_options, "f").account = account;
  }
  replaceValidation(validation) {
    __classPrivateFieldSet(this, _SignerAgent_validation, validation, "f");
  }
  /**
   * Enable manual triggering of canister calls execution
   */
  batch() {
    __classPrivateFieldSet(this, _SignerAgent_autoBatch, false, "f");
    if (__classPrivateFieldGet(this, _SignerAgent_scheduled, "f").slice(-1)[0].length > 0) {
      __classPrivateFieldGet(this, _SignerAgent_scheduled, "f").push([]);
    }
  }
  /**
   * Clear scheduled canister calls and switch back to automatic canister calls execution
   */
  clear() {
    __classPrivateFieldSet(this, _SignerAgent_scheduled, [[]], "f");
    __classPrivateFieldSet(this, _SignerAgent_autoBatch, true, "f");
  }
}
_a = SignerAgent, _SignerAgent_options = /* @__PURE__ */ new WeakMap(), _SignerAgent_certificates = /* @__PURE__ */ new WeakMap(), _SignerAgent_queue = /* @__PURE__ */ new WeakMap(), _SignerAgent_executeTimeout = /* @__PURE__ */ new WeakMap(), _SignerAgent_scheduled = /* @__PURE__ */ new WeakMap(), _SignerAgent_autoBatch = /* @__PURE__ */ new WeakMap(), _SignerAgent_validation = /* @__PURE__ */ new WeakMap(), _SignerAgent_instances = /* @__PURE__ */ new WeakSet(), _SignerAgent_executeQueue = async function _SignerAgent_executeQueue2(scheduled) {
  await Promise.all(scheduled.flat().map(({ options, resolve, reject }) => __classPrivateFieldGet(this, _SignerAgent_queue, "f").schedule(async () => {
    try {
      const response = await this.signer.callCanister(Object.assign({ sender: __classPrivateFieldGet(this, _SignerAgent_options, "f").account }, options));
      resolve(response);
    } catch (error) {
      reject(error);
    }
  })));
}, _SignerAgent_executeBatch = async function _SignerAgent_executeBatch2(scheduled, validation) {
  await __classPrivateFieldGet(this, _SignerAgent_queue, "f").schedule(async () => {
    try {
      const responses = await this.signer.batchCallCanister({
        sender: __classPrivateFieldGet(this, _SignerAgent_options, "f").account,
        requests: scheduled.map((entries) => entries.map(({ options }) => options)),
        validation: validation !== null && validation !== void 0 ? validation : void 0
      });
      scheduled.forEach((entries, sequenceIndex) => entries.forEach(({ resolve, reject }, requestIndex) => {
        const response = responses[sequenceIndex][requestIndex];
        if ("result" in response) {
          resolve(response.result);
          return;
        }
        if ("error" in response) {
          reject(new SignerAgentError(`${response.error.code}: ${response.error.message}
${JSON.stringify(response.error.data)}`));
          return;
        }
        reject(new SignerAgentError(INVALID_RESPONSE_MESSAGE));
      }));
    } catch (error) {
      scheduled.flat().forEach(({ reject }) => reject(error));
    }
  });
};
_SignerAgent_isInternalConstructing = { value: false };
class NFIDAdapter extends BaseAdapter {
  constructor(args) {
    super(args);
    this.identity = null;
    this.sessionKey = null;
    this.unwrapResponse = (response) => {
      if ("error" in response) {
        throw new SignerError(response.error);
      }
      if ("result" in response) {
        return response.result;
      }
      throw new SignerError({
        code: 500,
        message: "Invalid response"
      });
    };
    this.storage = new IdbStorage();
    const transportConfig = {
      ...this.adapter.config.transport
    };
    this.transport = new PostMessageTransport({
      url: this.adapter.config.signerUrl,
      ...transportConfig
    });
    this.signer = new Signer({
      transport: this.transport
    });
    const signerHttpAgent = HttpAgent.createSync({ host: this.adapter.config.hostUrl });
    this.signerAgent = SignerAgent.createSync({
      signer: this.signer,
      account: Principal.anonymous(),
      // Start anonymous
      agent: signerHttpAgent
    });
    this.agent = HttpAgent.createSync({ host: this.adapter.config.hostUrl });
    this.setState(Adapter.Status.READY);
    this.restoreFromStorage().catch((error) => {
      console.debug("[NFID] Failed to restore from storage on init:", error);
    });
  }
  async clearStoredSession() {
    this.identity = null;
    this.signerAgent = null;
    this.sessionKey = null;
    await removeIdentity("nfid", this.storage);
    await removeDelegationChain("nfid", this.storage);
    console.debug("[NFID] Cleared stored session data.");
  }
  async restoreFromStorage() {
    try {
      console.debug("[NFID] Attempting to restore from storage...");
      const storedSessionKey = await getIdentity("nfid", this.storage);
      const delegationChain = await getDelegationChain("nfid", this.storage);
      if (!storedSessionKey || !delegationChain) {
        console.debug("[NFID] No session key or delegation chain found in storage.");
        await this.clearStoredSession();
        return;
      }
      const expiration = delegationChain.delegations[0].delegation.expiration;
      if (expiration < BigInt(Date.now() * 1e6)) {
        console.debug("[NFID] Stored delegation chain has expired.");
        await this.clearStoredSession();
        return;
      }
      console.debug("[NFID] Found valid session key and delegation chain, restoring...");
      this.sessionKey = storedSessionKey;
      this.identity = DelegationIdentity.fromDelegation(
        this.sessionKey,
        delegationChain
      );
      this.signerAgent = SignerAgent.createSync({
        signer: this.signer,
        // Signer should be initialized in constructor
        account: this.identity.getPrincipal(),
        agent: HttpAgent.createSync({ host: this.adapter.config.hostUrl })
      });
      console.debug("[NFID] Successfully restored connection.");
      this.setState(Adapter.Status.CONNECTED);
    } catch (error) {
      console.error("[NFID] Error restoring from storage:", error);
      await this.clearStoredSession();
    }
  }
  async openChannel() {
    if (this.signer) {
      await this.signer.openChannel();
    }
  }
  async isConnected() {
    return this.identity !== null && this.state === Adapter.Status.CONNECTED;
  }
  async getPrincipal() {
    if (!this.identity) {
      throw new Error("NFID Adapter: Not connected. Call connect() first.");
    }
    return this.identity.getPrincipal().toText();
  }
  async connect() {
    if (this.identity && this.state === Adapter.Status.CONNECTED) {
      return createAccountFromPrincipal(this.identity.getPrincipal());
    }
    if (!this.identity) {
      try {
        await this.restoreFromStorage();
        if (this.identity && this.state === Adapter.Status.CONNECTED) {
          console.debug("[NFID] Connection restored from storage during connect call.");
          return createAccountFromPrincipal(this.identity.getPrincipal());
        }
      } catch (error) {
        console.debug("[NFID] Failed to restore from storage during connect call:", error);
      }
    }
    if (this.identity && this.state === Adapter.Status.CONNECTED) {
      return createAccountFromPrincipal(this.identity.getPrincipal());
    }
    this.setState(Adapter.Status.CONNECTING);
    if (!this.signer || !this.transport || !this.agent) {
      this.setState(Adapter.Status.ERROR);
      throw new Error("NFID Adapter not initialized correctly.");
    }
    try {
      console.debug("[NFID] Opening channel...");
      await this.signer.openChannel();
      this.sessionKey = Ed25519KeyIdentity.generate();
      console.debug("[NFID] Generated new session key for delegation request.");
      const maxTimeToLiveNs = this.adapter.config.delegationTimeout !== void 0 ? BigInt(Date.now() * 1e6) + BigInt(this.adapter.config.delegationTimeout) : BigInt(Date.now() * 1e6) + BigInt(48 * 60 * 60 * 1e9);
      console.debug("[NFID] Requesting delegation...");
      const delegationChain = await this.signer.delegation({
        publicKey: this.sessionKey.getPublicKey().toDer(),
        targets: Array.isArray(this.adapter.config.delegationTargets) ? this.adapter.config.delegationTargets.filter((target) => typeof target === "string" && target.length > 0).map((target) => Principal.fromText(target)) : [],
        maxTimeToLive: maxTimeToLiveNs
      });
      console.debug("[NFID] Storing session key and delegation chain...");
      await setIdentity("nfid", this.sessionKey, this.storage);
      await setDelegationChain("nfid", delegationChain, this.storage);
      const delegationIdentity = DelegationIdentity.fromDelegation(
        this.sessionKey,
        delegationChain
      );
      this.signerAgent = SignerAgent.createSync({
        signer: this.signer,
        account: delegationIdentity.getPrincipal(),
        agent: HttpAgent.createSync({ host: this.adapter.config.hostUrl })
      });
      this.identity = delegationIdentity;
      if (this.adapter.config.fetchRootKey) {
        await fetchRootKeyIfNeeded(this.agent, true);
      }
      const principal = delegationIdentity.getPrincipal();
      if (isPrincipalAnonymous(principal)) {
        this.setState(Adapter.Status.READY);
        await this.clearStoredSession();
        throw new Error(
          "Failed to authenticate with NFID - got anonymous principal"
        );
      }
      console.debug("[NFID] Successfully connected and session stored.");
      this.setState(Adapter.Status.CONNECTED);
      return createAccountFromPrincipal(principal);
    } catch (error) {
      console.error("[NFID] Connection failed:", error);
      await this.clearStoredSession();
      if (this.signer) {
        try {
          this.signer.closeChannel();
        } catch (e3) {
          console.debug("[NFID] Error closing channel on connect failure:", e3);
        }
      }
      this.setState(Adapter.Status.READY);
      throw error;
    }
  }
  undelegatedActor(canisterId, idlFactory2) {
    const agent = HttpAgent.createSync({
      identity: this.identity,
      host: this.adapter.config.hostUrl,
      verifyQuerySignatures: this.adapter.config.verifyQuerySignatures
    });
    const actor = Actor.createActor(idlFactory2, {
      agent,
      canisterId
    });
    return actor;
  }
  // Implementation for BaseIcAdapter actor caching
  createActorInternal(canisterId, idlFactory2, options) {
    const requiresSigning = options?.requiresSigning !== false;
    if (!this.identity) {
      throw new Error("Not connected. Identity not available.");
    }
    if (!this.signerAgent && requiresSigning) {
      throw new Error("Signer agent not available. Please connect first.");
    }
    if (!this.adapter.config.hostUrl) {
      throw new Error("Host URL configuration is missing.");
    }
    try {
      const inTargets = this.identity.getDelegation().delegations.some(
        (d2) => d2.delegation.targets?.some((p) => p.toText() === canisterId)
      );
      if (inTargets && !requiresSigning || !inTargets && !requiresSigning) {
        return this.undelegatedActor(canisterId, idlFactory2);
      }
      if (requiresSigning) {
        return Actor.createActor(idlFactory2, {
          agent: this.signerAgent,
          canisterId
        });
      }
      return Actor.createActor(idlFactory2, {
        agent: this.signerAgent,
        canisterId
      });
    } catch (error) {
      console.error("Error creating actor:", error);
      throw new Error(
        `Failed to create actor: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }
  // disconnect is handled by BaseIcAdapter, implement internal methods instead
  async disconnectInternal() {
    console.debug("[NFID] Disconnecting internally...");
    await this.clearStoredSession();
    try {
      if (this.signer) {
        this.signer.closeChannel();
      }
    } catch (error) {
      console.error("[NFID] Error during disconnect internal cleanup:", error);
    }
  }
  cleanupInternal() {
    console.debug("[NFID] Performing final cleanup (transport/signer are re-created on new instance).");
  }
}
const _OisyAdapter = class _OisyAdapter extends BaseAdapter {
  constructor(args) {
    super(args);
    this.signer = null;
    this.agent = null;
    this.signerAgent = null;
    this.transport = null;
    const signerUrl = this.adapter.config.signerUrl ?? "https://oisy.com/sign";
    this.agent = HttpAgent.createSync({ host: this.adapter.config.hostUrl });
    const transportConfig = {
      ...this.adapter.config.transport
    };
    this.transport = new PostMessageTransport({
      url: signerUrl,
      ...transportConfig
    });
    this.signer = new Signer({
      transport: this.transport
    });
    this.signerAgent = SignerAgent.createSync({
      signer: this.signer,
      account: Principal.anonymous(),
      agent: this.agent
    });
  }
  async openChannel() {
    if (this.signer) {
      await this.signer.openChannel();
    }
  }
  async isConnected() {
    return this.agent !== null && this.signer !== null && this.signerAgent !== null;
  }
  async getPrincipal() {
    if (!this.signerAgent) {
      if (this.transport && this.signer && this.adapter.config.hostUrl) {
        this.agent = HttpAgent.createSync({ host: this.adapter.config.hostUrl });
        this.signerAgent = SignerAgent.createSync({
          signer: this.signer,
          account: Principal.anonymous(),
          agent: this.agent
        });
      } else {
        throw new Error("Oisy signer agent not initialized or connected");
      }
    }
    const principal = await this.signerAgent.getPrincipal();
    return principal.toText();
  }
  // Override the base class method with a specific implementation
  async getAccountId() {
    const principal = await this.getPrincipal();
    return deriveAccountId(principal);
  }
  async connect() {
    this.setState(Adapter.Status.CONNECTING);
    try {
      if (!this.signerAgent && this.transport && this.signer && this.adapter.config.hostUrl) {
        this.agent = HttpAgent.createSync({ host: this.adapter.config.hostUrl });
        this.signerAgent = SignerAgent.createSync({
          signer: this.signer,
          account: Principal.anonymous(),
          agent: this.agent
        });
      } else if (!this.signerAgent || !this.signerAgent.signer) {
        throw new Error("Oisy signer agent not initialized. Was the constructor called with config?");
      }
      let principal;
      const storedPrincipal = localStorage.getItem(_OisyAdapter.OISY_PRINCIPAL_KEY);
      if (storedPrincipal && isValidPrincipal(storedPrincipal)) {
        try {
          principal = Principal.fromText(storedPrincipal);
          this.signerAgent.replaceAccount(principal);
        } catch (e3) {
          localStorage.removeItem(_OisyAdapter.OISY_PRINCIPAL_KEY);
          const accounts = await this.signerAgent.signer.accounts();
          if (!accounts || accounts.length === 0) {
            await this.disconnect();
            throw new Error("No accounts returned from Oisy");
          }
          principal = accounts[0].owner;
          localStorage.setItem(_OisyAdapter.OISY_PRINCIPAL_KEY, principal.toText());
          this.signerAgent.replaceAccount(principal);
        }
      } else {
        const accounts = await withRetry(() => this.signerAgent.signer.accounts());
        if (!accounts || accounts.length === 0) {
          await this.disconnect();
          throw new Error("No accounts returned from Oisy");
        }
        principal = accounts[0].owner;
        localStorage.setItem(_OisyAdapter.OISY_PRINCIPAL_KEY, principal.toText());
        this.signerAgent.replaceAccount(principal);
      }
      if (principal.isAnonymous()) {
        this.setState(Adapter.Status.READY);
        throw new Error(
          "Failed to authenticate with Oisy - got anonymous principal"
        );
      }
      if (this.adapter.config.fetchRootKey) {
        if (!this.signerAgent) throw new Error("Signer agent not ready for fetchRootKey");
        await this.signerAgent.fetchRootKey();
      }
      this.setState(Adapter.Status.CONNECTED);
      return createAccountFromPrincipal(principal);
    } catch (error) {
      console.error("[Oisy] Connection error:", error);
      await this.disconnect();
      throw error;
    }
  }
  // Use BaseIcAdapter's actor caching by implementing createActorInternal
  createActorInternal(canisterId, idlFactory2) {
    if (!this.signerAgent) {
      throw new Error("No signer agent available. Please connect first.");
    }
    try {
      const agentToUse = this.signerAgent;
      return Actor.createActor(idlFactory2, {
        agent: agentToUse,
        canisterId
      });
    } catch (error) {
      console.error("[Oisy] Actor creation error:", error);
      throw error;
    }
  }
  async disconnectInternal() {
    if (this.signer) {
      try {
        this.signer.closeChannel();
      } catch (error) {
        console.warn("[Oisy] Error closing signer channel:", error);
      }
    }
    localStorage.removeItem(_OisyAdapter.OISY_PRINCIPAL_KEY);
  }
  cleanupInternal() {
    this.agent = null;
    this.signerAgent = null;
  }
};
_OisyAdapter.OISY_PRINCIPAL_KEY = "oisy_principal";
let OisyAdapter = _OisyAdapter;
const phantomLogo = "data:image/webp;base64,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";
const solflareLogo = "data:image/svg+xml,%3csvg%20width='290'%20height='290'%20viewBox='0%200%20290%20290'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20clip-path='url(%23clip0_146_299)'%3e%3cpath%20d='M63.2951%201H226.705C261.11%201%20289%2028.8905%20289%2063.2951V226.705C289%20261.11%20261.11%20289%20226.705%20289H63.2951C28.8905%20289%201%20261.11%201%20226.705V63.2951C1%2028.8905%2028.8905%201%2063.2951%201Z'%20fill='%23FFEF46'%20stroke='%23EEDA0F'%20stroke-width='2'/%3e%3cpath%20d='M140.548%20153.231L154.832%20139.432L181.462%20148.147C198.893%20153.958%20207.609%20164.61%20207.609%20179.62C207.609%20190.999%20203.251%20198.504%20194.536%20208.188L191.873%20211.093L192.841%20204.314C196.714%20179.62%20189.452%20168.968%20165.484%20161.22L140.548%20153.231ZM104.717%2068.739L177.347%2092.9488L161.61%20107.959L123.843%2095.3698C110.77%2091.012%20106.412%2083.9911%20104.717%2069.2232V68.739ZM100.359%20191.725L116.822%20175.988L147.811%20186.157C164.031%20191.483%20169.599%20198.504%20167.905%20216.177L100.359%20191.725ZM79.539%20121.516C79.539%20116.917%2081.9599%20112.559%2086.0756%20108.927C90.4334%20115.222%2097.9384%20120.79%20109.801%20124.664L135.464%20133.137L121.18%20146.937L96.0016%20138.705C84.3809%20134.832%2079.539%20129.021%2079.539%20121.516ZM155.558%20248.618C208.819%20213.272%20237.387%20189.304%20237.387%20159.768C237.387%20140.158%20225.766%20129.263%20200.104%20120.79L180.736%20114.253L233.756%2063.4128L223.103%2052.0342L207.367%2065.8337L133.043%2041.3818C110.043%2048.8869%2080.9916%2070.9178%2080.9916%2092.9487C80.9916%2095.3697%2081.2337%2097.7907%2081.96%20100.454C62.8342%20111.348%2055.0871%20121.516%2055.0871%20134.105C55.0871%20145.968%2061.3816%20157.831%2081.4758%20164.368L97.4542%20169.694L42.2559%20222.713L52.9082%20234.092L70.0972%20218.356L155.558%20248.618Z'%20fill='%2302050A'/%3e%3c/g%3e%3cdefs%3e%3cclipPath%20id='clip0_146_299'%3e%3crect%20width='290'%20height='290'%20fill='white'/%3e%3c/clipPath%3e%3c/defs%3e%3c/svg%3e";
const backpackLogo = "data:image/webp;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAYAAAD0eNT6AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAACAKADAAQAAAABAAACAAAAAAAL+LWFAAAo9UlEQVR4Ae3dPYwc57Um4CJFUSQ1l7B9fS9oYEMqp3I6p3Iau+EIdmjDDm3YoQ0xtGGFuxDDXYi5GO5CzMVczE34+loy74j/MrdOUz2sqen5pn+q+uc7TwGDqe7qqq7znJqpt6uqu8+8aofGQIAAAQIECKQSOJuqWsUSIECAAAECEwEBwIZAgAABAgQSCggACZuuZAIECBAgIADYBggQIECAQEIBASBh05VMgAABAgQEANsAAQIECBBIKCAAJGy6kgkQIECAgABgGyBAgAABAgkFBICETVcyAQIECBAQAGwDBAgQIEAgoYAAkLDpSiZAgAABAgKAbYAAAQIECCQUEAASNl3JBAgQIEBAALANECBAgACBhAICQMKmK5kAAQIECAgAtgECBAgQIJBQQABI2HQlEyBAgAABAcA2QIAAAQIEEgoIAAmbrmQCBAgQICAA2AYIECBAgEBCAQEgYdOVTIAAAQIEBADbAAECBAgQSCggACRsupIJECBAgIAAYBsgQIAAAQIJBQSAhE1XMgECBAgQEABsAwQIECBAIKGAAJCw6UomQIAAAQICgG2AAAECBAgkFBAAEjZdyQQIECBAQACwDRAgQIAAgYQCAkDCpiuZAAECBAgIALYBAgQIECCQUEAASNh0JRMgQIAAAQHANkCAAAECBBIKCAAJm65kAgQIECAgANgGCBAgQIBAQgEBIGHTlUyAAAECBAQA2wABAgQIEEgoIAAkbLqSCRAgQICAAGAbIECAAAECCQUEgIRNVzIBAgQIEBAAbAMECBAgQCChgACQsOlKJkCAAAECAoBtgAABAgQIJBQQABI2XckECBAgQEAAsA0QIECAAIGEAgJAwqYrmQABAgQICAC2AQIECBAgkFBAAEjYdCUTIECAAAEBwDZAgAABAgQSCggACZuuZAIECBAgIADYBggQIECAQEIBASBh05VMgAABAgQEANsAAQIECBBIKCAAJGy6kgkQIECAgABgGyBAgAABAgkFBICETVcyAQIECBAQAGwDBAgQ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";
const walletconnectLogo = "data:image/webp;base64,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";
const oisyLogo = "data:image/webp;base64,UklGRgIcAABXRUJQVlA4WAoAAAAwAAAA/wAA/wAASUNDUMgBAAAAAAHIAAAAAAQwAABtbnRyUkdCIFhZWiAH4AABAAEAAAAAAABhY3NwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAA9tYAAQAAAADTLQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlkZXNjAAAA8AAAACRyWFlaAAABFAAAABRnWFlaAAABKAAAABRiWFlaAAABPAAAABR3dHB0AAABUAAAABRyVFJDAAABZAAAAChnVFJDAAABZAAAAChiVFJDAAABZAAAAChjcHJ0AAABjAAAADxtbHVjAAAAAAAAAAEAAAAMZW5VUwAAAAgAAAAcAHMAUgBHAEJYWVogAAAAAAAAb6IAADj1AAADkFhZWiAAAAAAAABimQAAt4UAABjaWFlaIAAAAAAAACSgAAAPhAAAts9YWVogAAAAAAAA9tYAAQAAAADTLXBhcmEAAAAAAAQAAAACZmYAAPKnAAANWQAAE9AAAApbAAAAAAAAAABtbHVjAAAAAAAAAAEAAAAMZW5VUwAAACAAAAAcAEcAbwBvAGcAbABlACAASQBuAGMALgAgADIAMAAxADZBTFBI1ggAAA3wxmz/+7T9/12MZoANuKZ2McjZhlBmFqqIoMQqBidoZCedljqQqPZuya1076IgZUnuyB4MUYaJXAJqBmSwKbhAUjMcm41Ndpz3YNgvv17PR29GxARAcENDQ+SyYKkkSCz2mz9njjecd+/eumm3j40OD9mslv5+kFW+dOmSRQuVPpi195w58/3E4iCJNFgmDwl9YL5+rbury0oLRXRUZGQQOKpULly0ZKl0rL29tWWABBEr4+Nk4L4kPDIySmFrbLjSwXQhTyasEcODpXFx8RH2+roLFjaLTUxcDB70X70mQdFz7lwTa61ISQ4Efy5ITIwar6m+yk4RarUEfBuYlLxy1GjsYCFRmkYJfg5Qq5eZDZUOxonVJoHPlakaUW15E8OkZyjB+2u1MebSCjYRZWXOhSCGZaTfKSl2MEfwRg2E0zcr089QOMQUj215CgKbukly9uQgMwRsU0OAUzZLjccn2GDnegj0uu3+ZUcYQPOsN4R7ww7nIYPARb8gg7A/m2r7pUXARLpVEHzZczGX9Q6hStsKJozXiU5UClLYS2FgxS2avoN9wpOpBUOGvqQoLxGYx3NCwJbaTMveG0LydDaYU54jLzojGN6vqcCi2WrTHqcwhOeCUVW5XgWdQpCeBnbNVVVW8F9OOFhWk9a5l+cefdsfbBueM/n9CJ89oQPzzntHom/jr+T1YGHd8rIavtqYADbWJtcV8pNOBVZOyDLp+ej1ELCzSmfJ558PxWBp+ev2L3nGe5cv2Fr0wf3dTj55JA/M7Zvn9ek9/njkY7B4ns/n9/jCOw9s/onPp06e2AVWz/PazQ8f+jIb8u5/yQevi8Huvh/Y8z1PFwKWF71u0XvaRhXYXq4zFXpWcgJYX5VVV+NJT6wH+yckl7V5zqM6UFC7XD/iMW+DhjrJ956S408EvDO51zPSw0HFeTmdFZ4QngY6hqdVdnLPOxeU1KgKnJx7DbTM9drDtadVxECu6Qy3Hs8GNVXqohucygE9s+V7uZQZQhDkWEq4E6YFReWZ5X2ceQk01SoOciUtjCh4qa+SG6KtoGqo5oSDEzrQdYtIz4XoVYSB7nILB14AZeNjfnGfRkYaPGczuO1Z0FaWeshdO72Jg2edR9wTsB7k3VE24ZZtoO8G/+PueExNIGw3DrphCyi8TnrSdcFPkQibzw65bCNonCIpdJVIQyRsMjhclAUqp/oVuyiTTMgscU36XDpl3alwSQbo7Jte6opYJaGQYW5ygRaUDospn50oiVTQ1jpmlQZarxVVzkpDLGgMs4lQUivV3DELNaitXGYkHtSzWCEh2OjVGaWA3gErq2eUTDAk18wkNpBiSeNNM0gExQOjzhEPiTMIWUy0Hss0T4LmCxQXpkkgGhLqpllDtTX1U0WIqbba3jHFSlDdP+LKFPFkQ3zDFHF0i2v8P4WMcLYBANGgu1TRAiCKcIhqBRBJucj2fwPkQZQLH7NiKSgvkXYRD0u7sIR2S7qxiHaLrmEh7RZeh5J2SnOoD/EehIL4oSHUC5FTTy6jniyYesFS6kkl1JMEUS9ITD0x/fyo5zefevPnUG8O/byp5w3yO72J57w7h3h36XdrPvFu3fQj3k27mHh2+o0FEW9sVEK80WEp8YaHgok3ZJMRz2aVE89qCSGepT+UeP39D5SkMwNm8l1fSLrrwLVFpLsGdC8hXTfQtZR0XUCXVEK40WHAOhZOuE4AaI8kXPu/A61RhGv9vxaFlGzDA/83YIsjWyOmbCRfQzzZGqa6EuFPtMmOqTrsq4l2CdPWryFa/XR1CUSrm+6CYgHJ/hmYztKTSLJzmOE5+kUFEmy8dSZN40kEq8WMa5IJVjOz6pUB5Jq4MrOro2pyGTFLI/2WKYll/ns2HeZUYlVh1gYNsQyzqxStJdWfjtk5arWkKocLy2PCCNXX7IomcwahSuHS0nRfMt2vcE3FnSwyFcPFJZlkKnFVsV8qkapuusph2ESk03B5oSSFRNWjrhs6u5lEp+DGk9J1BPpj2B2Dxu0EOga3HvffQJ7fJ90zUbaDPEfh5iPOZ4lzCG4/lCojja3KfQbbc6T5DRz8JSaeMA3NXGi5rCOMHpzUi7aQ5aSDG44TmlCi9BvA0cq+l4hyEJw9qNCSpHyAO33lmXKCWEvA4RJLDkH2gtN75dnkKLJy60aRWkUMkxEcP2PKJUYBOL/HK5cUBQ+55yxQaQhhMMEDOyvTwsnQWQmPrOjMmUeE23vhoXsn3yHCd/DY7yU6EuhHPWdEv1xLgPK/4MFtZckJzFdXA4+uqctSMZ6pGB5eaNLJmc6qh8frLa+LGM6RDx7Mt3/ow2z3vwIvfnlvF7N9Cp7c7ZXHaJ8+5Avnpz6fMNlnD8Cb9z73yWOwTx+AR+996pXny1j3P30IXnXuvv+BiKkcX4F3v7S/Lmcoaz54ON+iUzGTSQ9e1puyEhiprhg8XViXrGWi8hrwdk3Zch0D6f8Cj7fpJe/MY5zb342C10e+n8wJZ5rOveD9vZ1pGoYxVEIAKypVucxSYIIgdhZ45aqYxFTwEALp3GNSZzNIkRECeqZIniNnDOteKwT1xl5LppYpyksguCXlipdCmaH/4AAEuO9gn2YLI5w0QKArT4h08QzQoHdAsB36yzHPyQTO9lszBL3lF1vqs4J2qAqCbzjk3LFBsH4/CiY8Uua/fZ0g/XFsEow4cdwo3ZwiONWnhsGQgyfPSjalCkrV6VEw5lChwS8zy1cg7heX3ASDOopL7qRnhAlAX2kFmLWi1ByjXctzf5Y3g2mbymtFmlQlb5mrDA4wr6PSYF6mVgfw0ITR+DcYucNoHF2ZnBTIK+O1NVfA1Fera8ajEhMX8MQ/5861gsGbzp3rUSSsWe3vYZOX6usGwOyWC3X19oj4uDiphww3NjZ0gPk7rjQ02hRRkZHhEk6Ndra3tw6AjAMtre3tY9KlSxYtVCrdZjZfv9bdNQyCWru6uq9dNz8IDZHLgqWSILHYb/6cOd5w3r1766bdPjY6PGSzWvohuFZQOCA2EQAA0EoAnQEqAAEAAT5tMpNHJCMhoSzyqYCADYlkbvx8eyL+d5IZoF4A/QB+gH6AeIB9ACa3gD+e/lp+//ltU/5x/a/2C/t37W9NhuL3p/Jr4x+IcfX1E9p/2P94/uf7JfN/+wfxr2Afwn+6/7P+o/AB+mn+v/vH+G/aT4jPUH5gP6d/gv/P/gvew/t3/A/s3uN/sP+Z/T74AP6l/mf/V6yPsG+gB/QP8J/4fXE/cv4Kv20/dH3PP89///+P7gH//9QD9/+x36Z/2P8e+//+35DiBL9vMYLId4z5Kt3bABui8cveN0APzZ6sH994x/rH2BvLA9gvo0nUExCHYEUceSTa+nFYudkCYp6yxyDf13nj9qmt7DAwBpMaRrC1IlQzq7zx+l49h1d3deFgw1qTXNjz6GvY3CLwovEjaHW6ENga9gW0fh7+0dV86Xc8GkG6N/1gRW7QArUF5WorCsiORsBlfdTi+XYQ+xjmqKFdrd2BlFJ6UFr0/Sqd72n3rqzYzE9X1nCqWry1bsn+b9hko5WFGZDuMXEuPtqcMcPlTJuyc93muyYEirxlRS5kBuPcwMxy9dmU+1BbJhp08PGw/iytDAvrfIJfvQDgReQWP0OtUa1uVMF6Sfb9ufCjcKBtR1LXv9pT75uGxpcG3zPd+Pbv0OgKIE1af7xZI/ic142uGbfVMSU3T/ZAOoW8rrOXrHnWGBphT8dE4kCGxgSA19BaOyzomvLLpX66QLLtGAeegtskYVqIj2VoDrxHq821AbJaBY7T578CVNRbsMOVg/71UNGiDUtFqAOJjFHD9eOhKAD+P6qAw8PC4j58hgWGNhIFKkB7Fc+Td3Ia8d35zmjFn4ajhI8aiCF8nM96Ti3qz1Xg3LVowPyJYsmvjQ0iOFdwKOWLh3shkJTl4Liqk56hFUnPLpJpDSVoHP/x9s9qWiRQIptj5Xro0pJV+Lzp7Ko3iZrLuHvC2vVoORQk6uR2JgugeTPrq3ouewQQLjmOipukAZMhUIwq3vkfPkMCwxsI8AW8i2MIJeXjguh6ckC9gP0UuCrgYqsF/YmwjS/oMk5a7Z0ry3hNPGYjZnIEjRSNp2E18dUAAAAO/SB1/DrQl4O7JgnVEqzf2qBYlhIXiu9iRNLgZswLEfMFQrzha5IT7m2m03ebtyVae4Xqh+Zm/SkDxplVSAel+rnOZKI13/Vg9aWpXTubEUwe/iroTZStPxE9sAATbfjYCfOIdRnUE5n11eWQ9knu4okbIZ4UoLEw9QPTRsKQQu8y3u+1nFakhq54LvRpEBuVyP4O7ROlAQA2k8fEDQF+hvNTQYfFBdw/cmkW9r/zV+Tz1x4Xxfm9HqG3JYmRwVIe7l1y6hg/DQEfJF1O1t+Xdtjqo7EbM5AkeI94Fhz9fxrt25i7dQa4Wnxttn5y1ETT+Tj5P8YP1r+ELVWjLxbdHz1IlWNfBLqA8zoewZLroirXRFtufI+qDTEw7bkBJUXBxQSWEHOu8Dpj6DXJ31Jes9841cKxZ+svAlEjGq0cN2Q45SvVWxXmnzY/+XmWViEN+zaXG9SoZzNYGX3JpXf50JRzzMSKtaQI8QsMft27D/aKQuyA+gWUi58U25ns1KyYnEegTLodyZ8mUz6gkJV0+7qAk5GcejdZVIEIDPfQpbaYOSE5N4cPWDcVOLXnJA8LIdkn+AIOIwNJixShDxbXB0s4YUZIuuIZfMhXa99CymHgsG8FBHV4+4BmzNFiUek/5UhltHISj8LGhIs4OCryqGIGmxqGDg9ObSJEjWI18F9MNBWws2qGtLImibyhbiWQ0l8cMImLe2tqquTqxTIwqxOJwemnff6VvjQ5L0eO7lCnTLGYCiC4G7AfW+xK99+oDU9/ragrWLxLFrBxFUVsUvf+5qxBf2zwv2hTutCen+Jvlix3EI6O6HpqtSFwClVlicza3f9UfDWLvlvOJ69AvnxGIjj9eP+CyKyfQ8Q2K3UxjVSXu6pC1/c/YUo7FREhdFJp8Sjhy8IbQeCAJuwFGqZd1CMadHRk1TeRHSrJTth+mA9saqRef7f0Gbe3EnCOiUXfuVQ34gRDLKHtv/lVuCvZk3ehe4zF86mq9b5cBDDuvFhtd4hmGub+98/kmykpSw2GV8S1ApLnJvLASo+ZEdHpPXejDzBuqN0T8R9/lseTipwFgdAXyhJ3bccCoivLmFCbPyn32v5AjLKIoehA2pNg0Fve/3bduEiE1sSlozbz6zc6+cmdH4v+F5T2rYXOGoYEUHiYsT/VucSS3WrE/Nc0US6Qa6Atn4M0LPAJgW/bBY7d55XVKHL1eBvpMVHoKEMT6Qg/X2nTApE9UXV5V2a6+xmBT89lDWQrjox4bhhFr6eT5fMN5k/4+28oBNEpyaajDYTmoSezbpjuf5FmM72QqH54nPybYAgJPr7o8Nik/co0v6NWF7HmZ9EnZB67uVPUg5tvju9nw1EhEmdnaFEB9DJ7XkSLFfJ4RifkXhfWKKZAC5nPKnPPJLTuYISCVPShXG/6I0mVP4Q0Z+tXXUV0caUlSNaib3uAH+gjutMAMKf17uyDSGyyYnyj2Mlr5aklr/fXGtmm99NqpCGBNGB7d73IVacg5qBFogHGX+Ri3FH32Ena+iHbJ++xJ0owRtKdeyQpi2YoiHs9JJmRbGxKMK7L4hK0D0s4wU27wGV5ub6IhX+qb0a/1k51pFb1BJwemJeequZjdOmAx5SYANWwYmEZ3d2anG8F1k7Wn5jzDrqvC/ueFWrhue8t2J2SENLHV+IT3hSK7aJTZiDCpFTZwZ6pHVnr9UKg5y9ZiAtQfNRy9a/LPH63/0GaYvROnErfcTKT/klg2lv+UXz3erlzYwVbxSErtURg4EsGVELmtxDig4nJY1+LvG6oq6Xg2c0usyS8sys0BSiHo8HyARsbcsG64oP/DFGLqWPQXQocmWVatBaW/zywISPAcObpzQ64cmTVY5MXuDMNs44T1d5+bUAABPaGSHtwKcN79v26/tMzUfU1bJhRChGW+pBqBCPzGaKq6DpdLLOehfbeceH92qf5IxP9japUFIjpJ1Em7vQfXnSca43hv8bvSvYDUoCzdwvgtR6zmLXnsNWjB3iynrxsJYSSmN/LhBKNtkXVMdJMzp20Hs+ZAVpcooduMTodnsBQ/iIOf+DHobynOmKa+KEbtV6RmN6DUJOvkz/7B9AaQWcNnZubQoGl3C2DMjvMZfXkv8kh67SUHww4WKgoRWDfZ2jwDV2BXNa3hUmdUtXbIii9VosQUAEfmWcLTVUtuSPjgRwIdFFC1u38S6y3MaYg7+y3+jRcZ1AKjveSK99Rmxk6wZxxPev1MnNSOnS7iN6uA8osd+jDJiZCGPB0vk9BU72dIvkZyBBTnrVspA9HhrKKcnzq+HJx+DT42JNOIIrd/dTqDoNb54fwwSwG1RcFWcwJUk96+Ziv24NAwIjB/lU2mtRCseBj+kWamtAGgtFVmnWnBU07TnA3g2eiXNQ+yHuJcLzpcA2jPrqZzSut9u2jBGN+Ph3v2O+LbDRHcaglzFcG5QJP8fGdXBGGi6viw1IdjIfhNUHXH+B4QRCd5nBatb9CWCPMgCe/uIK28JivUn2kIVLkzjAwMsYcmjvYjQwGFgu6XaR2z5xjTGCSQZAtdPthMkDkdcj745U4FuhZUymyhkhZhVE44po0IDO9/KAbCn1yZIoO2tgIpRbarIuij9WiHdizPQ9DptZ17kHPny37fxOvsW5C11lAD69xL4IwSiUrYSldTk/iQOQfAW3/P6F/8p0nlWUkLYdqbhaLPQj6S3dWG2cbO7FNY6ipkJIt1Emx/SQfRmE2gdOzhHyn/RVSMdJ7jTKhPfzgpCOIIZPpL8jXq5iGGJ6DlLRPZJHqH9+ZA9PMlTGU1jHHQR7zH6hPYG80T9NdNz5PnLftY7tWdaVBtRYX9Uw3jTlc1d2oXYdTT6fJJ9MjWSszpxpt+eD7Hm8QNo6HD5CtB3q8rvROtQ1Lnq2H3h6tbXiWyijc0QytOWpk13nX1GJ/LmTvcFhlp58ZrxVo9d0Aa9bsbc2q6b+nSvo34PvzUW2Q6q+n5V3l6WMzoOGk8lyiXcPjQKHt+HgNXhOJJx0cgeWQatbhCvwvoYWGqHh/LJ84hJiQF4Mr6/B/12ObHcxIwQTUaiKuwzuGbHcC0E7CaAnk6tokOvdP70iWz+b4lXs9RqBfwAJTjWBQZm6HTp2f7BLkuQg/Zb++A/kOee2asWAyV3ZQ2X9QJGgxzY4xmQzUe/D+lvocKXpHbtvZH2AQgC7mO9gID/lT+kdd54o/2CjnvOYqQHTjR0v82WloWab92BI0p7ELK6ujb5XBfVKuML87lHmrOO+moXae93Bkd3+g4QXKvvX+lC55IvpwsdCEuyo6y/T6uTVCCNM8K/+hWGOPPAcn4EGoi4xCqG5ZKGFOmUMMmF+memZlh6z/FE0wzhuge/Hw3Kaa/HLCfjgjNV0L86oc1zKY65XGp5Mebolkz9RFHtFIHvU+GdfXKPc3w+jkM0Kfmw1Puwe6AJQUArmAP91vRm4wgAL6xaVBaLeq399g+M2tM2zxjBWuAoVTKqARhbf5kd10S/F+RtBPx6Wcbpb9cN9+lK+lx7LHWOn1Dkq+7FN6hvjgdA3OIeWBFOIcvIvfePQWFCKanV+NxWRWaqvH2/TVsWyxXR1+AjK2nMecvcv5Zk6Nd2MlSaxL8024TujQhqA4ph1haRvYSeHdzYez78D+p6BX1iUUIlPICteuB6A3iUGaiiyz6quSUzu/FdM3hpvJL1pJPiXt8/pukhzES/OK1wpVE7u5iGTSMFIH3AHY1SoEX0xxMI7J5NqQase2nQzlq44suP6ba65LMfMvMr+15m1NIRHqxL3JFQBN2o5T4cM2MiRdYoXR5uTBWMIAlf3MRUKfgKk/8WY86ODdPIdy6tm1GbWay2vR9gD1ySENb/VQhQ9LEtWk27br+8q4ANRuOiDa9ox4Kzdq+FPGTdNk+3ZnaESfKMyflpc5Bb/XjLvoGB6HA8SupxL+COsnv15SxiUY/gH0lqDpFD8KzL9NC3l1yDlvCKp9iNC2GSnQZhjv5LPXSD8VhvsXjzI/sVyHU8AATYqhvyh8zUxHsLDU2w35opXjRkgmUCd4ku13kLSYzFZmrrUjmvXZ2hBrs4I1V6zVPWZ1JmBVEYK0uChnNH0R/M7iTjUPGAhQ2emy1lgoZaL/X674NyEGomlo0eLFEyKsa7C5gEyIxY7Tm7F12eWq5qSUOUvXIdt53nnRyhOWS4JCxu18UABIrcfWhVFvF9kYD8+i05Fa3t4ALQt7fRF+O7+D+z7GK3Pzu+djztuphp1MKH7O1j6IaaFbNIL7mrIYIrck8uJV6BtmNBQKdjcAqGFNIDuf9W3MkG6Q/oaxWJiPxKE6MqRwWXV6QLNqBeQlrGV6wr+FdezbZHskp+Ip2si5BAU+IczmehEJWGEbaClVUMwB1ZmIMLzAxElFeqJWq5eMOVDMeaaNwAHONoVktn/TFjChfPdVUrgAQpUPV3UxzvQMJZZkRpKl3QU9D9/zbe5ZsOV5JtwhwWltfJK/m8fJfF14c2IAcl/KX0FAAD/kYD8+i09rLiYm9BAH2CbgOAJer2YP7PsbQ4BjVzY7YQXMc+/zFOAzJSWh4VAxey9e6MXMj72EKMrwEneh8vpgAGJ4aTEtuN24MNJzAcIVhkLmhc223Fzvv52DrlF7EvUnBdXzZN2H8BTm/WcNW/By48In61LtDUse4yjnrIi4NRp2dIrvtr4bW/F/UrBZoZBRl7UjsnvFHg485CFnZpTw2f1166twivNO+Es1koGTk1pevRs0mF8dnJ/k5P3SF/L77UQq839RswAAAAA=";
const nfidLogo = "data:image/webp;base64,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";
const dfinityLogo = "data:image/webp;base64,UklGRsQLAABXRUJQVlA4WAoAAAAwAAAAlQAAlQAASUNDUMgBAAAAAAHIAAAAAAQwAABtbnRyUkdCIFhZWiAH4AABAAEAAAAAAABhY3NwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAA9tYAAQAAAADTLQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlkZXNjAAAA8AAAACRyWFlaAAABFAAAABRnWFlaAAABKAAAABRiWFlaAAABPAAAABR3dHB0AAABUAAAABRyVFJDAAABZAAAAChnVFJDAAABZAAAAChiVFJDAAABZAAAAChjcHJ0AAABjAAAADxtbHVjAAAAAAAAAAEAAAAMZW5VUwAAAAgAAAAcAHMAUgBHAEJYWVogAAAAAAAAb6IAADj1AAADkFhZWiAAAAAAAABimQAAt4UAABjaWFlaIAAAAAAAACSgAAAPhAAAts9YWVogAAAAAAAA9tYAAQAAAADTLXBhcmEAAAAAAAQAAAACZmYAAPKnAAANWQAAE9AAAApbAAAAAAAAAABtbHVjAAAAAAAAAAEAAAAMZW5VUwAAACAAAAAcAEcAbwBvAGcAbABlACAASQBuAGMALgAgADIAMAAxADZBTFBI9gIAAAFPQCBAGWSBHjBFRIT+1QEgt7Zt107e+/KZd5mEpwRleJORqgL4JfwGIJX5Ztxy731nm3MHuSL6D0GS3LgNBGZ5OoslwEcMz6d8hy++fHn1YkxSuwnU8r0vJX4vMvYRqL1vnSw7JOgHuWzcOsVJPdGop1oHb62LX5fSwR81t5ktmcHP0cv46o+ZgTru6GVKpun14Bf0MqYsNPmJOZPaTwddfqOiZoKF89/rUspixfldKb1M9Q2c/0FOtyJWE5cZeCjzNUh5Og7XjzRWC0+HYbhZMsWElbKmb0NzI9YPlImOSY03EDsSWTKAf8F0JPp4w/sFJgq5ERp8QLY60YWwcMiTmYVFnEFAkic8czGlKZUFpJOoFQYNWa0LbkiG2QaySdUdEYBy2FYFZbD55eY4g0bBoRb0hgUd94HzHABDliPCmuDanoCf/R60ZEfUT8ah3ggZnnml5gzdIYmahJoBykxVOhxEwxUHiAnkRQUHyZ0BQQfI0EDkDIYRoeUAiBkbQUk03JkDiSRVbMvBqqJpkNB4+/AWJOEu8nJ+KpqIuFLMwo5tHf7od6Gt2BZJCfOFW4HX6T5/4hZ7+i7Cf3GsvSEEuhjUr3dyekNMkMUui849HSBT0rL24RkxCfogi53Ub7x9K5nBCDjpDoTIlcWfMkssDDMAhFhOwkarwjS4Qd5Ww4SGjbruiQiPBPQK0GEGQ132RINrBia1vWp4kPNjbKgEDDy9Fo0wHqT8BBkieAXiFm5q7GwjgpoDvQMLZ6oFxsKiC8byR44TMCd6LQEPzByhTFhYARiRGeoF6+pu+RWQ4CE1kQnjNgt9bNNbxocs1uO4SvVB4N3Dj0torNJJrJQhJVFFM6k9IYG/jBqLVX6YFIZiIMJmKuR/65jiCZDIEiVJjaW0y+80HWbELMBrINVPoOTn0ZNhplDUujVnSOboNTZzpoxALcmcOfN7YWyy3NDLdimZ6bIlXDXXu7T4NvSM88sUZLLz4tOXL8djB2ovau/5lG8AVlA4INgGAACwJQCdASqWAJYAPkEci0Qiv6EV6fUV+AQEsjdv+BegXSq+wBooFzMqlGmKP6j+S/5gfKzT/5x94vys59Wd/Nn8Y/Lv9v/b/yQ9+39u9hH3Ae4B/DP5D/hf7L+4v96+AD+gezvzB/zz+8f8v/Y+8p6EvQA/qn+89Xj/ZewJ/evUA/cL1VP85+unwHftT/7v9N8BP8y/uv/h/P/5APQA9ADsYf8BRQHBphC+1z2KHSIrF9rnr38RAcwL0aeV2ux1vsBZ9+rNV8BBq/xwbilp/7CUzlYNLIlR1hXd1xJT1R7YDFRy0qkw4eN7nMmgvUECES+Pgz7D2MKwpazNXdsMTS6R1L2ec2uwRfh+O4wYn4MbdGAPSPK6UugICmuXWyoDe4a5i4iXOUs4u3Zb8HHaDRXSIrF9rngAAP7+pTYAANX6qLlTGD0S0vxrEzDe9dadDCv5GN2Rq7PxQ5QLr+4WzzQTn70rjIYpmjDVEBdpMon/NosuNcmaMhWjxk/P3zWqMOakILHD/DX9p0MK/kUQz2GLmFb54xxGB5nkQXQsUJcY721+FPYdlxXdl4RXPdK+e5/098m9GDrodLyH0gyRkDc99hktCpxSyzg2D4StG//LXBoJ9GHweUoQNhEihPw8AGIjK5ZZhzc3zSHd8YwYBTRuy7JJKFx9PxmzEzW13EkIeNB5A5DWeaF1NnH7uvz07d0OqmR3xj64WXXIfpf3sNZmYPH5Te+VJ+gwFzlTegKK5SmIqSQelJ4prV8BREewiR6a8Om0Ee6G1u+fhfTOWXeZ4C2ybsy0HbBjbTwJpL8y/3sEc5nvXVq1O44om9cFyuDmtxf6ED7LiAjOK34yPyJUFEqU/T5wGlHiFTrCqOGworkGftiUTRaAA/2fjfq88eup7oiuEokopvpGVciJZJVSRqvTQ+/B1hMJI0yQf1VG0/9PsuioQnQbgMeM33n60BMhhU+zvzN04NVEFBOrqQ1weAClYrB2Atwpl5X5KsSxaAlfBY9iZU2wCOVrHbehgtfNH0oXW85aD2TnYu9H58glgT6XdxbImYhWEKp4eyYj9hhwHhMjcPruD0Ry+VT6Pvs4+Vqbw1U/juhJzn9QRR3T+i5yqG/TOzPRVJ/ai/suFPOCyaQQZrDuTq9/HJ+4Oe4nW9wo7S6gzGYPzyqzjgmIxgT15G9kfL3vv6n3G/gKSJNe3De7E8OO1BwAfof6scbtPLaQu18lV4WHmIbLJhhR7CYtYvewjy6COh/pBofcCW9ZJh8UD32JTTXuPvzfkFy5QedFWnh2Lo913fIfMVKAmw4B6UDOLwYyH+DqUGZbZfHo/+yp7vv2K92kYAxy92mJjQiHVgK17Pp4QRZyQhCA9ZeN59YkYPCIC3OAIlVv/ifsCCPx7e+vfTMwu2TdYc9rnmelIXRX02/gmcu2tD/hAjy0n4lr8GZnWTxKdf6WX30mUpwR0wrQ5uFBtMq39+XQX2wv0Ev/3YF/i+i2NCq+u5yk/vWcmIENc1FNGfF5J6iw9SCZROkMUQZPkbfiP7M4wtDXr9gp9I2cvFJFRVV/Drf3BqmxAHXpPv/907qcQTIKTycBfi2LobrDPRIVSYMbl5xk1Y2ZAV9VvPKmMezGRYGwFS3AQ053b8iyAhBrH2IWsA8xKulVOLVeA2iRJ+DrkUg6ZNQodI9aW3VG4OvBUhgpaO9x5x4Mbq9OTGuby2LEZsBShQPC1zItO/oqcgdCWnF1KiX+zWZoZ7kGDjWcFDCYxX//KM7h+jEe8B3C7weyjvnKzhAvBzKlhJChPC5R6Luf3NhvGGgn+iahRNAs8PUpLT+4jMZBj49u6PiCX1O6nTrIcrwUZX4ClI/+b2Gsx2c/ZQ/DP4LmVIpK0Qqv73GWm3q5ELvuz0T9r4ydpHRhyoMYiHze1REyE/0ZzIKg6WOVFWPXyKUuzbOveQHn2Pa9hry76II3jSdIcWz8QwYmFbQd2m6NA6JJ/H+PQhEkWh2DyMrWjhtNGw4NLb64kBylMSYvIDBD84yNaaW/oLGErn/jf52IlSHXzu3jL0wxQydITJm0Wu2Nk/FVYT354Ej9gZhIziJUb/EqKVFNv/nDP/15f/1u/i+A/3V8NCG00dK/YTNL8XyPpiRB9MnQCZaIhkLdFI8UiMlIEZKqK1RTVlA+CEVG1WlSBq/mXLKFFlFcv2xu5EABMrJhT7/abUBpQCQTa8uM+oTJMwpyDbaXoMtdB4wH/BtveAAExeXZZRtDOb5E0GNVHigUSXUsmZxP9HLKsP7nqgGB58voOwFUH4//avh/iIbBFQaM1n1sb3HcNpqrONoL+Ur1wAAAAAAAAAAAAAA=";
const plugLogo = "data:image/webp;base64,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";
const Adapters = {
  // Solana Adapters
  phantomSiws: {
    id: "phantomSiws",
    enabled: false,
    walletName: "Phantom",
    logo: phantomLogo,
    website: "https://phantom.app",
    chain: "SOL",
    adapter: SiwsAdapter,
    config: {
      enabled: false,
      solanaNetwork: WalletAdapterNetwork.Mainnet
    }
  },
  solflareSiws: {
    id: "solflareSiws",
    enabled: false,
    walletName: "Solflare",
    logo: solflareLogo,
    website: "https://solflare.com",
    chain: "SOL",
    adapter: SiwsAdapter,
    config: {
      enabled: false,
      solanaNetwork: WalletAdapterNetwork.Mainnet
    }
  },
  backpackSiws: {
    id: "backpackSiws",
    enabled: false,
    walletName: "Backpack",
    logo: backpackLogo,
    website: "https://backpack.app",
    chain: "SOL",
    adapter: SiwsAdapter,
    config: {
      enabled: false,
      solanaNetwork: WalletAdapterNetwork.Mainnet
    }
  },
  walletconnectSiws: {
    id: "walletconnectSiws",
    enabled: false,
    walletName: "WalletConnect",
    logo: walletconnectLogo,
    website: "https://walletconnect.com",
    chain: "SOL",
    adapter: SiwsAdapter,
    config: {
      enabled: false,
      solanaNetwork: WalletAdapterNetwork.Mainnet,
      projectId: "YOUR_PROJECT_ID",
      appName: "Windoge98",
      appDescription: "A dApp using WalletConnect for Solana",
      appUrl: "https://desktop.windoge98.com",
      appIcons: ["https://desktop.windoge98.com/logo.png"]
    }
  },
  // Internet Computer Adapters
  oisy: {
    id: "oisy",
    enabled: true,
    walletName: "OISY Wallet",
    logo: oisyLogo,
    website: "https://oisy.com",
    chain: "ICP",
    adapter: OisyAdapter,
    config: {
      signerUrl: "https://oisy.com/sign",
      transport: {
        windowOpenerFeatures: "width=525,height=705",
        establishTimeout: 45e3,
        disconnectTimeout: 45e3,
        statusPollingRate: 500,
        detectNonClickEstablishment: false
      }
    }
  },
  nfid: {
    id: "nfid",
    enabled: true,
    walletName: "NFID",
    logo: nfidLogo,
    website: "https://nfid.one",
    chain: "ICP",
    adapter: NFIDAdapter,
    config: {
      signerUrl: "https://nfid.one/rpc",
      fetchRootKey: false,
      verifyQuerySignatures: true,
      transport: {
        windowOpenerFeatures: "width=525,height=705",
        establishTimeout: 45e3,
        disconnectTimeout: 45e3,
        statusPollingRate: 500,
        detectNonClickEstablishment: false
      }
    }
  },
  ii: {
    id: "ii",
    enabled: true,
    walletName: "Internet Identity",
    logo: dfinityLogo,
    website: "https://internetcomputer.org",
    chain: "ICP",
    adapter: IIAdapter,
    config: {
      fetchRootKey: false,
      verifyQuerySignatures: true,
      derivationOrigin: void 0,
      localIdentityCanisterId: "rdmx6-jaaaa-aaaaa-aaadq-cai"
    }
  },
  plug: {
    id: "plug",
    enabled: true,
    walletName: "Plug",
    logo: plugLogo,
    website: "https://plugwallet.ooo",
    chain: "ICP",
    adapter: PlugAdapter,
    config: {
      delegationTargets: [],
      delegationTimeout: BigInt(7 * 24 * 60 * 60 * 1e3 * 1e3 * 1e3)
    }
  }
};
const defaultCreateArgs = {
  // Global defaults matching user's updated PnpConfig
  dfxNetwork: "ic",
  replicaPort: 8080,
  frontendPort: 3e3,
  delegationTimeout: BigInt(24 * 60 * 60 * 1e3 * 1e3 * 1e3),
  // 1 day
  delegationTargets: [],
  localStorageKey: "pnpState",
  adapters: {
    ...Adapters
  }
};
function getHostUrl(dfxNetwork, replicaPort) {
  if (dfxNetwork === "local") {
    return `http://127.0.0.1:${replicaPort || defaultCreateArgs.replicaPort}`;
  }
  return "https://icp0.io";
}
function createPNPConfig(config = {}) {
  const finalAdapters = {};
  const hostUrl = getHostUrl(config.dfxNetwork, config.replicaPort);
  function getDerivationOrigin() {
    if (config.frontendCanisterId && hostUrl.includes("icp0.io")) {
      return `https://${config.frontendCanisterId}.icp0.io`;
    }
    return `http://localhost:${config.frontendPort || defaultCreateArgs.frontendPort}`;
  }
  const derivationOrigin = getDerivationOrigin();
  for (const adapterId in defaultCreateArgs.adapters) {
    const defaultAdapterInfo = defaultCreateArgs.adapters[adapterId];
    const userAdapterOverride = config.adapters?.[adapterId];
    if (!defaultAdapterInfo) continue;
    const finalAdapterConfig = {
      // Start with the default metadata (id, walletName, logo, adapter constructor)
      ...defaultAdapterInfo,
      // Override 'enabled' status if provided by user, otherwise use default
      enabled: userAdapterOverride?.enabled ?? defaultAdapterInfo.enabled,
      // Build the nested 'config' object
      config: {
        // 1. Start with the default adapter's config
        ...defaultAdapterInfo.config,
        // 2. Apply global overrides from the main config object
        hostUrl,
        // Use nullish coalescing (??) for booleans to allow 'false' override
        fetchRootKey: config.fetchRootKey ?? config.dfxNetwork === "local" ? true : false,
        verifyQuerySignatures: config.verifyQuerySignatures ?? config.dfxNetwork === "local" ? false : true,
        delegationTimeout: config.delegationTimeout || defaultCreateArgs.delegationTimeout,
        delegationTargets: config.delegationTargets || defaultCreateArgs.delegationTargets,
        frontendCanisterId: config.frontendCanisterId,
        derivationOrigin: config.derivationOrigin || derivationOrigin,
        localStorageKey: config.localStorageKey || defaultCreateArgs.localStorageKey,
        // Merge global SIWS ID if provided, otherwise use default adapter config's value (if any) or default global
        siwsProviderCanisterId: config.siwsProviderCanisterId,
        // 3. Apply adapter-specific overrides provided DIRECTLY by the user (e.g., projectId, appName)
        // Filter out 'enabled' and 'config' as they are handled separately/next
        ...Object.fromEntries(
          Object.entries(userAdapterOverride || {}).filter(
            ([key]) => key !== "enabled" && key !== "config"
          )
        ),
        // 4. Apply overrides provided WITHIN the user's 'config' object (highest precedence for specific config keys)
        ...userAdapterOverride?.config || {}
      }
    };
    if (userAdapterOverride?.walletName) finalAdapterConfig.walletName = userAdapterOverride.walletName;
    if (userAdapterOverride?.logo) finalAdapterConfig.logo = userAdapterOverride.logo;
    if (userAdapterOverride?.website) finalAdapterConfig.website = userAdapterOverride.website;
    finalAdapters[adapterId] = finalAdapterConfig;
  }
  const finalGlobalConfig = {
    // Global settings merged from user input and defaults
    dfxNetwork: config.dfxNetwork || defaultCreateArgs.dfxNetwork,
    replicaPort: config.replicaPort || defaultCreateArgs.replicaPort,
    hostUrl,
    delegationTimeout: config.delegationTimeout || defaultCreateArgs.delegationTimeout,
    delegationTargets: config.delegationTargets || defaultCreateArgs.delegationTargets,
    derivationOrigin: config.derivationOrigin || derivationOrigin,
    fetchRootKey: config.fetchRootKey ?? config.dfxNetwork === "local" ? true : false,
    verifyQuerySignatures: config.verifyQuerySignatures ?? config.dfxNetwork === "local" ? false : true,
    localStorageKey: config.localStorageKey || defaultCreateArgs.localStorageKey,
    siwsProviderCanisterId: config.siwsProviderCanisterId,
    // The processed adapters map
    adapters: finalAdapters
  };
  return finalGlobalConfig;
}
var AdapterStatus = /* @__PURE__ */ ((AdapterStatus2) => {
  AdapterStatus2["INIT"] = "INIT";
  AdapterStatus2["READY"] = "READY";
  AdapterStatus2["CONNECTING"] = "CONNECTING";
  AdapterStatus2["CONNECTED"] = "CONNECTED";
  AdapterStatus2["DISCONNECTING"] = "DISCONNECTING";
  AdapterStatus2["DISCONNECTED"] = "DISCONNECTED";
  AdapterStatus2["ERROR"] = "ERROR";
  return AdapterStatus2;
})(AdapterStatus || {});
class ConnectionManager {
  constructor(config, logger) {
    this.adapter = null;
    this.provider = null;
    this.account = null;
    this.status = AdapterStatus.INIT;
    this.config = config;
    this.status = AdapterStatus.READY;
    this.eventEmitter = new EventEmitter();
    this.logger = logger || new ErrorManager(this.eventEmitter);
  }
  _resetState() {
    const oldAccount = this.account;
    this.provider;
    const oldAdapter = this.adapter;
    const oldStatus = this.status;
    this.account = null;
    this.provider = null;
    this.adapter = null;
    this.status = AdapterStatus.READY;
    this.emit(PnpEventType.STATUS_CHANGE, {
      oldStatus,
      newStatus: this.status
    });
    this.emit(PnpEventType.ACCOUNT_CHANGE, {
      oldAccount,
      newAccount: null
    });
    this.emit(PnpEventType.ADAPTER_CHANGE, {
      oldAdapter,
      newAdapter: null
    });
  }
  async openChannel() {
    if (this.provider) {
      await this.provider.openChannel();
    }
  }
  async connect(walletId) {
    if (this.status === AdapterStatus.CONNECTING) {
      return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          this.off(PnpEventType.CONNECTED, onConnected);
          this.off(PnpEventType.ERROR, onError);
          reject(new Error("Connection attempt timed out"));
        }, 3e4);
        const onConnected = (event) => {
          clearTimeout(timeout);
          this.off(PnpEventType.CONNECTED, onConnected);
          this.off(PnpEventType.ERROR, onError);
          resolve(event.data.account);
        };
        const onError = (event) => {
          clearTimeout(timeout);
          this.off(PnpEventType.CONNECTED, onConnected);
          this.off(PnpEventType.ERROR, onError);
          reject(event.data.error);
        };
        this.on(PnpEventType.CONNECTED, onConnected);
        this.on(PnpEventType.ERROR, onError);
      });
    }
    const oldStatus = this.status;
    this.status = AdapterStatus.CONNECTING;
    this.emit(PnpEventType.STATUS_CHANGE, {
      oldStatus,
      newStatus: AdapterStatus.CONNECTING,
      walletId
    });
    let instance2 = null;
    try {
      const targetWalletId = walletId;
      if (!targetWalletId) {
        throw new Error("No wallet ID provided");
      }
      if (!this.config.adapters[targetWalletId]) {
        throw new Error(`Invalid adapter id: ${targetWalletId}`);
      }
      const adapterInfo = this.config.adapters[targetWalletId];
      instance2 = new adapterInfo.adapter({
        adapter: adapterInfo,
        config: {
          ...this.config,
          ...adapterInfo.config
        },
        logger: this.logger
      });
      if (!instance2 || typeof instance2.connect !== "function") {
        throw new Error("Invalid adapter instance");
      }
      const account = await instance2.connect();
      if (!account || !account.owner) {
        throw new Error("Invalid connection result: Missing account or owner");
      }
      const oldAccount = this.account;
      const oldAdapter = this.adapter;
      const oldStatus2 = this.status;
      this.account = account;
      this.adapter = {
        id: adapterInfo.id || targetWalletId,
        enabled: adapterInfo.enabled ?? true,
        logo: adapterInfo.logo || "",
        walletName: adapterInfo.walletName || targetWalletId,
        chain: adapterInfo.chain || "ICP",
        adapter: adapterInfo.adapter,
        config: adapterInfo.config || {}
      };
      this.provider = instance2;
      this.status = AdapterStatus.CONNECTED;
      this.emit(PnpEventType.CONNECTED, { account });
      this.emit(PnpEventType.STATUS_CHANGE, {
        oldStatus: oldStatus2,
        newStatus: this.status,
        walletId
      });
      this.emit(PnpEventType.ACCOUNT_CHANGE, {
        oldAccount,
        newAccount: account
      });
      this.emit(PnpEventType.ADAPTER_CHANGE, {
        oldAdapter,
        newAdapter: adapterInfo
      });
      return account;
    } catch (error) {
      this.status = AdapterStatus.ERROR;
      this.emit(PnpEventType.STATUS_CHANGE, {
        oldStatus,
        newStatus: AdapterStatus.ERROR,
        walletId
      });
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      const enhancedError = new Error(`Connection failed: ${errorMessage}`);
      if (error instanceof Error && error.name) {
        enhancedError.name = error.name;
      }
      this.emit(PnpEventType.ERROR, {
        error: enhancedError,
        operation: "connect",
        walletId
      });
      if (instance2) {
        try {
          await instance2.disconnect();
        } catch (disconnectError) {
          this.logger.error("Error during disconnect after failed connect", disconnectError);
        }
      }
      this._resetState();
      throw enhancedError;
    }
  }
  async disconnect() {
    const oldStatus = this.status;
    this.status = AdapterStatus.DISCONNECTING;
    this.emit(PnpEventType.STATUS_CHANGE, {
      oldStatus,
      newStatus: AdapterStatus.DISCONNECTING
    });
    try {
      if (this.provider) await this.provider.disconnect();
      this._resetState();
      this.status = AdapterStatus.DISCONNECTED;
      this.emit(PnpEventType.DISCONNECTED, {});
      this.emit(PnpEventType.STATUS_CHANGE, {
        oldStatus,
        newStatus: AdapterStatus.DISCONNECTED
      });
    } catch (error) {
      this.emit(PnpEventType.ERROR, {
        error,
        operation: "disconnect"
      });
      this._resetState();
      this.status = AdapterStatus.ERROR;
      this.emit(PnpEventType.STATUS_CHANGE, {
        oldStatus,
        newStatus: AdapterStatus.ERROR
      });
    }
  }
  isAuthenticated() {
    return this.adapter !== null && this.provider !== null && this.account !== null && this.status === AdapterStatus.CONNECTED;
  }
  // Event emitter methods
  on(event, listener) {
    this.eventEmitter.on(event, listener);
  }
  off(event, listener) {
    this.eventEmitter.off(event, listener);
  }
  emit(event, data) {
    this.eventEmitter.emit(event, data);
  }
  removeAllListeners(event) {
    this.eventEmitter.removeAllListeners(event);
  }
}
class ActorManager {
  constructor(config, provider = null) {
    this.actorCache = /* @__PURE__ */ new Map();
    this.config = config;
    this.provider = provider;
    this.eventEmitter = new EventEmitter();
  }
  setProvider(provider) {
    const oldProvider = this.provider;
    this.provider = provider;
    this.emit(PnpEventType.PROVIDER_CHANGED, {
      oldProvider,
      newProvider: provider
    });
  }
  getActor(options) {
    const { canisterId, idl, anon = false, requiresSigning = false } = options;
    if (anon) {
      return this.createAnonymousActor(canisterId, idl);
    }
    if (!this.provider) {
      throw new Error(
        "Cannot create signed actor. No wallet provider connected."
      );
    }
    const actor = this.provider.createActor(canisterId, idl, {
      requiresSigning
    });
    this.emit(PnpEventType.ACTOR_CREATED, {
      canisterId,
      idl,
      isAnonymous: false,
      requiresSigning
    });
    return actor;
  }
  createAnonymousActor(canisterId, idl) {
    const cacheKey = `anon-${canisterId}`;
    const cachedActor = this.actorCache.get(cacheKey);
    if (cachedActor) return cachedActor;
    const agent = HttpAgent.createSync({
      host: this.config.hostUrl,
      verifyQuerySignatures: this.config.verifyQuerySignatures
    });
    fetchRootKeyIfNeeded(agent, this.config.fetchRootKey);
    const actor = Actor.createActor(idl, {
      agent,
      canisterId
    });
    this.actorCache.set(cacheKey, actor);
    this.emit(PnpEventType.ACTOR_CREATED, {
      canisterId,
      idl,
      isAnonymous: true,
      requiresSigning: false
    });
    return actor;
  }
  clearCache() {
    const cacheSize = this.actorCache.size;
    this.actorCache.clear();
    this.emit(PnpEventType.CACHE_CLEARED, {
      clearedEntries: cacheSize,
      timestamp: Date.now()
    });
  }
  // Event emitter methods
  on(event, listener) {
    this.eventEmitter.on(event, listener);
  }
  off(event, listener) {
    this.eventEmitter.off(event, listener);
  }
  emit(event, data) {
    this.eventEmitter.emit(event, data);
  }
  removeAllListeners(event) {
    this.eventEmitter.removeAllListeners(event);
  }
}
class ConfigManager {
  constructor(userConfig = {}) {
    this.config = createPNPConfig(userConfig);
    this.eventEmitter = new EventEmitter();
    this.validateConfig(this.config);
  }
  getConfig() {
    return this.config;
  }
  updateConfig(partialConfig) {
    const oldConfig = this.config;
    const newConfig = createPNPConfig({ ...this.config, ...partialConfig });
    const validationResult = this.validateConfig(newConfig);
    if (!validationResult.isValid) {
      this.emit(PnpEventType.CONFIG_VALIDATION, {
        config: newConfig,
        isValid: false,
        errors: validationResult.errors
      });
      throw new Error(`Invalid configuration: ${validationResult.errors.map((e3) => e3.message).join(", ")}`);
    }
    this.config = newConfig;
    this.emit(PnpEventType.CONFIG_CHANGE, {
      oldConfig,
      newConfig,
      changes: partialConfig
    });
  }
  validateConfig(config) {
    const errors = [];
    if (config.hostUrl) {
      try {
        new URL(config.hostUrl);
      } catch {
        errors.push({ field: "hostUrl", message: "Invalid host URL format" });
      }
    }
    if (config.delegationTimeout && config.delegationTimeout <= 0) {
      errors.push({ field: "delegationTimeout", message: "Delegation timeout must be positive" });
    }
    if (config.delegationTargets) {
      if (!Array.isArray(config.delegationTargets)) {
        errors.push({ field: "delegationTargets", message: "Delegation targets must be an array" });
      } else {
        config.delegationTargets.forEach((target, index) => {
          if (typeof target !== "string") {
            errors.push({ field: `delegationTargets[${index}]`, message: "Delegation target must be a string" });
          }
        });
      }
    }
    if (config.adapters) {
      Object.entries(config.adapters).forEach(([id, adapter]) => {
        if (!adapter) {
          errors.push({ field: `adapters.${id}`, message: "Adapter configuration is required" });
          return;
        }
        if (adapter.id && typeof adapter.id !== "string") {
          errors.push({ field: `adapters.${id}.id`, message: "Adapter ID must be a string" });
        }
        if (adapter.walletName && typeof adapter.walletName !== "string") {
          errors.push({ field: `adapters.${id}.walletName`, message: "Wallet name must be a string" });
        }
        if (adapter.logo && typeof adapter.logo !== "string") {
          errors.push({ field: `adapters.${id}.logo`, message: "Logo URL must be a string" });
        }
        if (adapter.adapter && typeof adapter.adapter !== "function") {
          errors.push({ field: `adapters.${id}.adapter`, message: "Adapter must be a constructor function" });
        }
      });
    }
    const isValid = errors.length === 0;
    this.emit(PnpEventType.CONFIG_VALIDATION, {
      config,
      isValid,
      errors
    });
    return { isValid, errors };
  }
  // Helper methods
  getAdapterConfig(id) {
    return this.config.adapters?.[id] || null;
  }
  isAdapterEnabled(id) {
    const adapter = this.getAdapterConfig(id);
    return adapter?.enabled !== false;
  }
  enableAdapter(id) {
    this.updateConfig({
      adapters: {
        ...this.config.adapters,
        [id]: {
          ...this.config.adapters?.[id],
          enabled: true
        }
      }
    });
  }
  disableAdapter(id) {
    this.updateConfig({
      adapters: {
        ...this.config.adapters,
        [id]: {
          ...this.config.adapters?.[id],
          enabled: false
        }
      }
    });
  }
  // Event emitter methods
  on(event, listener) {
    this.eventEmitter.on(event, listener);
  }
  off(event, listener) {
    this.eventEmitter.off(event, listener);
  }
  emit(event, data) {
    this.eventEmitter.emit(event, data);
  }
  removeAllListeners(event) {
    this.eventEmitter.removeAllListeners(event);
  }
}
class StatePersistenceManager {
  constructor(errorManager, options) {
    this.errorManager = errorManager;
    this.options = {
      storage: typeof window !== "undefined" ? window.localStorage : void 0,
      maxHistorySize: 100,
      autoRecover: true,
      validateOnLoad: true,
      ...options
    };
  }
  saveState(history) {
    if (!this.options.storage) return;
    try {
      const serialized = JSON.stringify({
        ...history,
        transitions: history.transitions.map((t) => ({
          ...t,
          timestamp: t.timestamp.toISOString()
        }))
      });
      this.options.storage.setItem(this.options.key, serialized);
    } catch (error) {
      this.errorManager.warn("Failed to persist state", { error });
    }
  }
  loadState() {
    if (!this.options.storage) return null;
    try {
      const serialized = this.options.storage.getItem(this.options.key);
      if (!serialized) return null;
      const parsed = JSON.parse(serialized);
      const history = {
        ...parsed,
        transitions: parsed.transitions.map((t) => ({
          ...t,
          timestamp: new Date(t.timestamp)
        }))
      };
      if (this.options.validateOnLoad && !this.validateStateHistory(history)) {
        this.errorManager.warn("Invalid state history loaded", { history });
        return null;
      }
      return history;
    } catch (error) {
      this.errorManager.warn("Failed to load persisted state", { error });
      return null;
    }
  }
  clearState() {
    if (!this.options.storage) return;
    try {
      this.options.storage.removeItem(this.options.key);
    } catch (error) {
      this.errorManager.warn("Failed to clear persisted state", { error });
    }
  }
  validateStateHistory(history) {
    if (!history.currentState || !history.transitions) return false;
    if (!Object.values(PnpState).includes(history.currentState)) return false;
    for (const transition of history.transitions) {
      if (!this.validateTransition(transition)) return false;
    }
    return true;
  }
  validateTransition(transition) {
    return Object.values(PnpState).includes(transition.from) && Object.values(PnpState).includes(transition.to) && transition.timestamp instanceof Date && !isNaN(transition.timestamp.getTime());
  }
  getStateKey() {
    return this.options.key;
  }
  setOptions(options) {
    this.options = { ...this.options, ...options };
  }
}
var PnpState = /* @__PURE__ */ ((PnpState2) => {
  PnpState2["INITIALIZED"] = "initialized";
  PnpState2["CONNECTING"] = "connecting";
  PnpState2["CONNECTED"] = "connected";
  PnpState2["DISCONNECTING"] = "disconnecting";
  PnpState2["DISCONNECTED"] = "disconnected";
  PnpState2["ERROR"] = "error";
  return PnpState2;
})(PnpState || {});
class StateManager {
  constructor(eventEmitter, errorManager, persistenceOptions) {
    this.state = "initialized";
    this.transitions = [];
    this.eventEmitter = eventEmitter;
    this.errorManager = errorManager;
    this.persistenceManager = new StatePersistenceManager(errorManager, {
      key: persistenceOptions?.key || "pnp-state",
      ...persistenceOptions
    });
    this.loadState();
  }
  loadState() {
    const savedState = this.persistenceManager.loadState();
    if (savedState) {
      this.state = savedState.currentState;
      this.transitions = savedState.transitions;
      this.lastError = savedState.lastError;
    }
  }
  saveState() {
    const stateHistory = {
      currentState: this.state,
      transitions: this.transitions,
      lastError: this.lastError
    };
    this.persistenceManager.saveState(stateHistory);
  }
  getCurrentState() {
    return this.state;
  }
  getStateHistory() {
    return [...this.transitions];
  }
  getLastError() {
    return this.lastError;
  }
  async transitionTo(newState, context) {
    const transition = {
      from: this.state,
      to: newState,
      timestamp: /* @__PURE__ */ new Date(),
      context
    };
    if (!this.isValidTransition(this.state, newState)) {
      const error = new PnpError(
        `Invalid state transition from ${this.state} to ${newState}`,
        "INVALID_STATE_TRANSITION",
        { transition }
      );
      this.errorManager.handleError(error);
      throw error;
    }
    this.state = newState;
    this.transitions.push(transition);
    this.saveState();
    this.eventEmitter.emit(PnpEventType.STATE_CHANGE, {
      from: transition.from,
      to: transition.to,
      context: transition.context
    });
    this.errorManager.info(`State changed from ${transition.from} to ${transition.to}`, {
      context: transition.context
    });
  }
  isValidTransition(from, to) {
    const validTransitions = {
      [
        "initialized"
        /* INITIALIZED */
      ]: [
        "connecting",
        "error"
        /* ERROR */
      ],
      [
        "connecting"
        /* CONNECTING */
      ]: [
        "connected",
        "error"
        /* ERROR */
      ],
      [
        "connected"
        /* CONNECTED */
      ]: [
        "disconnecting",
        "error"
        /* ERROR */
      ],
      [
        "disconnecting"
        /* DISCONNECTING */
      ]: [
        "disconnected",
        "error"
        /* ERROR */
      ],
      [
        "disconnected"
        /* DISCONNECTED */
      ]: [
        "connecting",
        "error"
        /* ERROR */
      ],
      [
        "error"
        /* ERROR */
      ]: [
        "initialized",
        "connecting"
        /* CONNECTING */
      ]
    };
    return validTransitions[from]?.includes(to) ?? false;
  }
  setError(error) {
    this.lastError = error;
    this.saveState();
  }
  clearError() {
    this.lastError = void 0;
    this.saveState();
  }
}
const _PNP = class _PNP {
  /**
   * Register a new adapter globally. Call before PNP instantiation to make available to all instances.
   * @param id Adapter id (unique key)
   * @param config AdapterConfig
   */
  static registerAdapter(id, config) {
    _PNP.adapterRegistry[id] = config;
  }
  /**
   * Unregister an adapter by id.
   * @param id Adapter id
   */
  static unregisterAdapter(id) {
    delete _PNP.adapterRegistry[id];
  }
  /**
   * Get all registered adapters.
   */
  static getRegisteredAdapters() {
    return { ..._PNP.adapterRegistry };
  }
  constructor(config = {}) {
    const mergedAdapters = {
      ..._PNP.adapterRegistry,
      ...config.adapters || {}
    };
    const mergedConfig = { ...config, adapters: mergedAdapters };
    this.eventEmitter = new EventEmitter();
    this.errorManager = new ErrorManager(
      this.eventEmitter,
      config.logLevel || LogLevel.INFO
    );
    this.stateManager = new StateManager(
      this.eventEmitter,
      this.errorManager,
      {
        key: config.persistenceKey || "pnp-state",
        storage: config.storage,
        maxHistorySize: config.maxStateHistorySize,
        autoRecover: config.autoRecoverState,
        validateOnLoad: config.validateStateOnLoad
      }
    );
    this.configManager = new ConfigManager(mergedConfig);
    const finalConfig = this.configManager.getConfig();
    this.connectionManager = new ConnectionManager(finalConfig, this.errorManager);
    this.actorManager = new ActorManager(finalConfig, null);
    this.connectionManager.on(PnpEventType.CONNECTED, async () => {
      try {
        await this.stateManager.transitionTo(PnpState.CONNECTED);
        this.actorManager.setProvider(this.connectionManager.provider);
        this.emit(PnpEventType.CONNECTED, { account: this.account });
      } catch (error) {
        this.errorManager.handleError(error);
      }
    });
    this.connectionManager.on(PnpEventType.DISCONNECTED, async () => {
      try {
        await this.stateManager.transitionTo(PnpState.DISCONNECTED);
        this.actorManager.setProvider(null);
        this.actorManager.clearCache();
        this.emit(PnpEventType.DISCONNECTED, {});
      } catch (error) {
        this.errorManager.handleError(error);
      }
    });
    this.stateManager.transitionTo(PnpState.INITIALIZED).catch((error) => {
      this.errorManager.handleError(error);
    });
  }
  async openChannel() {
    await this.connectionManager.openChannel();
  }
  // Event emitter methods
  on(event, listener) {
    this.eventEmitter.on(event, listener);
  }
  off(event, listener) {
    this.eventEmitter.off(event, listener);
  }
  emit(event, data) {
    this.eventEmitter.emit(event, data);
  }
  removeAllListeners(event) {
    this.eventEmitter.removeAllListeners(event);
  }
  get config() {
    return this.configManager.getConfig();
  }
  get adapter() {
    return this.connectionManager.adapter;
  }
  get provider() {
    return this.connectionManager.provider;
  }
  get account() {
    return this.connectionManager.account;
  }
  get status() {
    return this.connectionManager.status;
  }
  async connect(walletId) {
    try {
      if (this.stateManager.getCurrentState() === PnpState.CONNECTED) {
        this.errorManager.info("Already connected.");
        return this.account;
      }
      await this.stateManager.transitionTo(PnpState.CONNECTING);
      const account = await this.connectionManager.connect(walletId);
      this.actorManager.setProvider(this.connectionManager.provider);
      return account;
    } catch (error) {
      await this.stateManager.transitionTo(PnpState.ERROR, { error });
      this.errorManager.handleError(error);
      throw error;
    }
  }
  async disconnect() {
    try {
      await this.stateManager.transitionTo(PnpState.DISCONNECTING);
      await this.connectionManager.disconnect();
      this.actorManager.setProvider(null);
      this.actorManager.clearCache();
    } catch (error) {
      await this.stateManager.transitionTo(PnpState.ERROR, { error });
      this.errorManager.handleError(error);
      throw error;
    }
  }
  getActor(options) {
    return this.actorManager.getActor(options);
  }
  isAuthenticated() {
    return this.connectionManager.isAuthenticated();
  }
  getEnabledWallets() {
    return Object.entries(this.config.adapters).filter(([_2, wallet]) => wallet?.enabled !== false).map(([id, wallet]) => ({
      ...wallet,
      id: wallet.id || id
      // Ensure id is always present
    }));
  }
};
_PNP.adapterRegistry = {};
let PNP = _PNP;
const createPNP = (config = {}) => new PNP(config);
export {
  createPNP as A,
  BaseSignerWalletAdapter as B,
  EventEmitter$1 as E,
  PublicKey as P,
  SolanaSignAndSendTransaction as S,
  Transaction as T,
  VersionedTransaction as V,
  WalletConnectionError as W,
  getAugmentedNamespace as a,
  bufferExports as b,
  createStore as c,
  clear as d,
  del as e,
  get as f,
  getDefaultExportFromCjs$1 as g,
  base58 as h,
  isVersionedTransaction as i,
  WalletReadyState as j,
  keys as k,
  WalletNotReadyError as l,
  WalletAdapterNetwork as m,
  WalletWindowClosedError as n,
  WalletDisconnectionError as o,
  WalletNotConnectedError as p,
  WalletSignTransactionError as q,
  requireBuffer as r,
  set as s,
  WalletSignMessageError as t,
  SolanaSignTransaction as u,
  SolanaSignMessage as v,
  createPNPConfig as w,
  PnpState as x,
  PnpEventType as y,
  PNP as z
};
